<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.coder.love","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="青马流光的博客">
<meta property="og:url" content="http://blog.coder.love/index.html">
<meta property="og:site_name" content="青马流光的博客">
<meta property="og:description" content="学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="青马流光">
<meta property="article:tag" content="Java、数据">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://blog.coder.love/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>青马流光的博客</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">青马流光的博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Code the love to the world.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">青马流光</p>
  <div class="site-description" itemprop="description">学习笔记</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.coder.love/2022/03/21/SpringBoot-AOP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="青马流光">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="青马流光的博客">
      <meta itemprop="description" content="学习笔记">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 青马流光的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/21/SpringBoot-AOP/" class="post-title-link" itemprop="url">SpringBoot-AOP</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-03-21 15:06:25 / 修改时间：17:07:11" itemprop="dateCreated datePublished" datetime="2022-03-21T15:06:25+08:00">2022-03-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><font color='00FF00'>——————————————————————关于Spring AOP——————————————————————</font></p>
<h1 id="1-EnableAspectJAutoProxy"><a href="#1-EnableAspectJAutoProxy" class="headerlink" title="1. @EnableAspectJAutoProxy"></a>1. @EnableAspectJAutoProxy</h1><p>如下来自其注释。</p>
<blockquote>
<p>支持处理用AspectJ的@Aspect注解标记的组件，类似于在Spring的  aop:aspectj-autoproxy XML元素中找到的功能。<br>在@Configuration类上使用如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line">   <span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">       <span class="meta">@Bean</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> FooService <span class="title">fooService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> FooService();</span><br><span class="line">       &#125;</span><br><span class="line">  </span><br><span class="line">       <span class="meta">@Bean</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> MyAspect <span class="title">myAspect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> MyAspect();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>FooService是一个典型的POJO组件，而MyAspect是一个@Aspect风格的方面:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooService</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">       <span class="comment">// various methods</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Aspect</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">       <span class="meta">@Before(&quot;execution(* FooService+.*(..))&quot;)</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">advice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">// advise FooService methods as appropriate</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在上面的场景中，@EnableAspectJAutoProxy确保了MyAspect将被正确处理，并且FooService将在它提供的通知中被代理混合。<br>用户可以使用proxyTargetClass()属性来控制为FooService创建的代理类型。下面启用cglib风格的“子类”代理，而不是默认的基于接口的JDK代理方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line">   <span class="meta">@EnableAspectJAutoProxy(proxyTargetClass=true)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>请注意@Aspect bean可以像其他任何bean一样被组件扫描。简单地用@Aspect和@Component标记切面:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.foo;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Component</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooService</span> </span>&#123; ... &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Aspect</span></span><br><span class="line">   <span class="meta">@Component</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>注意；@EnableAspectJAutoProxy只适用于它的本地应用程序上下文，允许在不同级别上选择性地代理bean。 请在每个单独的上下文中重新声明@EnableAspectJAutoProxy，例如公共的根web应用程序上下文和任何单独的DispatcherServlet应用程序上下文，如果你需要在多个级别应用它的行为。<br>这个特性需要aspectjweaver出现在类路径上。虽然这个依赖通常对于spring-aop是可选的，但是对于@EnableAspectJAutoProxy及其底层工具来说是必需的。</p>
</blockquote>
<p><strong>@EnableAspectJAutoProxy通过添加@Import注解引入了AspectJAutoProxyRegistrar.class。</strong></p>
<h1 id="2-AspectJAutoProxyRegistrar"><a href="#2-AspectJAutoProxyRegistrar" class="headerlink" title="2. AspectJAutoProxyRegistrar"></a>2. AspectJAutoProxyRegistrar</h1><ul>
<li>根据给定的@EnableAspectJAutoProxy注解，在当前的BeanDefinitionRegistry中注册一个<strong>AnnotationAwareAspectJAutoProxyCreator</strong>。</li>
<li>基于导入的@Configuration类上的@EnableAspectJAutoProxy.proxyTargetClass()属性的值，注册、升级和配置AspectJ自动代理创建器</li>
<li>AspectJAutoProxyRegistrar实现自ImportBeanDefinitionRegistrar接口。</li>
</ul>
<blockquote>
<p><strong>ImportBeanDefinitionRegistrar</strong></p>
<p>接口，由在处理@Configuration类时注册额外bean定义的类型实现。当在bean定义级别(与@Bean方法/实例级别相反)操作时，需要或必须使用。</p>
<p>与@Configuration和ImportSelector一起，这种类型的类可以提供给@Import注解(也可以从ImportSelector返回)。</p>
<p><font color='FF0000'>是在什么时候被调用的？</font></p>
<p>ImportBeanDefinitionRegistrar可以实现以下任何一个Aware接口，它们各自的方法将在registerBeanDefinitions之前被调用:</p>
<ul>
<li>EnvironmentAware</li>
<li>BeanFactoryAware</li>
<li>BeanClassLoaderAware</li>
<li>ResourceLoaderAware</li>
</ul>
<p>或者，该类可以提供唯一的构造函数，其中包含一个或多个受支持的形参类型:</p>
<ul>
<li>Environment</li>
<li>BeanFactory</li>
<li>ClassLoader</li>
<li>ResourceLoader</li>
</ul>
<p>有关使用示例，请参阅实现和相关的单元测试</p>
</blockquote>
<h1 id="3-AnnotationAwareAspectJAutoProxyCreator"><a href="#3-AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="3. AnnotationAwareAspectJAutoProxyCreator"></a>3. AnnotationAwareAspectJAutoProxyCreator</h1><blockquote>
<p>处理当前应用上下文中所有AspectJ注解切面的<strong>AspectJAwareAdvisorAutoProxyCreator</strong>子类，以及Spring Advisor。</p>
<p>任何带有AspectJ注解的类都将被自动识别，如果Spring AOP的基于代理的模型能够应用它们，那么它们的通知将被应用。这包括了方法执行连接点。</p>
<p>如果使用了aop:include元素，只有名称与包含模式匹配的@AspectJ bean才会被认为定义了用于Spring自动代理的方面。</p>
<p>Spring Advisors的处理遵循在org.springframework.aop.framework.autoproxy.<strong>AbstractAdvisorAutoProxyCreator</strong>中建立的规则。</p>
</blockquote>
<ul>
<li><p>它有两个AspectJAdvisorFactory和BeanFactoryAspectJAdvisorsBuilder类型的成员：aspectJAdvisorFactory和aspectJAdvisorsBuilder。aspectJAdvisorFactory为ReflectiveAspectJAdvisorFactory的实例，并用aspectJAdvisorFactory构造了aspectJAdvisorsBuilder。</p>
</li>
<li><p>findCandidateAdvisors方法</p>
<blockquote>
<p>-&gt; 调用了aspectJAdvisorsBuilder.buildAspectJAdvisors()</p>
<p>-&gt; 调用了aspectJAdvisorFactory.getAdvisors(…)   【ReflectiveAspectJAdvisorFactory::getAdvisors(…)】</p>
</blockquote>
</li>
</ul>
<h1 id="4-AbstractAdvisorAutoProxyCreator"><a href="#4-AbstractAdvisorAutoProxyCreator" class="headerlink" title="4. AbstractAdvisorAutoProxyCreator"></a>4. AbstractAdvisorAutoProxyCreator</h1><blockquote>
<p>通用的自动代理生成器，根据检测到的每个bean的advisor为特定bean构建AOP代理。</p>
<p><strong>子类可以重写findCandidateAdvisors()方法来返回应用于任何对象的自定义advisor列表。 子类还可以重写继承的shouldSkip方法，以排除某些对象的自动代理。</strong></p>
<p>需要排序的顾问或建议应该用@Order注解，或者实现org.springframework.core.Ordered接口。 这个类使用AnnotationAwareOrderComparator对顾问进行排序。 没有使用@Order注释或没有实现Ordered接口的advisor将被认为是无序的;它们将以未定义的顺序出现在advisor链的末尾。</p>
</blockquote>
<ul>
<li>继承自<strong>AbstractAutoProxyCreator</strong>。</li>
</ul>
<h1 id="5-AbstractAutoProxyCreator"><a href="#5-AbstractAutoProxyCreator" class="headerlink" title="5. AbstractAutoProxyCreator"></a>5. AbstractAutoProxyCreator</h1><blockquote>
<p>org.springframework.beans.factory.config.<strong>BeanPostProcessor</strong>的实现， 它用AOP代理包装每个合格的bean，在调用bean本身之前委托给指定的拦截器。</p>
<ul>
<li><p>BeanPostProcessor</p>
<blockquote>
<ul>
<li><p>工厂钩子，允许自定义修改新bean实例——例如，检查标记接口或用代理包装bean。</p>
</li>
<li><p>通常，通过标记接口或类似的方式填充bean的后处理器将实现postProcessBeforeInitialization， 而用代理包装bean的后处理器通常将实现postProcessAfterInitialization。</p>
</li>
<li><p>注册</p>
<p>ApplicationContext可以在它的bean定义中自动检测BeanPostProcessor bean，并将这些后处理器应用到随后创建的任何bean。 普通的BeanFactory允许以编程方式注册后处理程序，将它们应用于通过bean工厂创建的所有bean。</p>
</li>
<li><p>排序</p>
<p>在ApplicationContext中被自动检测到的BeanPostProcessor bean将根据 org.springframework.core.prioritordered和org.springframework.core.Ordered语义进行排序。 相反，以编程方式注册到BeanFactory的BeanPostProcessor bean将按照注册的顺序应用; 对于以编程方式注册的后处理器，任何通过实现prioritorderordered或Ordered接口表示的排序语义都将被忽略。 而且，对于BeanPostProcessor bean， @Order注解没有被考虑在内</p>
</li>
</ul>
</blockquote>
</li>
<li><p>postProcessBeforeInstantiation</p>
<p>-&gt; createProxy</p>
<blockquote>
<p>为给定的bean创建AOP代理。</p>
</blockquote>
<p>-&gt; ProxyFactory::getProxy</p>
<blockquote>
<p>根据该工厂中的设置创建一个新的代理。</p>
</blockquote>
<p>-&gt; ProxyCreatorSupport::createAopProxy</p>
<blockquote>
<ul>
<li><p>ProxyCreatorSupport</p>
<blockquote>
<p>代理工厂的基类。提供对可配置的AopProxyFactory的方便访问</p>
<ul>
<li><p>AopProxyFactory</p>
<blockquote>
<p>接口，由工厂实现，这些工厂能够基于AdvisedSupport配置对象创建AOP代理。</p>
<p>代理人须遵守以下合约:</p>
<ul>
<li>它们应该实现配置指出应该代理的所有接口。</li>
<li>它们应该实现被建议的接口。</li>
<li>它们应该实现equals方法来比较代理接口、通知和目标。</li>
<li>如果所有的advisor和target都是可序列化的，它们应该是可序列化的。</li>
<li>如果advisor和target是线程安全的，那么它们应该是线程安全的。</li>
</ul>
<p>代理可能允许也可能不允许更改通知。如果它们不允许更改通知(例如，因为配置被冻结)，代理应该在尝试更改通知时抛出AopConfigException。</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<p>-&gt; DefaultAopProxyFactory::createAopProxy</p>
<blockquote>
<ul>
<li><p>DefaultAopProxyFactory</p>
<blockquote>
<p>默认的AopProxyFactory实现，创建CGLIB代理或JDK动态代理。</p>
<p><font color='00FF00'>创建一个CGLIB代理，如果一个给定的AdvisedSupport实例如下所示:</font></p>
<ul>
<li>设置了 optimize 标志</li>
<li>设置了 proxyTargetClass 标志</li>
<li>没有指定代理接口</li>
</ul>
<p>通常，指定proxyTargetClass来强制使用CGLIB代理，或者指定一个或多个接口来使用JDK动态代理。</p>
</blockquote>
</li>
</ul>
</blockquote>
<p>-&gt; AopProxy::getProxy</p>
<blockquote>
<ul>
<li><p>AopProxy</p>
<blockquote>
<p>用于已配置的AOP代理的委托接口，允许创建实际的代理对象。</p>
<p>JDK动态代理和CGLIB代理都有现成的实现，由DefaultAopProxyFactory应用。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/image-20220315162419708.png" alt="image-20220315162419708"></p>
</blockquote>
</li>
<li><p>JdkDynamicAopProxy::getProxy</p>
<blockquote>
<p><font color='FF0000'>JdkDynamicAopProxy的invoke方法是在哪里调用的？</font></p>
</blockquote>
<p>-&gt; Proxy.newProxyInstance  【jdk java.lang.reflect】</p>
<blockquote>
<p>返回指定接口的代理实例，该接口将方法调用分派给指定的调用处理程序。</p>
<p>如果违反了以下任何一个限制，将会抛出IllegalArgumentException:</p>
<p>……</p>
<p>请注意，指定的代理接口的顺序是重要的:对具有相同接口组合但顺序不同的代理类的两个请求将导致两个不同的代理类。</p>
</blockquote>
<p>-&gt; Constructor::newInstance</p>
</li>
<li><p>ObjenesisCglibAopProxy::getProxy</p>
<blockquote>
<p>基于对象的CglibAopProxy扩展，在不调用类构造函数的情况下创建代理实例。在Spring 4中默认使用。</p>
<ul>
<li><p>CglibAopProxy</p>
<blockquote>
<p>面向Spring AOP框架的基于cglib的AopProxy实现。</p>
<p>这种类型的对象应该通过代理工厂获得，由AdvisedSupport对象配置。这个类是Spring AOP框架的内部类，客户机代码不需要直接使用它。</p>
<p>如果需要，DefaultAopProxyFactory将自动创建基于cglib的代理，例如在代理一个目标类的情况下(有关详细信息，请参阅代理javadoc)。</p>
<p>如果底层(目标)类是线程安全的，则使用该类创建的代理是线程安全的。</p>
</blockquote>
</li>
</ul>
</blockquote>
<p>-&gt; SpringObjenesis::newInstance  ||  Constructor::newInstance</p>
<blockquote>
<ul>
<li><p>SpringObjenesis</p>
<blockquote>
<p>特定于Spring的ObjenesisStd / ObjenesisBase的变体，提供基于Class键而不是类名的缓存，并允许选择性地使用缓存。</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p>postProcessAfterInitialization</p>
<blockquote>
<p>如果bean被子类标识为代理，则使用配置的拦截器创建代理</p>
</blockquote>
<p>-&gt; wrapIfNecessary</p>
<p>-&gt; createProxy</p>
</li>
</ul>
<p>这个类区分“公共”拦截器:为它创建的所有代理共享，和“特定”拦截器:每个bean实例唯一。 不需要任何通用的拦截器。如果有，则使用interceptorNames属性设置它们。</p>
</blockquote>
<p><font color='00FF00'>——————————————那么AnnotationAwareAspectJAutoProxyCreator是什么时候怎么起作用的呢？——————————————</font></p>
<h1 id="7-AbstractAutowireCapableBeanFactory"><a href="#7-AbstractAutowireCapableBeanFactory" class="headerlink" title="7. AbstractAutowireCapableBeanFactory"></a>7. AbstractAutowireCapableBeanFactory</h1><ul>
<li>initializeBean -&gt; <ul>
<li>applyBeanPostProcessorsBeforeInitialization</li>
<li>applyBeanPostProcessorsAfterInitialization</li>
</ul>
</li>
</ul>
<h1 id="8-DefaultSingletonBeanRegistry"><a href="#8-DefaultSingletonBeanRegistry" class="headerlink" title="8. DefaultSingletonBeanRegistry"></a>8. DefaultSingletonBeanRegistry</h1><p>getSingleton</p>
<blockquote>
<p>处理循环引用。</p>
</blockquote>
<h1 id="PropertyAccessorFactory（spring-beans）"><a href="#PropertyAccessorFactory（spring-beans）" class="headerlink" title="PropertyAccessorFactory（spring-beans）"></a>PropertyAccessorFactory（spring-beans）</h1><ul>
<li>获取PropertyAccessor实例的简单工厂facade，特别是对于BeanWrapper实例。隐藏实际的目标实现类及其扩展的公共签名。</li>
</ul>
<h1 id="HandlerInterceptor（spring-webmvc）"><a href="#HandlerInterceptor（spring-webmvc）" class="headerlink" title="HandlerInterceptor（spring-webmvc）"></a>HandlerInterceptor（spring-webmvc）</h1><blockquote>
<p>HandlerInterceptor基本上类似于Servlet Filter，但与后者相比，它只允许自定义预处理（可以选择禁止处理程序本身的执行），以及自定义后处理。过滤器功能更强大，例如，它们允许交换传递给链的请求和响应对象。请注意，过滤器是在web .xml中配置的，它是应用程序上下文中的HandlerInterceptor。</p>
</blockquote>
<h1 id="WebRequestInterceptor"><a href="#WebRequestInterceptor" class="headerlink" title="WebRequestInterceptor"></a>WebRequestInterceptor</h1><blockquote>
<p>接口，一般的web请求拦截。允许通过构建WebRequest抽象来应用于Servlet请求。<br>该接口采用<strong>mvc风格的请求处理:执行一个处理程序，公开一组模型对象，然后根据该模型呈现视图。</strong>另外，处理程序也可以完全处理请求，而不呈现视图。</p>
</blockquote>
<h1 id="RequestMappingHandlerMapping"><a href="#RequestMappingHandlerMapping" class="headerlink" title="RequestMappingHandlerMapping"></a>RequestMappingHandlerMapping</h1><blockquote>
<p>从@Controller类的类型和方法级的@RequestMapping注释中创建RequestMappingInfo实例。<br>弃用注意:<br>在5.2.4中，useSuffixPatternMatch和useRegisteredSuffixPatternMatch被弃用，以阻止使用路径扩展来进行请求映射和内容协商(与ContentNegotiationManagerFactoryBean中类似的弃用)。有关更多内容，请阅读第24719期。</p>
</blockquote>
<h1 id="BeanNameUrlHandlerMapping"><a href="#BeanNameUrlHandlerMapping" class="headerlink" title="BeanNameUrlHandlerMapping"></a>BeanNameUrlHandlerMapping</h1><blockquote>
<p>实现了org.springframe.web.servlet.HandlerMapping接口，该接口将url映射到名称以斜杠(“/”)开头的bean，类似于Struts将url映射到动作名称的方式。<br>这是org.springframework.web.servlet使用的默认实现。DispatcherServlet，以及org.springframework.web.servlet.mvc.method.annotation .RequestMappingHandlerMapping。另外，SimpleUrlHandlerMapping允许以声明的方式自定义处理程序映射。<br>映射是从URL到bean名。因此，一个传入的URL“/foo”将映射到一个名为“/foo”的处理程序，或者映射到“/foo /foo2”，如果多个映射到一个单独的处理程序。<br>支持直接匹配(给定”/test” -&gt;注册”/test”)和”<em>“匹配(给定”/test” -&gt;注册”/t</em>“)。注意，默认情况下，如果适用，映射到当前servlet映射中;详见”alwaysUseFullPath”属性。关于模式选项的详细信息，请参见org.springframework.util.AntPathMatcher javadoc。</p>
</blockquote>
<h1 id="ProxyFactory"><a href="#ProxyFactory" class="headerlink" title="ProxyFactory"></a>ProxyFactory</h1><blockquote>
<p>用于编程使用的AOP代理的工厂，而不是通过bean工厂中的声明性设置。这个类提供了一种在自定义用户代码中获取和配置AOP代理实例的简单方法。</p>
</blockquote>
<h1 id="AopProxyFactory-gt-DefaultAopProxyFactory"><a href="#AopProxyFactory-gt-DefaultAopProxyFactory" class="headerlink" title="AopProxyFactory -&gt; DefaultAopProxyFactory"></a>AopProxyFactory -&gt; DefaultAopProxyFactory</h1><blockquote>
<p><strong>DefaultAopProxyFactory</strong></p>
<p>默认的AopProxyFactory实现，创建CGLIB代理或JDK动态代理。</p>
<p>创建一个CGLIB代理，如果一个给定的AdvisedSupport实例如下所示:</p>
<ul>
<li>设置了 optimize 标志</li>
<li>设置了 proxyTargetClass 标志</li>
<li>没有指定代理接口</li>
</ul>
<p>通常，指定proxyTargetClass来强制使用CGLIB代理，或者指定一个或多个接口来使用JDK动态代理</p>
</blockquote>
<ul>
<li>createAopProxy</li>
</ul>
<h1 id="BeanDefinitionRegistry"><a href="#BeanDefinitionRegistry" class="headerlink" title="BeanDefinitionRegistry"></a>BeanDefinitionRegistry</h1><ul>
<li>保存bean定义的注册中心的接口，例如RootBeanDefinition和ChildBeanDefinition实例。 通常由内部使用AbstractBeanDefinition层次结构的Beanfactories实现。</li>
<li>这是Spring bean工厂包中封装bean定义注册的唯一接口。标准的BeanFactory接口只包括对完全配置的工厂实例的访问。</li>
<li>Spring bean定义的读者希望使用这个接口的实现。Spring core 中已知的实现者有DefaultListableBeanFactory和GenericApplicationContext。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.coder.love/2022/03/21/SpringBoot-web-%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="青马流光">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="青马流光的博客">
      <meta itemprop="description" content="学习笔记">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 青马流光的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/21/SpringBoot-web-%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">SpringBoot-web-问题记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-03-21 15:06:25 / 修改时间：17:07:11" itemprop="dateCreated datePublished" datetime="2022-03-21T15:06:25+08:00">2022-03-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="1-lib-spring-core-无法关联源码？"><a href="#1-lib-spring-core-无法关联源码？" class="headerlink" title="1. lib spring-core 无法关联源码？"></a>1. lib spring-core 无法关联源码？</h3><p>解决：spring-core依赖中的jar是0字节，需删除重新倒入该依赖。即可。</p>
<h3 id="2-中文编码问题？"><a href="#2-中文编码问题？" class="headerlink" title="2. 中文编码问题？"></a>2. 中文编码问题？</h3><p>参考：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.6.4/reference/htmlsingle/#web.servlet.spring-mvc.message-converters">https://docs.spring.io/spring-boot/docs/2.6.4/reference/htmlsingle/#web.servlet.spring-mvc.message-converters</a><br>中17.4.4。<br>说明：Spring MVC使用HttpMessageConverter接口来转换HTTP请求和响应。明智的默认值包括在开箱即用。例如，对象可以自动转换为JSON(通过使用Jackson库)或XML(如果Jackson XML扩展可用，则使用Jackson XML扩展;如果Jackson XML扩展不可用，则使用JAXB)。默认情况下，字符串采用UTF-8编码。<br>如果你需要添加或自定义转换器，你可以使用Spring Boot的HttpMessageConverters类，如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHttpMessageConvertersConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> HttpMessageConverters <span class="title">customConverters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HttpMessageConverter&lt;?&gt; additional = <span class="keyword">new</span> AdditionalHttpMessageConverter();</span><br><span class="line">    HttpMessageConverter&lt;?&gt; another = <span class="keyword">new</span> AnotherHttpMessageConverter();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HttpMessageConverters(additional, another);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上下文中出现的任何HttpMessageConverter bean都被添加到转换器列表中。您也可以用同样的方法重写默认转换器。<br>Spring使用HttpMessageConverters来渲染@ResponseBody(或@RestController的响应)。您可以通过在Spring Boot上下文中添加适当类型的bean来贡献其他转换器。如果您添加的bean是默认情况下已经包含的类型(例如用于JSON转换的MappingJackson2HttpMessageConverter)，那么它将替换默认值。提供了HttpMessageConverters类型的方便bean，如果您使用默认的MVC配置，它总是可用的。它有一些有用的方法来访问默认的和用户增强的消息转换器(例如，如果您想手动将它们注入到自定义的RestTemplate中，它可能很有用)。<br>解决：如HttpMessageConverterConfig。</p>
<h3 id="3-Aspect-找不到。"><a href="#3-Aspect-找不到。" class="headerlink" title="3. @Aspect 找不到。"></a>3. @Aspect 找不到。</h3><p>解决：添加依赖spring-boot-starter-aop，它会引入aspectjweaver依赖，@Aspect为其中注解。</p>
<h3 id="4-未生效"><a href="#4-未生效" class="headerlink" title="4. 未生效"></a>4. 未生效</h3><p>解决：@Aspect类要通过添加@Component或@Bean等注解由容器创建其实例才能生效。</p>
<h3 id="5-After逻辑中通过Method对象获取的方法上的注解列表不完整"><a href="#5-After逻辑中通过Method对象获取的方法上的注解列表不完整" class="headerlink" title="5. @After逻辑中通过Method对象获取的方法上的注解列表不完整"></a>5. @After逻辑中通过Method对象获取的方法上的注解列表不完整</h3><p>见：BizLogAspect。</p>
<p>原因：自定义的注解BizLogAnnotation没有添加元注解@Retention(RetentionPolicy.RUNTIME)。</p>
<blockquote>
<p>扩展：通过代理模式生成代理对象上的方法不会有注解，我们要取注解只能从目标对象中取。</p>
<p>错误写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处method获取的是代理对象（由代理模式生成的对象）的方法</span></span><br><span class="line">Method method1 = ((MethodSignature) joinPoint.getSignature()).getMethod();</span><br><span class="line"><span class="comment">// 此处annotation==null</span></span><br><span class="line">Annotation annotation = method1.getAnnotation(BizLogAnnotation.class);</span><br></pre></td></tr></table></figure>

<p>正确写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">targetClass = Class.forName(targetName);</span><br><span class="line"><span class="comment">// 此处是目标对象的原始方法。</span></span><br><span class="line">Method[] methods = targetClass.getMethods();</span><br><span class="line">BizLogAnnotation bizLogAnnotation = methods[<span class="number">0</span>].getAnnotation(BizLogAnnotation.class);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="6-Indexed注解"><a href="#6-Indexed注解" class="headerlink" title="6. @Indexed注解"></a>6. @Indexed注解</h3><p>注释中描述：</p>
<blockquote>
<p>指示带注解的元素表示索引的构造型。</p>
<p>CandidateComponentsIndex是类路径扫描的替代方法，它使用在编译时生成的元数据文件。索引允许基于原型检索候选组件(即完全限定的名称) 。该注解指示生成器对存在注释元素的元素进行索引，或者对注释元素进行实现或扩展。原型是被注释元素的完全限定名称。</p>
<p>考虑默认的Component注解，它是用这个注解进行元注解的。如果一个组件用Component来注解，那么该组件的一个条目将会被org.springframework.stereotype.Component模板添加到索引中。</p>
<p>这个注解也在元注解中得到了尊重。考虑如下定制注解:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line">   <span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line">   <span class="meta">@Documented</span></span><br><span class="line">   <span class="meta">@Indexed</span></span><br><span class="line">   <span class="meta">@Service</span></span><br><span class="line">   <span class="keyword">public</span> <span class="meta">@interface</span> PrivilegedService &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>如果上面的注释出现在一个类型上，它将被两个原型索引:org.springframework.stereotype.Component和com.example .PrivilegedService。虽然Service不是直接用Indexed注释的，但它是用Component元注释的。</p>
<p>也可以通过添加@Indexed来索引某个接口的所有实现或者给定类的所有子类。考虑以下基本接口:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Indexed</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AdminService</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>现在，考虑在某个地方实现这个AdminService:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.foo;</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">import</span> com.example.AdminService;</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationAdminService</span> <span class="keyword">implements</span> <span class="title">AdminService</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>因为这个类实现了一个被索引的接口，所以它将被自动包含在com.example.AdminService原型中。如果层次结构中有更多的@Indexed接口和/或超类，类将映射到它们所有的原型。</p>
</blockquote>
<p>其它参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/54chensongxia/p/14389134.html">@Indexed注解</a>、<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.2.6.RELEASE/spring-framework-reference/core.html#beans-scanning-index">官方文档</a>，但是6.0.0-M2版本官方文档中无相关介绍。</p>
<h3 id="7-Scope注解是怎么生效的？"><a href="#7-Scope注解是怎么生效的？" class="headerlink" title="7. @Scope注解是怎么生效的？"></a>7. @Scope注解是怎么生效的？</h3><p>ConfigurationClassPostProcessor</p>
<blockquote>
<p>BeanDefinitionRegistryPostProcessor</p>
<ul>
<li>扩展到标准的BeanFactoryPostProcessor SPI，允许在常规BeanFactoryPostProcessor检测开始之前注册更多的bean定义。特别是，BeanDefinitionRegistryPostProcessor可以注册更多的bean定义，这些定义反过来又定义了BeanFactoryPostProcessor实例。</li>
<li>继承自BeanFactoryPostProcessor。</li>
</ul>
</blockquote>
<p>-&gt; <strong>ConfigurationClassBeanDefinitionReader</strong>:loadBeanDefinitions中会检查有无@Scope注解，若有则根据其属性填充bean定义。</p>
<h3 id="8"><a href="#8" class="headerlink" title="8."></a>8.</h3><h1 id="待整理内容"><a href="#待整理内容" class="headerlink" title="待整理内容"></a>待整理内容</h1><ul>
<li><p>DefaultAopProxyFactory</p>
</li>
<li><p>AbstractAspectJAdvisorFactory -&gt; ReflectiveAspectJAdvisorFactory</p>
<blockquote>
<p>Spring AOP支持的Aspectj注解：Pointcut.class, Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class。</p>
</blockquote>
</li>
<li><p>AnnotationUtils</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.coder.love/2022/03/21/Spring%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="青马流光">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="青马流光的博客">
      <meta itemprop="description" content="学习笔记">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 青马流光的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/21/Spring%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">Spring应用启动过程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-03-21 15:06:25 / 修改时间：17:07:11" itemprop="dateCreated datePublished" datetime="2022-03-21T15:06:25+08:00">2022-03-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-SpringApplication"><a href="#1-SpringApplication" class="headerlink" title="1. SpringApplication"></a>1. SpringApplication</h1><blockquote>
<p>类，可用于从Java主方法引导和启动Spring应用程序。默认情况下，类将执行以下步骤来引导你的应用程序:</p>
<ul>
<li>创建适当的ApplicationContext实例(取决于您的类路径)</li>
<li>注册CommandLinePropertySource以将命令行参数公开为Spring属性</li>
<li>刷新应用程序上下文，加载所有单例beans</li>
<li>触发任何CommandLineRunner beans</li>
</ul>
</blockquote>
<h1 id="BootstrapContext"><a href="#BootstrapContext" class="headerlink" title="BootstrapContext"></a>BootstrapContext</h1><p>引导上下文</p>
<h1 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h1><p>应用上下文</p>
<blockquote>
<p>为应用程序提供配置的中央接口。在应用程序运行时，这是只读的，但如果实现支持，可能会重新加载。<br>一个ApplicationContext提供:</p>
<ul>
<li>用于访问应用程序组件的Bean工厂方法。从ListableBeanFactory继承。</li>
<li>以通用方式加载文件资源的能力。继承自org.springframework.core.io.ResourceLoader接口。</li>
<li>将事件发布到已注册侦听器的能力。继承自ApplicationEventPublisher接口。</li>
<li>解析消息的能力，支持国际化。继承自MessageSource接口。</li>
<li>从父上下文继承。后代上下文中的定义总是优先。这意味着，例如，一个单独的父上下文可以被整个web应用程序使用，而每个servlet都有自己独立于任何其他servlet的子上下文。</li>
</ul>
<p>除了标准的org.springframework.beans.factory.BeanFactory生命周期功能外，ApplicationContext实现检测和调用ApplicationContextAware bean以及ResourceLoaderAware、ApplicationEventPublisherAware和MessageSourceAware bean。</p>
</blockquote>
<h1 id="ApplicationContextInitializer"><a href="#ApplicationContextInitializer" class="headerlink" title="ApplicationContextInitializer"></a>ApplicationContextInitializer</h1><blockquote>
<ul>
<li>在刷新之前初始化一个Spring ConfigurableApplicationContext的回调接口。</li>
<li>通常用于需要对应用上下文进行编程初始化的web应用程序中。例如，根据上下文的环境注册属性源或激活概要文件。参见ContextLoader和FrameworkServlet 支持，分别声明一个“contextInitializerClasses”上下文参数和初始化参数。</li>
<li>ApplicationContextInitializer处理器被鼓励检测Spring的Ordered接口是否已经实现，或者是否存在@Order注解，如果存在，则在调用之前对实例进行排序。</li>
<li>在prepareContext()过程中应用。</li>
</ul>
</blockquote>
<h1 id="SpringApplicationRunListener"><a href="#SpringApplicationRunListener" class="headerlink" title="SpringApplicationRunListener"></a>SpringApplicationRunListener</h1><blockquote>
<ul>
<li><p>用于SpringApplication运行方法的侦听器。SpringApplicationRunListeners是通过SpringFactoriesLoader加载的，它应该声明一个公共构造函数，该构造函数接受一个SpringApplication实例和一个String[]参数。每次运行都会创建一个新的SpringApplicationRunListener实例</p>
</li>
<li><p>唯一实现：<strong>EventPublishingRunListener</strong></p>
<blockquote>
<ul>
<li><p>发布SpringApplicationEvents的SpringApplicationRunListener。</p>
</li>
<li><p>使用内部的<strong>ApplicationEventMulticaster</strong>来处理在上下文实际刷新之前触发的事件。</p>
<blockquote>
<p><strong>ApplicationEventMulticaster</strong></p>
<ul>
<li>由对象实现的接口，这些对象可以管理许多<strong>ApplicationListener</strong>对象并向它们发布事件。</li>
<li>一个org.springframework.context.ApplicationEventPublisher，通常是一个Spring org.springframework.context.ApplicationEventPublisher，可以使用一个ApplicationEventMulticaster作为一个委托来实际发布事件。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p>通过该接口可看出Spring Boot将运行过程分成几个环节（事件），对应spring-boot包context.event package 下的七个SpringApplicationEvent。</p>
<blockquote>
<ol>
<li><p>starting：当run方法第一次启动时立即调用。可以用于非常早期的初始化。</p>
<p>-&gt; ApplicationStartingEvent</p>
<blockquote>
<p>事件应该在SpringApplication启动后尽早发布——在环境或ApplicationContext可用之前，但在ApplicationListeners被注册之后。事件的源是SpringApplication本身，但是要注意在这个早期阶段不要过多地使用它的内部状态，因为它可能会在生命周期的后期被修改。</p>
</blockquote>
</li>
<li><p>environmentPrepared：在环境准备好之后，但在ApplicationContext创建之前调用。 </p>
<p>-&gt; ApplicationEnvironmentPreparedEvent</p>
<blockquote>
<p>事件发布时，一个SpringApplication正在启动，并且Environment第一次可用来检查和修改。</p>
</blockquote>
</li>
<li><p>contextPrepared：创建并准备好ApplicationContext，但在加载源之前调用。</p>
<p>-&gt; ApplicationContextInitializedEvent</p>
<blockquote>
<p>事件发布时，SpringApplication启动，ApplicationContext已经准备好，ApplicationContextInitializers已经被调用，但在任何bean定义被加载之前。</p>
</blockquote>
</li>
<li><p>contextLoaded：加载应用程序上下文后，在刷新应用程序上下文之前调用。</p>
<p>-&gt; ApplicationPreparedEvent</p>
<blockquote>
<p>事件发布时，一个SpringApplication正在启动，ApplicationContext已经完全准备好，但还没有刷新。bean定义将被加载，并且在这个阶段Environment已经可以使用了。</p>
</blockquote>
</li>
<li><p>started：上下文已经刷新，应用程序已经启动，但是CommandLineRunners和ApplicationRunners还没有被调用。</p>
<p>-&gt; ApplicationStartedEvent</p>
<blockquote>
<p>事件在刷新应用程序上下文之后，但在调用任何应用程序和命令行运行程序之前发布。</p>
</blockquote>
</li>
<li><p>ready：在run方法结束之前，当应用程序上下文已经被刷新并且所有的CommandLineRunners和ApplicationRunner已经被调用时，立即调用。</p>
<p>-&gt; ApplicationReadyEvent</p>
<blockquote>
<p>事件尽可能晚地发布，以表明应用程序已准备好为请求提供服务。事件的源是SpringApplication本身，但是要谨慎修改它的内部状态，因为那时所有的初始化步骤都已经完成了</p>
</blockquote>
</li>
<li><p>failed：当运行应用程序时发生故障时调用。</p>
<p>-&gt; ApplicationFailedEvent</p>
<blockquote>
<p>SpringApplication启动失败时发布的事件。</p>
</blockquote>
</li>
</ol>
</blockquote>
</li>
</ul>
</blockquote>
<h1 id="ApplicationListener"><a href="#ApplicationListener" class="headerlink" title="ApplicationListener"></a>ApplicationListener</h1><blockquote>
<ul>
<li>由应用程序事件侦听器实现的接口。</li>
<li>基于观察者设计模式的标准java.util.EventListener接口。</li>
<li>从Spring 3.0开始，ApplicationListener可以通用地声明它感兴趣的事件类型。当在Spring ApplicationContext中注册时，事件将被相应地过滤，只有匹配的事件对象才会调用侦听器。</li>
<li>不同于SpringApplicationRunListener，有一点关联，其关联可阅读EventPublishingRunListener。</li>
</ul>
</blockquote>
<h1 id="ApplicationContextFactory"><a href="#ApplicationContextFactory" class="headerlink" title="ApplicationContextFactory"></a>ApplicationContextFactory</h1><blockquote>
<ul>
<li><p>用于创建用于SpringApplication的ConfigurableApplicationContext的策略接口。创建的上下文应该以默认的形式返回，由SpringApplication负责配置和刷新上下文。 </p>
</li>
<li><p>其有一个功能接口create(WebApplicationType webApplicationType)，根据给定的webApplicationType为SpringApplication创建应用上下文。</p>
</li>
<li><p>默认实现：ApplicationContextFactory.DEFAULT</p>
<blockquote>
<ul>
<li>SERVLET -&gt; <strong>AnnotationConfigServletWebServerApplicationContext</strong></li>
<li>REACTIVE -&gt; <strong>AnnotationConfigReactiveWebServerApplicationContext</strong></li>
<li>default -&gt; AnnotationConfigApplicationContext</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h1 id="AnnotationConfigServletWebServerApplicationContext"><a href="#AnnotationConfigServletWebServerApplicationContext" class="headerlink" title="AnnotationConfigServletWebServerApplicationContext"></a>AnnotationConfigServletWebServerApplicationContext</h1><blockquote>
<ul>
<li><p>ServletWebServerApplicationContext，它接受带注解的类作为输入——特别是带@Configuration注解的类，但也接受普通的@Component类和使用javax兼容JSR-330 的javax.inject注解。允许逐个注册类(将类名指定为配置位置)以及类路径扫描(将基包指定为配置位置)。</p>
</li>
<li><p>注意:在有多个@Configuration类的情况下，后面的@Bean定义将覆盖前面加载文件中定义的定义。可以利用这一点，通过额外的Configuration类有意覆盖某些bean定义。</p>
</li>
<li><p>register(Class&lt;?&gt;… annotatedClasses)</p>
<blockquote>
<p>注册一个或多个要处理的带注解类。请注意，为了让上下文完全处理新类，必须调用<strong>refresh()<strong>。<br>调用#register是</strong>幂等</strong>的;多次添加同一个带注解的类不会产生额外的效果。</p>
</blockquote>
</li>
<li><p>scan(String… basePackages)</p>
<blockquote>
<p>在指定的基包中执行扫描。请注意，为了让上下文完全处理新类，必须调用**refresh()**。 </p>
</blockquote>
</li>
<li><p><strong>refresh()</strong></p>
<blockquote>
<p>继承自<strong>ServletWebServerApplicationContext</strong>的实现：在超类（<strong>AbstractApplicationContext</strong>）的refresh外层加了异常处理，发生运行时异常时关闭web服务器。</p>
</blockquote>
</li>
<li><p>其supertypes hierarchy：</p>
<blockquote>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/AnnotationConfigServletWebServerApplicationContext.jpg" alt="AnnotationConfigServletWebServerApplicationContext"></p>
<ul>
<li><p>BeanFactory：用于访问Spring bean容器的根接口。</p>
</li>
<li><p>AbstractApplicationContext</p>
<blockquote>
<ul>
<li>ApplicationContext接口的抽象实现。不强制要求用于配置的存储类型;简单地实现公共上下文功能。使用模板方法设计模式，需要具体的子类来实现抽象方法。</li>
<li>与普通的BeanFactory相反，ApplicationContext应该检测在其内部bean工厂中定义的特殊bean:因此，这个类自动注册了在上下文中定义为bean的BeanFactoryPostProcessors、BeanPostProcessors和ApplicationListeners。</li>
<li>MessageSource也可以在上下文中作为bean提供，命名为“messageSource”;否则，消息解析被委托给父上下文。此外，应用事件的多播器可以作为ApplicationEventMulticaster类型的bean在上下文中提供;否则，将使用SimpleApplicationEventMulticaster类型的默认multicaster。</li>
<li>通过扩展DefaultResourceLoader实现资源加载。因此，将非url资源路径视为类路径资源(支持包含包路径的完整类路径资源名，例如。”mypackage/myresource.dat”)，除非getResourceByPath方法在子类中被重写。</li>
</ul>
</blockquote>
</li>
<li><p>GenericApplicationContext</p>
<blockquote>
<ul>
<li>通用的ApplicationContext实现，保存单个内部DefaultListableBeanFactory实例，并且不采用特定的bean定义格式。实现BeanDefinitionRegistry 接口，以便对其应用任何bean定义读取器。</li>
<li>典型的用法是通过BeanDefinitionRegistry接口注册各种bean定义，然后调用refresh()来用应用上下文语义初始化这些bean(处理ApplicationContextAware，自动检测BeanFactoryPostProcessors，等等)。</li>
<li>与为每次刷新创建一个新的内部BeanFactory实例的其他ApplicationContext实现不同，此上下文的内部BeanFactory从一开始就可用，以便能够在其上注册bean定义。refresh() 只能被调用一次。</li>
<li>对于自定义应用程序上下文实现，这些实现应该以可刷新的方式读取特殊的bean定义格式，考虑从AbstractRefreshableApplicationContext基类派生。</li>
<li>该类无参构造中创建的<strong>DefaultListableBeanFactory</strong>的实例。</li>
</ul>
</blockquote>
</li>
<li><p>GenericWebApplicationContext</p>
<blockquote>
<ul>
<li>GenericApplicationContext的子类，适用于web环境。</li>
<li>实现了ConfigurableWebApplicationContext，但不是用于web.xml中的声明式设置。相反，它是为编程设置而设计的，例如用于构建嵌套上下文或在WebApplicationInitializer中使用。</li>
</ul>
</blockquote>
</li>
<li><p>ServletWebServerApplicationContext</p>
<blockquote>
<ul>
<li><p>一个WebApplicationContext，可以用来从包含的ServletWebServerFactory bean中引导自己。</p>
<blockquote>
<p>ServletWebServerFactory: 工厂接口，可以用来创建一个WebServer。</p>
</blockquote>
</li>
<li><p>这个上下文将通过在ApplicationContext本身中搜索单个ServletWebServerFactory bean来创建、初始化和运行一个WebServer。ServletWebServerFactory可以自由使用标准的Spring概念(比如依赖注入、生命周期回调和属性占位符变量)。</p>
</li>
<li><p>此外，任何在上下文中定义的Servlet或Filter bean都将自动注册到web服务器。在单个Servlet bean的情况下，将使用’/‘映射。如果发现多个Servlet bean，则小写的bean名称将用作映射前缀。任何名为’dispatcherServlet’的Servlet都会被映射到’/‘。筛选器bean将被映射到所有的url(‘/*’)。</p>
</li>
<li><p>对于更高级的配置，上下文可以定义实现ServletContextInitializer接口的bean(通常是ServletRegistrationBeans和/或FilterRegistrationBeans) 。为了防止重复注册，ServletContextInitializer bean的使用将禁用自动Servlet和Filter bean注册。</p>
</li>
<li><p>虽然这个上下文可以直接使用，但是大多数开发人员应该考虑使用AnnotationConfigServletWebServerApplicationContext或XmlServletWebServerApplicationContext的变体。</p>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li></li>
</ul>
</blockquote>
<h1 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h1><blockquote>
<ul>
<li><p>工厂钩子，允许自定义修改应用程序上下文的bean定义，调整上下文的底层bean工厂的bean属性值。 适用于针对系统管理员的定制配置文件，这些配置文件覆盖了在应用程序上下文中配置的bean属性。请参阅PropertyResourceConfigurer及其具体实现，了解满足此类配置需求的开箱即用解决方案。 <strong>BeanFactoryPostProcessor可以与bean定义进行交互和修改，但不能与bean实例进行交互。</strong>这样做可能会导致bean过早实例化，违反容器并导致意想不到的副作用。<strong>如果需要bean实例交互，可以考虑实现BeanPostProcessor</strong>。</p>
</li>
<li><p>注册</p>
<p>ApplicationContext在它的bean定义中自动检测BeanFactoryPostProcessor bean，并在创建任何其他bean之前应用它们。一个BeanFactoryPostProcessor也可以通过编程的方式注册一个ConfigurableApplicationContext。</p>
</li>
</ul>
</blockquote>
<h1 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h1><blockquote>
<ul>
<li><p>工厂钩子，允许自定义修改新bean实例——例如，检查标记接口或用代理包装bean。</p>
</li>
<li><p>通常，通过标记接口或类似的方式填充bean的后处理器将实现postProcessBeforeInitialization， 而用代理包装bean的后处理器通常将实现postProcessAfterInitialization。</p>
</li>
<li><p>注册</p>
<p>ApplicationContext可以在它的bean定义中自动检测BeanPostProcessor bean，并将这些后处理器应用到随后创建的任何bean。 普通的BeanFactory允许以编程方式注册后处理程序，将它们应用于通过bean工厂创建的所有bean。</p>
</li>
<li><p>postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)</p>
</li>
</ul>
</blockquote>
<h1 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h1><blockquote>
<ul>
<li><p>默认创建的<strong>DefaultListableBeanFactory</strong>的实例。</p>
<blockquote>
<ul>
<li><p>AnnotationConfigServletWebServerApplicationContext无参构造 -&gt; GenericApplicationContext无参构造。</p>
</li>
<li><p>DefaultListableBeanFactory</p>
<blockquote>
<ul>
<li>Spring对ConfigurableListableBeanFactory和BeanDefinitionRegistry接口的默认实现:一个基于bean定义元数据的成熟的bean工厂，可以通过后处理器进行扩展。</li>
<li>典型的用法是在访问bean之前，首先注册所有bean定义(可能是从bean定义文件中读取)。因此，按名称查找Bean是本地Bean定义表中的一种成本较低的操作，它对预先解析的Bean定义元数据对象进行操作。</li>
</ul>
</blockquote>
</li>
<li><p>DefaultListableBeanFactory的supertypes hierarchy</p>
<blockquote>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/DefaultListableBeanFactory.jpg" alt="DefaultListableBeanFactory"></p>
<ul>
<li><p>SingletonBeanRegistry</p>
<blockquote>
<p>为<strong>共享bean实例</strong>（即单例）定义注册表的接口。注意是注册bean实例而非bean定义。</p>
</blockquote>
</li>
<li><p>BeanDefinitionRegistry</p>
<blockquote>
<ul>
<li>保存<strong>bean定义</strong>的注册中心的接口。注意是注册的bean定义。</li>
<li>DefaultListableBeanFactory对其方法的实现大多在其超类中，如SimpleAliasRegistry和AbstractBeanFactory。</li>
</ul>
</blockquote>
</li>
<li><p>SimpleAliasRegistry</p>
<blockquote>
<p>AliasRegistry接口的简单实现。作为org.springframework.beans.factory.support.BeanDefinitionRegistry实现的基类。</p>
</blockquote>
</li>
<li><p>DefaultSingletonBeanRegistry</p>
<blockquote>
<ul>
<li>共享bean实例的通用注册中心，实现了<strong>SingletonBeanRegistry</strong>。允许注册应该为注册表的所有调用者共享的单例实例，通过bean名获得。</li>
<li>还支持注册可销毁的bean实例(它可能与已注册的单例对应，也可能不对应)，在注册表关闭时销毁。可以注册bean之间的依赖项以强制执行适当的关闭顺序。</li>
<li>这个类主要作为org.springframework.beans.factory.BeanFactory实现的基类，分解出单例bean实例的公共管理。注意，org.springframework.beans.factory .config.ConfigurableBeanFactory接口扩展了SingletonBeanRegistry接口。</li>
<li>请注意，与AbstractBeanFactory和DefaultListableBeanFactory(继承自该类)相比，该类既不假设bean定义概念，也不假设bean实例的特定创建过程。也可以作为可委托的嵌套助手使用。</li>
</ul>
</blockquote>
</li>
<li><p>FactoryBeanRegistrySupport</p>
<blockquote>
<ul>
<li><p>支持需要处理FactoryBean实例的单例注册表的基类，集成了DefaultSingletonBeanRegistry的单例管理。 作为AbstractBeanFactory的基类。</p>
</li>
<li><p>注意：getObjectFromFactoryBean</p>
</li>
</ul>
</blockquote>
</li>
<li><p>HierarchicalBeanFactory</p>
<blockquote>
<ul>
<li>由bean工厂实现的子接口，可以是层次结构的一部分。</li>
<li>允许以可配置方式设置父类的bean工厂的相应setParentBeanFactory方法可以在ConfigurableBeanFactory接口中找到。</li>
</ul>
</blockquote>
</li>
<li><p>ConfigurableBeanFactory</p>
<blockquote>
<ul>
<li>由大多数bean工厂实现的配置接口。除了BeanFactory接口中的bean工厂客户端方法外，还提供配置bean工厂的工具。</li>
<li>这个bean工厂接口并不打算用于普通的应用程序代码:对于典型的需求，请坚持使用BeanFactory或ListableBeanFactory。这个扩展的接口只是为了允许框架内部即插即用，以及对bean工厂配置方法的特殊访问。</li>
</ul>
</blockquote>
</li>
<li><p>AbstractBeanFactory</p>
<blockquote>
<ul>
<li>BeanFactory实现的抽象基类，提供了ConfigurableBeanFactory SPI的全部功能。不假设有一个listable bean工厂:因此也可以用作从后端资源(其中bean定义访问是一项开销很大的操作) 获取bean定义的bean工厂实现的基类。</li>
<li>这个类提供了一个单例缓存(通过它的基类DefaultSingletonBeanRegistry、单例/原型确定、FactoryBean处理、别名、子bean定义的bean定义合并和bean销毁（可丢弃的bean接口、自定义销毁方法））。此外，它还可以通过实现HierarchicalBeanFactory接口来管理bean工厂层次结构(在未知bean的情况下委托给父类)。</li>
<li><strong>子类要实现的主要模板方法是getBeanDefinition和createBean</strong>，分别为给定的bean名检索bean定义和为给定的bean定义创建bean实例。这些操作的<strong>默认实现</strong>可以在<strong>DefaultListableBeanFactory</strong>和<strong>AbstractAutowireCapableBeanFactory</strong>中找到。</li>
</ul>
</blockquote>
</li>
<li><p>AbstractAutowireCapableBeanFactory</p>
<blockquote>
<ul>
<li>抽象bean工厂超类，实现了默认的bean创建，具有由RootBeanDefinition类指定的全部功能。除了AbstractBeanFactory的createBean方法之外，还实现了AutowireCapableBeanFactory接口。</li>
<li>提供bean创建(通过构造函数解析)、属性填充、连接(包括自动装配)和初始化。 处理运行时bean引用、解析托管集合、调用初始化方法等。支持自动装配构造函数、按名称的属性和按类型的属性。</li>
<li>**子类要实现的主要模板方法是resolveDependency(DependencyDescriptor, String, Set, TypeConverter)**，用于按类型自动装配。 对于能够搜索其bean定义的工厂，匹配的bean通常通过这样的搜索来实现。对于其他工厂样式，可以实现简化的匹配算法。</li>
<li>请注意，该类不假设或实现bean定义注册表功能。ListableBeanFactory和BeanDefinitionRegistry接口的实现请参见DefaultListableBeanFactory，它们分别表示这样一个工厂的API和SPI视图。</li>
</ul>
</blockquote>
</li>
<li><p>ListableBeanFactory</p>
<blockquote>
<ul>
<li>BeanFactory接口的扩展，由<strong>可以枚举其所有bean实例</strong>的bean工厂来实现，而不是按照客户端的要求，逐个尝试按名称查找bean实例。预加载所有bean定义(例如基于xml的工厂)的BeanFactory实现可以实现这个接口。</li>
<li>如果这是一个HierarchicalBeanFactory，返回值将<strong>不考虑任何BeanFactory层次结构，而是只与当前工厂中定义的bean相关</strong>。也可以使用BeanFactoryUtils helper类来考虑祖先工厂中的bean。</li>
<li>这个接口中的方法将只尊重这个工厂的bean定义。它们会忽略任何已经通过其他方式注册的单例bean，比如ConfigurableBeanFactory的registerSingleton方法，除了getBeanNamesForType和getBeansOfType，它们也会检查手动注册的单例bean。当然，BeanFactory的getBean也允许对这些特殊的bean进行透明访问。但是，在典型的场景中，所有bean都将由外部bean定义，因此大多数应用程序不需要担心这种区别。</li>
<li>注意:除了getBeanDefinitionCount和containsBeanDefinition之外，此接口中的方法不是为频繁调用而设计的。实现可能会很慢。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h1 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h1><blockquote>
<ul>
<li>由BeanFactory中使用的对象实现的接口，BeanFactory本身就是单个对象的工厂。如果bean实现了这个接口，那么它将被用作要公开的对象的工厂，而不是直接用作将自身公开的bean实例。</li>
<li>注意:实现此接口的bean不能作为普通bean使用。FactoryBean是以bean样式定义的，但是为bean引用公开的对象(getObject())始终是它创建的对象。</li>
</ul>
</blockquote>
<h1 id="WebServer"><a href="#WebServer" class="headerlink" title="WebServer"></a>WebServer</h1><p>LazyInitializationBeanFactoryPostProcessor + LazyInitializationExcludeFilter</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.coder.love/2022/03/21/JVM%E8%B0%83%E4%BC%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="青马流光">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="青马流光的博客">
      <meta itemprop="description" content="学习笔记">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 青马流光的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/21/JVM%E8%B0%83%E4%BC%98/" class="post-title-link" itemprop="url">JVM调优</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-03-21 15:06:25 / 修改时间：18:01:04" itemprop="dateCreated datePublished" datetime="2022-03-21T15:06:25+08:00">2022-03-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="关于锁"><a href="#关于锁" class="headerlink" title="关于锁"></a>关于锁</h3><ul>
<li><p>自适应自旋</p>
<blockquote>
<p>默认开启。</p>
</blockquote>
</li>
<li><p>偏向锁</p>
<blockquote>
<p>默认开启。- XX:+UseBiased Locking</p>
<p>如果某一类锁对象的总撤销数超过了一个阈值（对应 Java 虚拟机参数<br>-XX:BiasedLockingBulkRebiasThreshold，默认为 20），那么 Java 虚拟机会宣布这个类的偏向锁失效。</p>
<p>如果总撤销数超过另一个阈值（对应 Java 虚拟机参数<br>-XX:BiasedLockingBulkRevokeThreshold，默认值为 40），那么 Java 虚拟机会认为这个类已经不再适合偏向锁。此时，Java 虚拟机会撤销该类实例的偏向锁，并且在之后的加锁过程中直接为该类实例设置轻量级锁。</p>
</blockquote>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.coder.love/2022/03/21/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="青马流光">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="青马流光的博客">
      <meta itemprop="description" content="学习笔记">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 青马流光的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/21/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">Java多线程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-03-21 15:06:25 / 修改时间：18:01:04" itemprop="dateCreated datePublished" datetime="2022-03-21T15:06:25+08:00">2022-03-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li><p>处理器缓存</p>
</li>
<li><p>内存屏障</p>
</li>
<li><p>Java多线程机制</p>
<blockquote>
<ul>
<li><p>三个关注点：原子性、可见性、有序性</p>
<blockquote>
<p>可见性即内存可见性；有序性即禁止重排序</p>
</blockquote>
</li>
<li><p>硬件</p>
<blockquote>
<p>硬件保证某些从语义上看起来需要多次操作的行为可以只通过一条处理器指令就能完成，这类指令常用的有： </p>
<ul>
<li>测试并设置（Test-and-Set）； </li>
<li>获取并增加（Fetch-and-Increment）； </li>
<li>交换（Swap）； </li>
<li>比较并交换（Compare-and-Swap，下文称CAS）； </li>
<li>加载链接/条件储存（Load-Linked/Store-Conditional，下文称LL/SC）。</li>
</ul>
<p>=&gt; Java中最终暴露出来的是CAS指令。</p>
</blockquote>
</li>
<li><p>class 文件层面</p>
<blockquote>
<ul>
<li><p>synchronized同步块：monitorenter &amp; monitorexit</p>
</li>
<li><p>synchronized方法：ACC_SYNCHRONIZED</p>
</li>
</ul>
</blockquote>
</li>
<li><p>JDK 并发包层面</p>
<blockquote>
<ul>
<li><p>Unsafe.park &amp; Unsafe.unpark基于mutex互斥量实现的线程挂起。可参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/a7980718/article/details/83661613">jdk1.8 Unsafe类 park和unpark方法解析</a></p>
</li>
<li><p>Unsafe中的三个内存屏障：loadFence() &amp; storeFence() &amp; fullFence()</p>
</li>
<li><p>Unsafe中的CAS指令</p>
</li>
<li><p>happen-before规则</p>
</li>
</ul>
</blockquote>
</li>
<li><p>happen-before 规则总结</p>
<blockquote>
<ol>
<li>单线程中的每个操作，happen-before于该线程中任意后续操作。 </li>
<li>对volatile变量的写，happen-before于后续对这个变量的读。 </li>
<li>对synchronized的解锁，happen-before于后续对这个锁的加锁。 </li>
<li>对final变量的写，happen-before于final域对象的读，happen-before于后续对final变量的读。 </li>
</ol>
<p>四个基本规则再加上happen-before的传递性，就构成JMM对开发者的整个承诺。在这个承诺以外的部分，程序都可能被重排序，都需要开发者小心地处理内存可见性问题。</p>
<p>Java语言规范17.4.5中描述如下：</p>
<ul>
<li>在监视器上的解锁动作在每个后续在该监视器上的锁定操作之前发生。</li>
<li>对volatile 域（第8.3.1.4节）的写操作在每个后续对该域的读操作之前发生。</li>
<li>在线程上对 start() 的调用在被启动线程的所有动作之前发生。</li>
<li>一个线程中的所有动作在任何其他线程成功地从该线程上的 join() 返回之前发生。</li>
<li>任何对象的缺省初始化在程序中其他任何动作（除了缺省的写操作）之前发生。</li>
</ul>
</blockquote>
</li>
<li><p>JDK8开始，Unsafe中提供的三个内存屏障</p>
<ul>
<li>loadFence()</li>
<li>storeFence()</li>
<li>fullFence()</li>
</ul>
<blockquote>
<p>在理论层面，可以把基本的CPU内存屏障分成四种： </p>
<p>（1）LoadLoad：禁止读和读的重排序。 </p>
<p>（2）StoreStore：禁止写和写的重排序。 </p>
<p>（3）LoadStore：禁止读和写的重排序。 </p>
<p>（4）StoreLoad：禁止写和读的重排序。</p>
<p>根据注释：</p>
<ul>
<li><p>loadFence=LoadLoad+LoadStore ，即禁止读-读、读-写重排序</p>
</li>
<li><p>storeFence=StoreStore+LoadStore ，即禁止读-写、写-写重排序</p>
</li>
<li><p>fullFence=loadFence+storeFence+StoreLoad，即禁止所有重排序</p>
</li>
</ul>
</blockquote>
</li>
<li><p>内存屏障 + happen-before 规则  =&gt;  synchronized、volatile、final</p>
<ul>
<li><p>synchronized：原子性、可见性、有序性</p>
</li>
<li><p>volatile：64位写入的原子性、可见性和有序性。</p>
</li>
<li><p>final：有序性 =&gt; 需要避免构造函数溢出问题（示例见FinalReferenceEscapeExample，参考<a target="_blank" rel="noopener" href="https://bbs.huaweicloud.com/blogs/136261">final引用不能从构造函数内“溢出”</a>）。</p>
<blockquote>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/1575361630931085.png" alt="image.png"></p>
</blockquote>
</li>
</ul>
</li>
<li><p>从底向上看volatile背后的原理：</p>
</li>
</ul>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/%E6%88%AA%E5%B1%8F%202021-10-29%20%E4%B8%8B%E5%8D%882.54.08.png" alt="截屏 2021-10-29 下午2.54.08" style="zoom: 33%;" />

<ul>
<li><p>CPU 的 CAS（Compare and Swap）指令 =&gt; unsafe中的CAS操作：CAS能够将read-modify-write和check-and-act之类的操作转换为原子操作。</p>
<blockquote>
<p>Y：CAS操作常作用于volatile变量，如此可同时保证对其操作的原子性、可见性、有序性。如Atomic类。</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p>Java部分多线程相关类的实现</p>
<p>整个Concurrent包的层次体系：</p>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/%E6%88%AA%E5%B1%8F%202021-10-29%20%E4%B8%8B%E5%8D%882.59.24.png" alt="截屏 2021-10-29 下午2.59.24" style="zoom: 33%;"/>

<ul>
<li><p>Atomic类</p>
<blockquote>
<p>volatile + CAS</p>
<ul>
<li><p>Unsafe类中提供了int、long、Object三种类型的CAS操作，其它类型可转换成这三种类型，如boolean转成int，double转成long。带版本号的int和long通过与版本号构造Pair对象，转成Object。</p>
</li>
<li><p>ABA问题 =&gt; 同时使用“值”和“版本号”，即AtomicStampedReference。</p>
<blockquote>
<p>目前来说AtomicStampedReference处于相当鸡肋的位置，大部分情况下ABA问题不会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更为高效。</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p>Lock 与 Condition</p>
<blockquote>
<p>为了实现一把具有阻塞或唤醒功能的锁，需要几个核心要素：</p>
<ul>
<li><p>① 需要一个state变量，标记该锁的状态。state变量至少有两个值：0、1。对state变量的操作，要确保线程安全，也就是会用到CAS。</p>
<blockquote>
<p>volatile + CAS</p>
<p>state取值不仅可以是0、1，还可以大于1，就是为了支持锁的可重入性。</p>
</blockquote>
</li>
<li><p>② 需要记录当前是哪个线程持有锁。</p>
<blockquote>
<p>普通成员变量即可。</p>
</blockquote>
</li>
<li><p>③ 需要底层支持对一个线程进行阻塞或唤醒操作。</p>
<blockquote>
<p>在Unsafe类中，提供了阻塞或唤醒线程的一对操作原语，也就是park/unpark。</p>
<p>LockSupport的工具类，对这一对原语做了简单封装。</p>
</blockquote>
</li>
<li><p>④ 需要有一个队列维护所有阻塞的线程。这个队列也必须是线程安全的无锁队列，也需要用到CAS。</p>
<blockquote>
<p><strong>AbstractQueuedSynchronizer：队列同步器（AQS）</strong></p>
<p>提供一个框架，用于实现依赖先进先出 (FIFO) 等待队列的阻塞锁和相关同步器（信号量、事件等）。 此类旨在成为大多数依赖单个原子int值来表示状态的同步器的有用基础。</p>
<p>要将此类用作同步器的基础，请根据适用情况重新定义以下方法，方法是使用getState 、 setState和/或compareAndSetState检查和/或修改同步状态：</p>
<ul>
<li>tryAcquire</li>
<li>tryRelease</li>
<li>tryAcquireShared</li>
<li>tryReleaseShared</li>
<li>isHeldExclusively</li>
</ul>
<p>Y：模版方法模式。</p>
<p>基于 volatile + CAS + 双向链表 实现无锁化阻塞队列。</p>
</blockquote>
</li>
</ul>
<p>Condition将Object监视方法(wait、notify和notifyAll)分解为不同的对象，通过使用任意的Lock实现将它们组合起来，从而实现每个对象拥有多个等待集的效果。<strong>在Lock替换synchronized方法和语句的地方，Condition替换Object监视方法的使用。</strong></p>
<p>Condition类注解中的一个示例：BoundedBuffer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如，假设我们有一个支持put和take方法的有界缓冲区。如果在一个空的缓冲区上尝试一个take，那么线程将会阻塞，直到一个项目变得可用;如果尝试在已满的缓冲区上执行put操作，则线程将阻塞，直到有可用空间为止。我们希望在单独的等待集中保持等待的put线程和取线程，这样当缓冲区中的项目或空间可用时，我们可以使用这种优化，即每次只通知单个线程。这可以通过使用两个Condition实例来实现。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">     <span class="keyword">final</span> Condition notFull  = lock.newCondition(); </span><br><span class="line">     <span class="keyword">final</span> Condition notEmpty = lock.newCondition(); </span><br><span class="line">  </span><br><span class="line">     <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">     <span class="keyword">int</span> putptr, takeptr, count;<span class="comment">//PTR 为 指针。</span></span><br><span class="line">  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 使用count 而非putptr，因为实现的环形缓冲区。</span></span><br><span class="line">         <span class="keyword">while</span> (count == items.length)</span><br><span class="line">           notFull.await();</span><br><span class="line">         items[putptr] = x;</span><br><span class="line">         <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">         ++count;</span><br><span class="line">         notEmpty.signal();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">           notEmpty.await();</span><br><span class="line">         Object x = items[takeptr];</span><br><span class="line">         <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">         --count;</span><br><span class="line">         notFull.signal();</span><br><span class="line">         <span class="keyword">return</span> x;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p><strong>ReentrantLock</strong></p>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/image-20211030000810955.png" alt="image-20211030000810955" style="zoom: 33%;" />

<ul>
<li>ReentrantLock.Sync采用的独占模式，其中实现了tryRelease和isHeldExclusively，tryAcquire交由子类实现，FairSync和NonfairSync分别通过该方法实现了公平锁和非公平锁。（非公平锁的tryAcquire逻辑使用了Sync的nonfairTryAcquire，因为ReentrantLock的tryLock方法会直接调用sync.nonfairTryAcquire即使用非公平锁逻辑）。</li>
</ul>
<p><strong>ReentrantReadWriteLock</strong></p>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/image-20211030000856693.png" alt="image-20211030000856693" style="zoom: 50%;" />

<ul>
<li>acquire/release、acquireShared/releaseShared 是AQS里面的两对模板方法。互斥锁和读写锁的写锁都是基于acquire/release模板方法来实现的。读写锁的读锁是基于acquireShared/releaseShared这对模板方法来实现的。</li>
</ul>
<p><strong>StampedLock</strong></p>
<ul>
<li><p>乐观读</p>
<blockquote>
<ul>
<li>StampedLock引入了“乐观读”策略，读的时候不加读锁，读出来发现数据被修改了，再升级为“悲观读”，相当于降低了“读”的地位，把抢锁的天平往“写”的一方倾斜了一下，避免写线程被饿死。</li>
<li>使用一个volatile 变量 state，表示读锁、写锁、版本号，获取释放锁时对state进行CAS操作。</li>
<li>直接使用了loadFence避免validate()与前边的读操作进行重排序。</li>
</ul>
</blockquote>
</li>
<li><p>悲观读写：自旋 + 阻塞</p>
<ul>
<li><p>没有基于AQS，自己实现阻塞队列</p>
<blockquote>
<ul>
<li><p>在AQS里面，当一个线程CAS state失败之后，会立即加入阻塞队列，并且进入阻塞状态。但在StampedLock中，CAS state失败之后，会不断自旋，自旋足够多的次数之后，如果还拿不到锁，才进入阻塞状态。为此，根据CPU的核数，定义了自旋次数的常量值。如果是单核的CPU，肯定不能自旋，在多核情况下，才采用自旋策略。</p>
</li>
<li><p>另外一个不同于AQS的阻塞队列的地方是，在每个WNode里面有一个cowait指针，用于串联起所有的读线程。例如，队列尾部阻塞的是一个读线程 1，现在又来了读线程 2、3，那么会通过cowait指针，把1、2、3串联起来。1被唤醒之后，2、3也随之一起被唤醒，因为读和读之间不互斥。</p>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>锁</th>
<th>并发度</th>
<th>阻塞队列</th>
</tr>
</thead>
<tbody><tr>
<td>ReentrantLock</td>
<td>读与读互斥，读与写互斥，写与写互斥</td>
<td>基于AQS</td>
</tr>
<tr>
<td>ReentrantReadWriteLock</td>
<td>读与读不互斥，读与写互斥，写与写互斥</td>
<td>基于AQS</td>
</tr>
<tr>
<td>StampedLock</td>
<td>读与读不互斥，读与写不一定不互斥，写与写互斥</td>
<td>自实现阻塞队列</td>
</tr>
</tbody></table>
<p><strong>Condition</strong> </p>
<ul>
<li><p>AbstractQueuedSynchronizer.ConditionObject</p>
<blockquote>
<ul>
<li><p>wait（）/notify（）必须和synchronized一起使用，Condition也是如此，必须和Lock一起使用。</p>
</li>
<li><p>其作用在于使线程阻塞并添加到阻塞队列中（await），唤醒阻塞队列中第一个或全部线程（signal、signalAll）,基于LockSupport。</p>
</li>
<li><p>在调用 await、signal、signalAll的时候，必须先拿到锁。</p>
</li>
<li><p>因其操作都在获取锁之后进行，所以不需要volatile、CAS等机制。 </p>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p>同步工具</p>
<blockquote>
<p><strong>Semaphore</strong></p>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/%E6%88%AA%E5%B1%8F%202021-10-31%20%E4%B8%8B%E5%8D%883.12.49.png" alt="截屏 2021-10-31 下午3.12.49" style="zoom:33%;" />

<p><strong>CountDownLatch</strong></p>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/%E6%88%AA%E5%B1%8F%202021-10-31%20%E4%B8%8B%E5%8D%883.29.21.png" alt="截屏 2021-10-31 下午3.29.21" style="zoom:33%;" />

<ul>
<li><p>因为是基于 AQS 阻塞队列来实现的，所以可以让多个线程都阻塞在state=0条件上，通过countDown()一直累减state，减到0后一次性唤醒所有线程。如图4-4所示，假设初始总数为M，N个线程await()，M个线程countDown()，减到0之后，N个线程被唤醒。</p>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/%E6%88%AA%E5%B1%8F%202021-10-31%20%E4%B8%8B%E5%8D%883.35.29.png" alt="截屏 2021-10-31 下午3.35.29" style="zoom: 50%;" />

<p>Y：</p>
<ul>
<li><p>CountDownLatch的构造参数设置的state的值，即M，调用await方法，只是判断state是否等于0，等于则返回相当于获取锁成功，不等则一直阻塞，不可被中断，因响应中断后会重复进入阻塞。进入阻塞的线程数N与M无关。</p>
</li>
<li><p>调用countDown，会修改state的值，仅当state修改后变为0时唤醒阻塞队列中的所有线程，countDown需调用M次。</p>
<blockquote>
<p>最后一次countDown操作后触发doReleaseShared方法以唤醒队列中线程，阻塞的所有线程不是同时唤醒的，而是从头节点依次唤醒的，即被唤醒的线程继续执行唤醒操作doReleaseShared去唤醒下一个。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/128476015902">https://www.jianshu.com/p/128476015902</a></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><strong>CyclicBarrier</strong></p>
<blockquote>
<ul>
<li>CyclicBarrier基于ReentrantLock + Condition实现。</li>
<li>CyclicBarrier是可以被重用的。</li>
<li>CyclicBarrier 会响应中断。</li>
<li>构造参数中的回调函数barrierAction只会被最后一个线程执行1次（在唤醒其他所有线程之前），而不是所有线程每个都执行1次。</li>
</ul>
<p>Y：其与CountDownLatch的区别：</p>
<ul>
<li>下一步动作的动作实施者是不一样的，CountDownLatch中是await的所有线程，CyclicBarrier是最后一个线程。</li>
<li>整个过程的参与者不同，CountDownLatch中有两种角色，await与countDown，两个可能完全无关。CyclicBarrier中只有一种。</li>
</ul>
</blockquote>
<p><strong>Exchanger</strong></p>
<blockquote>
<p>用于线程间交换数据。</p>
<p>Exchanger的核心机制和Lock一样，也是CAS+park/unpark。</p>
</blockquote>
<p><strong>Phaser</strong></p>
<blockquote>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/%E6%88%AA%E5%B1%8F%202021-10-31%20%E4%B8%8B%E5%8D%885.05.41.png" alt="截屏 2021-10-31 下午5.05.41" style="zoom: 50%;" />

<p>基于volatile state + CAS + 无锁栈 Treiber Stack（等待队列）。</p>
<p>主要方法：</p>
<ul>
<li>arrive、awaitAdvance  =&gt;  可替代CountDownLatch</li>
<li>arriveAndAwaitAdvance  =&gt;  可替代CyclicBarrier</li>
</ul>
<p>特性：</p>
<ul>
<li><p>动态调整线程个数；</p>
</li>
<li><p>层次Phaser。</p>
<blockquote>
<p>父Phaser并不用感知子Phaser的存在，当子Phaser中注册的参与者数量大于0时，会把自己向父节点注册；当子Phaser中注册的参与者数量等于0时，会自动向父节点解注册。父Phaser把子Phaser当作一个正常参与的线程就可以了。</p>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p>并发容器</p>
<blockquote>
<p><strong>BlockingQueue</strong></p>
<blockquote>
<p>入队提供了add（..）、offer（..）、put （..）3个函数，有什么区别呢？从上面的定义可以看到，add（..）和offer（..）的返回值是布尔类型，而put无返回值，还会抛出中断异常，所以add（..）和offer（..）是无阻塞的，也是Queue本身定义的接口，而put（..）是阻塞式的。add（..）和offer（..）的区别不大，当队列为满的时候，前者会抛出异常，后者则直接返回false。</p>
<p>出队列与之类似，提供了remove（）、peek（）、take（）等函数，remove（）和peek（）是非阻塞式的，take（）是阻塞式的。</p>
</blockquote>
<ul>
<li><p>ArrayBlockingQueue </p>
<blockquote>
<p>是一个用数组实现的环形队列，核心为 1 把锁 + 2 个条件，即lock + notEmpty + notFull。</p>
</blockquote>
</li>
<li><p>LinkedBlockingQueue </p>
<blockquote>
<p>LinkedBlockingQueue是一种基于单向链表的阻塞队列。因为队头和队尾是2个指针分开操作的，所以用了2把锁+2个条件，同时有1个AtomicInteger的原子变量记录count数。</p>
<p>核心 为 2 把锁 + 2 个条件，即 takeLock + notEmpty + putLock + notFull。</p>
</blockquote>
</li>
<li><p>PriorityBlockingQueue</p>
<blockquote>
<p>队列通常是先进先出的，而PriorityQueue是按照元素的优先级从小到大出队列的。正因为如此，PriorityQueue中的2个元素之间需要可以比较大小，并实现Comparable接口。</p>
<p>核心为 1 把锁 + 1 个条件，即 lock + notEmpty。</p>
</blockquote>
</li>
<li><p>DelayQueue</p>
<blockquote>
<p>DelayQueue即延迟队列，也就是一个按延迟时间从小到大出队的PriorityQueue。</p>
<p>核心为 1 把锁 + 1 个非空条件，即 lock + available。</p>
</blockquote>
</li>
<li><p>SynchronousQueue</p>
<blockquote>
<p>SynchronousQueue是一种特殊的BlockingQueue，它本身没有容量。先调put（..），线程会阻塞；直到另外一个线程调用了take（），两个线程才同时解锁，反之亦然。对于多个线程而言，例如3个线程，调用3次put（..），3个线程都会阻塞；直到另外的线程调用3次take（），6个线程才同时解锁，反之亦然。</p>
<p>两种模式：</p>
<ul>
<li>公平模式（队列模式）：TransferQueue  -&gt;  volatile + CAS</li>
<li>非公平模式（栈模式）：TransferStack  -&gt;  volatile + CAS</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>BlockingDeque</strong></p>
<blockquote>
<p>BlockingDeque定义了一个阻塞的双端队列接口。该接口在继承了BlockingQueue接口的同时，增加了对应的双端队列操作接口。该接口只有一个实现，就是LinkedBlockingDeque，实现原理与LinkedBlockingQueue一样。</p>
</blockquote>
<p><strong>CopyOnWrite</strong></p>
<blockquote>
<p>CopyOnWrite指在“写”的时候，不是直接“写”源数据，而是把数据拷贝一份进行修改，再通过悲观锁或者乐观锁的方式写回。那为什么不直接修改，而是要拷贝一份修改呢？这是为了在“读”的时候不加锁。</p>
<p>Y：适合于“写”操作很少的情况。</p>
</blockquote>
<ul>
<li><p>CopyOnWriteArrayList</p>
<blockquote>
<p>CopyOnWriteArrayList的核心数据结构也是一个数组，该数组为volatile。</p>
<p>“读”函数不加锁，“写”函数加锁，且实现逻辑为写时复制一个新数组，将数据写（添加、删除、修改）到新数组中，用新数组替换旧数组。</p>
</blockquote>
</li>
<li><p>CopyOnWriteArraySet </p>
<blockquote>
<p>CopyOnWriteArraySet 就是用 Array 实现的一个 Set，保证所有元素都不重复。其内部是封装的一个CopyOnWriteArrayList。</p>
</blockquote>
</li>
</ul>
<p><strong>ConcurrentLinkedQueue/Deque</strong></p>
<p><strong>ConcurrentHashMap</strong></p>
<blockquote>
<p>volatile + CAS + synchronzied</p>
<ul>
<li><p>头节点所在的hash数组为volatile。</p>
</li>
<li><p>put：若数组中钙hash位置为null，则不需要使用锁，通过cas操作添加，若已有元素，则通过 synchronized (f) 进行同步，其中f为数组中的头节点。</p>
</li>
<li><p>get：不加锁</p>
</li>
<li><p>remove：基于replaceNode</p>
</li>
<li><p>replaceNode：使用 synchronized (f) 进行同步，其中f为数组中的头节点。</p>
</li>
</ul>
</blockquote>
</blockquote>
</li>
<li><p>线程池</p>
<blockquote>
<ul>
<li><p>ThreadPoolExecutor</p>
<blockquote>
<p>手动配置和调整此类时，请使用以下指南：（来自其注释）</p>
<ul>
<li><p><font color='00FF00'> Core and maximum pool sizes </font></p>
<blockquote>
<p>ThreadPoolExecutor会根据corePoolSize和maximumPoolSize设置的边界自动调整池的大小(见getPoolSize)。当在方法execute(Runnable)中提交一个新任务时，如果运行的线程少于corePoolSize，则创建一个新线程来处理该请求，即使其他工作线程空闲。否则，如果正在运行的线程少于maximumPoolSize，则只有在队列已满时才会创建一个新线程来处理请求。通过将corePoolSize和maximumPoolSize设置为相同，可以创建一个固定大小的线程池。通过将maximumPoolSize设置为一个本质上无界的值，比如Integer.MAX_VALUE，允许池容纳任意数量的并发任务。最典型的情况是，核心池和最大池大小仅在构造时设置，但它们也可以使用setCorePoolSize和setMaximumPoolSize动态更改。</p>
</blockquote>
</li>
<li><p>On-demand construction</p>
<blockquote>
<p><font color='00FF00'>默认情况下，即使是核心线程也只有在新任务到达时才被初始创建和启动，但这可以使用prestartCoreThread或prestartAllCoreThreads方法动态覆盖。</font>如果使用非空队列来构造线程池，您可能希望预先启动线程。</p>
</blockquote>
</li>
<li><p>Creating new threads</p>
<blockquote>
<p>使用ThreadFactory创建新线程。如果没有指定，则使用Executors.defaultThreadFactory，它创建的线程都在同一个线程组中，具有相同的NORM_PRIORITY优先级和非守护线程状态。通过提供一个不同的ThreadFactory，你可以改变线程的名称、线程组、优先级、守护进程状态等。如果ThreadFactory通过newThread返回null请求创建线程失败，执行器将继续执行，但可能无法执行任何任务。线程应该拥有“modifyThread”RuntimePermission。如果使用该池的工作线程或其他线程不拥有此权限，则服务可能降级:配置更改可能不会及时生效，并且shutdown线程池可能保持在可能终止但未完成的状态。</p>
</blockquote>
</li>
<li><p>Keep-alive times</p>
<blockquote>
<p>如果池当前有超过corePoolSize线程，多余的线程将被终止，如果它们的空闲时间超过了keepAliveTime(参见getKeepAliveTime(TimeUnit))。这提供了一种方法，可以在池没有被积极使用时减少资源消耗。如果以后池变得更活跃，则会构造新的线程。这个参数也可以使用方法setKeepAliveTime(long, TimeUnit)动态更改。使用Long.MAX_VALUE TimeUnit.NANOSECONDS 有效地禁止空闲线程在关闭之前终止。默认情况下，keep-alive策略只适用于多于corePoolSize线程的情况，但是allowCoreThreadTimeOut(boolean)方法也可以用于将这个超时策略应用于核心线程，只要keepAliveTime的值不为零。</p>
</blockquote>
</li>
<li><p>Queuing</p>
<blockquote>
<p>任何BlockingQueue都可以用来传输和保存提交的任务。这个队列的使用与池的大小调整相互作用:</p>
<ul>
<li>如果运行的线程少于corePoolSize, Executor总是倾向于添加一个新线程而不是排队。</li>
<li>如果corePoolSize或更多的线程正在运行，Executor总是倾向于将请求排队，而不是添加一个新线程。</li>
<li>如果请求不能排队，则创建一个新线程，除非该线程超过maximumPoolSize，在这种情况下，任务将被拒绝。</li>
</ul>
<p>有三种一般的排队策略:</p>
<ol>
<li>直接的传递。对于工作队列来说，一个好的默认选择是SynchronousQueue，它将任务传递给线程，而不持有它们。在这里，如果没有立即可用的线程来运行任务，尝试对任务进行排队将失败，因此将构造一个新线程。当处理可能具有内部依赖关系的请求集时，此策略可以避免锁定。直接切换通常需要无限制的maximumpoolsize，以避免拒绝新提交的任务。反过来，当命令的平均到达速度超过处理速度时，就有可能出现无限制的线程增长。</li>
<li>无界队列。使用无界队列(例如，没有预定义容量的LinkedBlockingQueue)将导致在所有corePoolSize线程都繁忙时，新的任务在队列中等待。因此，只会创建corePoolSize线程。(因此，maximumPoolSize的值没有任何影响。)当每个任务完全独立于其他任务时，这可能是合适的，因此任务不会影响其他任务的执行;例如，在一个网页服务器中。虽然这种类型的排队在平滑短暂的请求突发方面很有用，但当命令的平均到达速度超过它们的处理速度时，它承认了无限工作队列增长的可能性。</li>
<li>有界的队列。当使用有限的maximumPoolSizes时，有界队列(例如ArrayBlockingQueue)有助于防止资源耗尽，但可能更难调优和控制。队列大小和最大池大小可以相互权衡:使用大型队列和小型池可以最小化CPU使用、OS资源和上下文切换开销，但可能会人为地降低吞吐量。如果任务经常阻塞(例如，如果它们受I/O限制)，系统可能会为比您所允许的更多的线程调度时间。使用小队列通常需要更大的池大小，这使得cpu更加繁忙，但可能会遇到不可接受的调度开销，这也会降低吞吐量。</li>
</ol>
</blockquote>
</li>
<li><p>Rejected tasks</p>
<blockquote>
<p>在方法execute(Runnable)中提交的新任务将在Executor已经关闭，以及Executor使用了有限的最大线程和工作队列容量，并且饱和时被拒绝。在这两种情况下，execute方法都调用RejectedExecutionHandler.rejectedExecution(Runnable, ThreadPoolExecutor) 方法。提供了四个预定义的处理策略:</p>
<ol>
<li>在默认ThreadPoolExecutor.AbortPolicy，处理程序抛出一个运行时RejectedExecutionException。</li>
<li>在ThreadPoolExecutor.CallerRunsPolicy，调用execute的线程自身运行该任务。这提供了一个简单的反馈控制机制，可以降低新任务提交的速度。</li>
<li>在ThreadPoolExecutor.DiscardPolicy，一个不能执行的任务将被简单地删除。此策略仅为那些极少的从不依赖任务完成的情况而设计。</li>
<li>在ThreadPoolExecutor.DiscardOldestPolicy，如果执行器没有关闭，工作队列头的任务将被删除，然后重试执行(可能再次失败，导致重复执行)。这种政策很难被接受。在几乎所有的情况下，您还应该取消任务，以导致任何组件在等待其完成时出现异常，并/或记录失败，如ThreadPoolExecutor.DiscardOldestPolicy文档中所描述。</li>
</ol>
<p>可以定义和使用其他类型的RejectedExecutionHandler类。这样做需要一些注意，特别是当策略设计为仅在特定容量或排队策略下工作时。</p>
</blockquote>
</li>
<li><p>Hook methods</p>
<blockquote>
<p>​    该类提供受保护的可重写beforeExecute(Thread, Runnable)和afterExecute(Runnable, Throwable)方法，它们在每个任务执行之前和之后被调用。这些可以用来操纵执行环境;例如，重新初始化ThreadLocals、收集统计信息或添加日志条目。此外，可以覆盖终止的方法以执行在Executor完全终止后需要执行的任何特殊处理。</p>
<p>​    如果hook、callback或BlockingQueue方法抛出异常，内部工作线程可能会依次失败、突然终止，并可能被替换。</p>
</blockquote>
</li>
<li><p>Queue maintenance</p>
<blockquote>
<p><font color='00FF00'>方法getQueue()允许访问工作队列，以便进行监视和调试。</font>强烈制止将此方法用于其他目的。当大量排队的任务被取消时，提供的两个方法remove(Runnable)和purge可用来协助存储回收。</p>
</blockquote>
</li>
<li><p>Reclamation</p>
<blockquote>
<p>在程序中不再引用且没有剩余线程的池可以被回收(垃圾回收)，而无需显式关闭。您可以通过设置适当的keep-alive时间，使用0个核心线程的下界和/或设置allowCoreThreadTimeOut(boolean)来配置池，以允许所有未使用的线程最终死亡。</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p>ForkJoinPool</p>
<blockquote>
<ul>
<li><p>用于运行ForkJoinTasks的ExecutorService。ForkJoinPool为来自非Forkjointask客户端的提交提供入口点，以及管理和监控操作。</p>
</li>
<li><p>任务执行方法总结</p>
</li>
<li><table>
<thead>
<tr>
<th></th>
<th>Call from non-fork/join clients</th>
<th>Call from within fork/join computations</th>
</tr>
</thead>
<tbody><tr>
<td>安排异步执行</td>
<td>execute(ForkJoinTask)</td>
<td>ForkJoinTask.fork</td>
</tr>
<tr>
<td>等待并获得结果</td>
<td>invoke(ForkJoinTask)</td>
<td>ForkJoinTask.invoke</td>
</tr>
<tr>
<td>安排执行，获取 Future</td>
<td>submit(ForkJoinTask)</td>
<td>ForkJoinTask.fork (ForkJoinTasks are Futures)</td>
</tr>
</tbody></table>
<p>用于构造公共池的参数可以通过设置以下系统属性来控制:</p>
<blockquote>
<ul>
<li>java.util.concurrent.ForkJoinPool.common.parallelism - 并行级别，一个非负整数。</li>
<li>java.util.concurrent.ForkJoinPool.common.threadFactory - ForkJoinPool.ForkJoinWorkerThreadFactory的类名。系统类加载器用于加载该类。</li>
<li>java.util.concurrent.ForkJoinPool.common.exceptionHandler - Thread.UncaughtExceptionHandler的类名。系统类加载器用于加载该类。</li>
<li>java.util.concurrent.ForkJoinPool.common.maximumSpares - 用于维护目标并行性而允许的额外线程的最大数量(默认为256)。</li>
</ul>
</blockquote>
</li>
<li><p>实现注意事项:该实现将最大运行线程数限制为32767。尝试创建大于最大数量的池会导致IllegalArgumentException异常。</p>
</li>
<li><p>只有当池关闭或内部资源耗尽时，该实现才会拒绝提交的任务(即通过抛出RejectedExecutionException)。</p>
</li>
<li><p>构造函数参数：</p>
<blockquote>
<ul>
<li>parallelism - 并行度级别。对于默认值，使用Runtime.availableProcessors。</li>
<li>factory - 创建新线程的工厂。默认值为defaultForkJoinWorkerThreadFactory。</li>
<li>handler - 内部工作线程的处理程序，在执行任务时遇到不可恢复的错误而终止。对于默认值，使用null。</li>
<li>asyncMode - 如果为true，为未加入的fork任务建立本地先进先出调度模式。在工作线程只处理事件式异步任务的应用程序中，此模式可能比默认的基于本地堆栈的模式更合适。默认值为false。</li>
<li>corePoolSize - 要保持在池中的线程数(除非经过保持活动后超时)。通常情况下(默认情况下)这个值与并行级相同，但如果任务经常阻塞，可以设置为更大的值以减少动态开销。使用较小的值(例如0)具有与默认值相同的效果。</li>
<li>maximumPoolSize -允许的最大线程数。当达到最大值时，尝试替换阻塞的线程会失败。(但是，由于不同线程的创建和终止可能会重叠，并且可能由给定的线程工厂管理，因此这个值可能会暂时超过。)要排列公共池默认使用的相同值，请使用256加上并行级别。(默认情况下，公共池最多允许256个空闲线程。)使用大于实现的总线程限制的值(例如Integer.MAX_VALUE)与使用此限制(这是默认值)具有相同的效果。</li>
<li>minimumRunnable—不被join或ForkJoinPool.ManagedBlocker阻塞的最小允许的核心线程数。为了确保进度，当未阻塞的线程太少且可能存在未执行的任务时，会构造新的线程，直到给定的maximumPoolSize。对于默认值，请使用1，以确保活动性。在出现阻塞活动时，较大的值可能会提高吞吐量，但也可能不会，因为开销增加了。当提交的任务不能有需要额外线程的依赖项时，可以接受值为0。</li>
<li>saturate - 如果非空，则在尝试创建大于允许的最大线程总数时调用的谓词。默认情况下，当线程在join或ForkJoinPool.ManagedBlocker上即将阻塞，但因为将超过maximumPoolSize而不能被替换时，抛出RejectedExecutionException。但是，如果这个谓词返回true，则不会抛出异常，因此池继续在少于目标可运行线程数的情况下操作，这可能无法确保进度。</li>
<li>keepAliveTime—从最后一次使用到线程终止(然后在需要时替换)之前经过的时间。默认值为60,TimeUnit.SECONDS。</li>
<li>unit - keepAliveTime参数的时间单位</li>
</ul>
</blockquote>
</li>
<li><p>commonPool()</p>
<blockquote>
<p>返回公共池实例。这个池是静态构造的;它的运行状态不受shutdown或shutdownNow尝试的影响。 但是，这个池和任何正在进行的处理在程序System.exit时自动终止。 任何依赖于异步任务处理在程序终止前完成的程序都应该在退出前调用commonPool().awaitQuiescence</p>
</blockquote>
</li>
<li><p>使用示例：ForkJoinCalculator，参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/f641385712/article/details/83749798">ForkJoinPool线程池的使用以及原理</a></p>
<blockquote>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/work%20stealing.png" alt="work stealing" style="zoom: 67%;" />

<ul>
<li>ForkJoinPool 的每个工作线程都维护着一个工作队列（WorkQueue），这是一个双端队列（Deque），里面存放的对象是任务（ForkJoinTask）。</li>
<li>每个工作线程在运行中产生新的任务（通常是因为调用了 fork()）时，会放入工作队列的队尾，并且工作线程在处理自己的工作队列时，使用的是 LIFO 方式，也就是说每次从队尾取出任务来执行。</li>
<li>每个工作线程在处理自己的工作队列同时，会尝试窃取一个任务（或是来自于刚刚提交到 pool 的任务，或是来自于其他工作线程的工作队列），窃取的任务位于其他线程的工作队列的队首，也就是说工作线程在窃取其他工作线程的任务时，使用的是 FIFO 方式。</li>
<li>在遇到 join() 时，如果需要 join 的任务尚未完成，则会先处理其他任务，并等待其完成。</li>
<li>在既没有自己的任务，也没有可以窃取的任务时，进入休眠。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p>Executors 工厂方法</p>
<blockquote>
<ul>
<li><p>newFixedThreadPool(int nThreads) &amp; newFixedThreadPool(int nThreads, ThreadFactory threadFactory)</p>
<blockquote>
<ul>
<li><p>固定线程数，未预先启动线程。</p>
</li>
<li><p>基于ThreadPoolExecutor。</p>
</li>
<li><p>corePoolSize == maximumPoolSize</p>
</li>
<li><p>无界任务队列（Integer.MAX_VALUE）</p>
</li>
</ul>
</blockquote>
</li>
<li><p>newWorkStealingPool(int parallelism) &amp; newWorkStealingPool()</p>
<blockquote>
<ul>
<li>创建一个线程池，该线程池维护足够的线程以支持给定的并行性级别，并且可以使用多个队列来减少争用。并行度级别对应于参与或可参与任务处理的最大线程数。线程的实际数量可以动态地增长和收缩。工作窃取池不保证所提交任务的执行顺序。</li>
<li>基于ForkJoinPool</li>
<li>newWorkStealingPool()，并行度为Java虚拟机可用cpu核心数：Runtime.getRuntime().availableProcessors()。</li>
</ul>
</blockquote>
</li>
<li><p>newSingleThreadExecutor() &amp; newSingleThreadExecutor(ThreadFactory threadFactory)</p>
<blockquote>
<ul>
<li>基于ThreadPoolExecutor。</li>
<li>corePoolSize == maximumPoolSize == 1</li>
<li>无界任务队列（Integer.MAX_VALUE）</li>
</ul>
</blockquote>
</li>
<li><p>newCachedThreadPool() &amp; newCachedThreadPool(ThreadFactory threadFactory)</p>
<blockquote>
<ul>
<li>如果没有可用的现有线程，将创建一个新线程并将其添加到池中。60秒内未使用的线程将被终止并从缓存中删除。因此，一个长时间保持空闲的池不会消耗任何资源。</li>
<li>基于ThreadPoolExecutor。</li>
<li>corePoolSize == maximumPoolSize == 1</li>
<li>无界任务队列（Integer.MAX_VALUE）</li>
</ul>
</blockquote>
</li>
<li><p>newSingleThreadScheduledExecutor() &amp; newSingleThreadScheduledExecutor(ThreadFactory threadFactory)</p>
<blockquote>
<ul>
<li>创建一个单线程执行器，该执行器可以安排命令在给定的延迟后运行或定期执行。</li>
<li>基于ScheduledThreadPoolExecutor</li>
</ul>
</blockquote>
</li>
<li><p>newScheduledThreadPool(int corePoolSize) &amp; newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)</p>
<blockquote>
<ul>
<li>创建一个线程池，该线程池可以调度命令在给定的延迟后运行或定期执行。</li>
<li>基于其父类ThreadPoolExecutor。maximumPoolSize == Integer.MAX_VALUE</li>
</ul>
</blockquote>
</li>
<li><p>unconfigurableExecutorService(ExecutorService executor) &amp; unconfigurableScheduledExecutorService(ScheduledExecutorService executor)</p>
<blockquote>
<ul>
<li>返回一个对象，该对象将所有定义的ExecutorService方法委托给给定的执行器，而不是任何其他可能使用类型转换访问的方法。这提供了一种安全“冻结”配置的方法，并且不允许对给定的具体实现进行调优。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li></li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.coder.love/2022/03/21/Synchronized/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="青马流光">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="青马流光的博客">
      <meta itemprop="description" content="学习笔记">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 青马流光的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/21/Synchronized/" class="post-title-link" itemprop="url">Synchronized</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-03-21 15:06:25 / 修改时间：18:01:04" itemprop="dateCreated datePublished" datetime="2022-03-21T15:06:25+08:00">2022-03-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>表格 表示<strong>字段</strong>访问权限和属性的各个标志（来自Java虚拟机规范4.5）(ACC 简写自 access_flags)</p>
<table>
<thead>
<tr>
<th>标志名</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td></td>
<td>声明为public，可以从包外访问</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td></td>
<td>声明为private，只能在定义该字段的类中访问</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td></td>
<td>声明为protected，子类可以访问</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td></td>
<td>声明为static</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td></td>
<td>声明为final，对象构造好之后，就不能直接设置该字段了</td>
</tr>
<tr>
<td>ACC_VOLATILE</td>
<td></td>
<td>声明为volatile，被标识的字段无法缓存</td>
</tr>
<tr>
<td>ACC_TRANSIENT</td>
<td></td>
<td>声明为transient，被标识的字段不会为持久化对象管理器所写入或读取</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td></td>
<td>被表示的字段由编译器产生，而没有写源代码中</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td></td>
<td>该字段声明为某个枚举类型的成员</td>
</tr>
</tbody></table>
<p>表格 表示<strong>方法</strong>访问权限及属性的各个标志（来自Java虚拟机规范4.6）(ACC 简写自 access_flags)</p>
<table>
<thead>
<tr>
<th>标志名</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ACC_PUBLIC</td>
<td></td>
<td>声明为public，可以从包外访问</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td></td>
<td>声明为private，只能在定义该方法的类中访问</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td></td>
<td>声明为protected，子类可以访问</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td></td>
<td>声明为static</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td></td>
<td>声明为final，不能被覆盖</td>
</tr>
<tr>
<td>ACC_SYNCHRONIZED</td>
<td></td>
<td><font color='00FF00'>声明为synchronized，对该方法的调用，将包装在同步锁（monitor）里</font></td>
</tr>
<tr>
<td>ACC_BRIDGE</td>
<td></td>
<td>声明为bridge方法，由编译器产生</td>
</tr>
<tr>
<td>ACC_VARARGS</td>
<td></td>
<td>表示方法带有变长参数</td>
</tr>
<tr>
<td>ACC_NATIVE</td>
<td></td>
<td>声明为native，该方法不是用Java语言实现的</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td></td>
<td>声明为abstract，该方法没有实现代码</td>
</tr>
<tr>
<td>ACC_STRICT</td>
<td></td>
<td>声明为strictfp，使用FP-strict浮点模式</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td></td>
<td>该方法是由编译器合成的，而不是由源代码编译出来的</td>
</tr>
</tbody></table>
<p>参见SynchronizedDemo的字节码，同步方法add由一个ACC_SYNCHRONIZED flag。在其调用方main方法中调用add的前后几句指令如下，先通过monitorenter获取同步锁，调用完成同通过monitorexit释放同步锁。（此处静态方法add的监视器对象为SynchronizedDemo的类对象）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>: monitorenter</span><br><span class="line"><span class="number">5</span>: getstatic     #<span class="number">7</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"><span class="number">8</span>: iconst_1</span><br><span class="line"><span class="number">9</span>: invokestatic  #<span class="number">23</span>                 <span class="comment">// Method add:(I)I</span></span><br><span class="line"><span class="number">12</span>: invokevirtual #<span class="number">27</span>                 <span class="comment">// Method java/io/PrintStream.println:(I)V</span></span><br><span class="line"><span class="number">15</span>: aload_1</span><br><span class="line"><span class="number">16</span>: monitorexit</span><br></pre></td></tr></table></figure>

<p><strong>关于静态同步方法与非静态同步方法的调用：</strong></p>
<ul>
<li>不同线程 调用 同一个类的静态同步方法 互斥；</li>
<li>不同线程 调用 同一个对象的非静态同步方法 互斥；</li>
<li>不同线程 调用 同一个类的不同对象的非静态同步方法 不互斥。</li>
</ul>
<p><strong>对象头中同步锁相关内容：</strong></p>
<ul>
<li><p>对象在堆内存中的存储布局：对象头 + 实例数据 + 对齐填充</p>
</li>
<li><p>对象头=Mark Word + Klass Word + （数组长度）？</p>
<blockquote>
<p>Mark Word：存储对象自身运行时数据</p>
<p>Klass Word：类型指针，指向它的类型元数据。Java虚拟机通过该指针确定该对象是哪个类的实例。</p>
</blockquote>
</li>
<li><p>对象同步锁信息位于Mark Word中。</p>
</li>
<li><p>hotspot虚拟机对synchronized所做的锁优化：自旋锁与自适应自旋、轻量级锁、偏向锁、锁消除、锁粗化。</p>
<blockquote>
<p>这些优化应该只是针对synchronized的，对于并发框架中的Lock并未使用。</p>
</blockquote>
</li>
<li><p>针对锁优化，同步锁状态分成了四种状态：无锁、偏向锁、轻量级锁、重量级锁。</p>
</li>
</ul>
<blockquote>
<p>参考《深入理解Java虚拟机》</p>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E5%A4%B4Mark%20Word.png" alt="HotSpot虚拟机对象头Mark Word" style="zoom: 50%;" />

<p>参考：<a target="_blank" rel="noopener" href="https://www.likecs.com/show-203562639.html">Java对象头与偏向锁、轻量级锁</a></p>
</blockquote>
<p>重量级锁</p>
<ul>
<li><p>通过操作系统互斥量来实现。Linux中提供一把互斥锁mutex（也称之为互斥量）。</p>
<blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39736982/article/details/82348672">互斥锁mutex</a></p>
<p>主要应用函数：</p>
<ul>
<li><p>pthread_mutex_init()函数          功能：初始化一个互斥锁</p>
</li>
<li><p>pthread_mutex_destroy()函数   功能：销毁一个互斥锁</p>
</li>
<li><p>pthread_mutex_lock()函数        功能：加锁</p>
</li>
<li><p>pthread_mutex_trylock()函数    功能：尝试加锁</p>
</li>
<li><p>pthread_mutex_unlock()函数    功能：解锁</p>
</li>
</ul>
</blockquote>
</li>
</ul>
<p>轻量级锁</p>
<ul>
<li><p>目的：初衷是<strong>在没有多线程竞争的前提下</strong>，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p>
<blockquote>
<p>互斥同步面临的主要问题是进行线程阻塞和唤醒所带来的性能开销，因此这种同步也被称为阻塞同步（Blocking Synchronization）。</p>
</blockquote>
</li>
</ul>
<p>偏向锁</p>
<ul>
<li><p>目的：消除数据在<strong>无竞争情况下</strong>的同步原语，进一步提高程序的运行性能。</p>
<blockquote>
<p>即避免了轻量级锁中Mark Word 的 CAS拷贝等操作的消耗。</p>
</blockquote>
</li>
<li><p>其他注意点：</p>
<ul>
<li><p>当一个对象已经计算过一致性哈希码后，它就再也无法进入偏向锁状态了；而当一个对象当前正处于偏向锁状态，又收到需要计算其一致性哈希码请求[1]时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁。在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类里有字段可以记录非加锁状态（标志位为“01”）下的Mark Word，其中自然可以存储原来的哈希码。</p>
<blockquote>
<p>注意，[1]这里说的计算请求应来自于对Object::hashCode()或者System::identityHashCode(Object)方法的调用，如果重写了对象的hashCode()方法，计算哈希码时并不会产生这里所说的请求。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/%E5%81%8F%E5%90%91%E9%94%81%E4%B8%8E%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E8%BF%87%E7%A8%8B.jpg" alt="偏向锁与轻量级锁过程"></p>
<p>偏向锁还有写疑问，参考：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/55075763">https://www.zhihu.com/question/55075763</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cqqfboy/p/14657900.html">https://www.cnblogs.com/cqqfboy/p/14657900.html</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.itqiankun.com/article/bias-lightweight-synchronized-lock">https://www.itqiankun.com/article/bias-lightweight-synchronized-lock</a></p>
<blockquote>
<p>文中的一幅图：</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/1575018455.jpeg" alt="img"></p>
</blockquote>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.coder.love/2022/03/21/%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83%E9%9B%B6%E6%95%A3%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="青马流光">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="青马流光的博客">
      <meta itemprop="description" content="学习笔记">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 青马流光的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/21/%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83%E9%9B%B6%E6%95%A3%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">语言规范零散问题记录.md</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-03-21 15:06:25 / 修改时间：18:01:04" itemprop="dateCreated datePublished" datetime="2022-03-21T15:06:25+08:00">2022-03-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="try、catch、finally用法"><a href="#try、catch、finally用法" class="headerlink" title="try、catch、finally用法"></a>try、catch、finally用法</h3><ol>
<li>不管有没有异常，finally中的代码都会执行</li>
<li>当try、catch中有return时，finally中的代码依然会继续执行</li>
<li>finally是在return后面的表达式运算之后执行的，此时并没有返回运算之后的值，而是把值保存起来，不管finally对该值做任何的改变，返回的值都不会改变，依然返回保存起来的值。也就是说方法的返回值是在finally运算之前就确定了的。</li>
<li>finally代码中最好不要包含return，程序会提前退出，也就是说返回的值不是try或catch中的值</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.coder.love/2021/10/26/Mysql-Sql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="青马流光">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="青马流光的博客">
      <meta itemprop="description" content="学习笔记">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 青马流光的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/10/26/Mysql-Sql/" class="post-title-link" itemprop="url">Mysql事务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-10-26 19:36:09 / 修改时间：19:40:42" itemprop="dateCreated datePublished" datetime="2021-10-26T19:36:09+08:00">2021-10-26</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ul>
<li><p>INSERT … ON DUPLICATE KEY UPDATE</p>
<blockquote>
<p>相当于 先判断一条记录是否存在，存在则执行后边的Update语句，否则执行前边的insert语句。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/moxiaotao/p/9431808.html">https://www.cnblogs.com/moxiaotao/p/9431808.html</a></p>
</blockquote>
</li>
<li><p>replace into tbl_name(col_name, …) values(…)</p>
<blockquote>
<p>replace into 首先尝试插入数据到表中，如果发现表中已经有此行数据（根据主键或者唯一索引判断）则先删除此行数据，然后插入新的数据。 否则，直接插入新数据。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/liu379702831/article/details/105819304/">https://blog.csdn.net/liu379702831/article/details/105819304/</a></p>
</blockquote>
</li>
<li><p>replace into与INSERT … ON DUPLICATE KEY UPDATE的区别</p>
<blockquote>
<p>replace into和on duplcate key update都是只有在primary key或者unique key冲突的时候才会执行。如果数据存在，replace into则会将原有数据删除，再进行插入操作，这样就会有一种情况，如果某些字段有默认值，但是replace into语句的字段不完整，则会设置成默认值。而on duplicate key update则是执行update后面的语句。 </p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq2430/article/details/80511640">https://blog.csdn.net/qq2430/article/details/80511640</a></p>
</blockquote>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.coder.love/2021/09/09/Concurrent-Programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="青马流光">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="青马流光的博客">
      <meta itemprop="description" content="学习笔记">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 青马流光的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/09/Concurrent-Programming/" class="post-title-link" itemprop="url">并发编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-09 10:58:59" itemprop="dateCreated datePublished" datetime="2021-09-09T10:58:59+08:00">2021-09-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-21 12:42:33" itemprop="dateModified" datetime="2022-03-21T12:42:33+08:00">2022-03-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-操作系统进程的状态"><a href="#1-操作系统进程的状态" class="headerlink" title="1. 操作系统进程的状态"></a>1. 操作系统进程的状态</h1><p>三种基本状态：就绪态、执行态、阻塞态。这三种基本状态是每个OS中都会有的，因此也称之为基本状态，</p>
<p>下面先给出三种基本状态的定义：</p>
<ul>
<li><p><strong>就绪（Ready）状态</strong>：通过Ready我们可以看到，处于此状态的进程已经处于准备好要运行了，此时进程已经分配好除CPU外的所有必要资源，只需获得CPU（CPU如何进行分配，请关注后续有关处理机调度的博文），便可立即执行。用一句话来描述处于就绪态的进程：万事俱备，只欠CPU。另外还有一个就绪队列的概念，处于就绪态的进程都在此队列中，等待着调度程序的调度（分配CPU）。</p>
</li>
<li><p><strong>执行（Running）状态</strong>：Running，运行中的，处于此状态的进程是已经获得CPU并且正在执行中。对于这一状态，在单CPU OS中，同一时刻只能有一个进程处于此状态，而在多CPU OS中，则可以有多个（不超过CPU的数量）进程同时处于执行状态。</p>
</li>
<li><p><strong>阻塞（Block）状态</strong>：阻塞，百度释义为：障碍而不能通过，无法畅通。处于此状态的进程是因为在执行的过程中由于发生某种需要等待的事件（I/O请求、申请缓存失败、等待接收数据等），而暂时无法继续执行。我们知道在多道批处理系统中，此时需要进程把处理机释放，并选取新的就绪进程执行。与就绪队列相对应的，处于阻塞状态的进程都在阻塞队列中，某些OS中，出于提高效率的目的，根据阻塞的原因，会有多个阻塞队列。</p>
<blockquote>
<p>Y：阻塞是在等待CPU之外的资源？好像不止，等待事件，比如建立Socket连接的请求事件。</p>
</blockquote>
</li>
</ul>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/process_state_trans.jpeg" alt="进程三种基本状态转换图" style="zoom: 50%;" />

<p>各个状态切换发生的原因：</p>
<ul>
<li>就绪态—&gt;执行态：进程获得CPU（被调度程序选中）；</li>
<li>执行态—&gt;阻塞态：向OS请求共享资源（互斥、同步）失败、等待某种操作完成、新数据尚未到达（I/O操作）、等待新任务的到达；</li>
<li>阻塞态—&gt;阻塞态：上述的四类等待事件发生；</li>
<li>执行态—&gt;就绪态：分配给进程的时间片执行完成（轮转调度算法）、高优先级的进程到达（抢占式调度）。</li>
</ul>
<h1 id="2-Java-线程"><a href="#2-Java-线程" class="headerlink" title="2. Java 线程"></a>2. Java 线程</h1><p>基于内核线程（实际是系统提供的轻量级进程）实现，与内核线程1:1，由系统进行调度。</p>
<p>Java中定义的线程状态Thread.State：</p>
<hr>
<blockquote>
<p>内容来源：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34666857/article/details/102852747">操作系统进程状态和状态转换详解</a></li>
</ul>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.coder.love/2021/09/07/IDEA-Plugs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="青马流光">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="青马流光的博客">
      <meta itemprop="description" content="学习笔记">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 青马流光的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/07/IDEA-Plugs/" class="post-title-link" itemprop="url">IDEA Plugs</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-07 11:54:18" itemprop="dateCreated datePublished" datetime="2021-09-07T11:54:18+08:00">2021-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-09-08 15:32:58" itemprop="dateModified" datetime="2021-09-08T15:32:58+08:00">2021-09-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol>
<li>jclasslib Bytecode Viewer<ul>
<li>使用方法：打开“view” 菜单，选择“Show Bytecode With Jclasslib” 选项，右侧会出现jclasslib工具窗口。</li>
</ul>
</li>
<li>JOL Java Object Layout<ul>
<li>使用方法：Set a cursor into a class name and then press <code>Code / Show Object Layout</code> and you’ll see a right panel with layout info.</li>
</ul>
</li>
<li>arthas idea <ul>
<li>Arthas 的IDEA插件</li>
<li>使用方法：右键 -&gt; Arthas Command</li>
</ul>
</li>
<li>Translation<ul>
<li>翻译插件</li>
<li>使用方法：右键 -&gt; 翻译文档；选中待翻译内容 -&gt; 右键 -&gt; 翻译</li>
</ul>
</li>
<li>Java Decompiler<ul>
<li>IntelliJ IDEA and provoke PluginException / InvalidMirrorException. Unfortunately some of these errors cannot be fixed on JD-Core side.</li>
</ul>
</li>
<li></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">青马流光</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
