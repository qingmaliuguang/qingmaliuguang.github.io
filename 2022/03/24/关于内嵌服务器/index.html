<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="关于内嵌服务器"/>




  <meta name="keywords" content="SpringBoot," />





  <link rel="alternate" href="/default" title="青马流光的博客" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="http://blog.coder.love/2022/03/24/关于内嵌服务器/"/>


<meta name="description" content="1. 内嵌服务器是如何注入的？注入ServletWebServerFactory实例 spring-boot-autoconfigure -&gt; spring.factory   -&gt; EnableAutoConfiguration&#x3D;ServletWebServerFactoryAutoConfiguration    -&gt; ServletWebServerFactoryAutoC">
<meta property="og:type" content="article">
<meta property="og:title" content="关于内嵌服务器">
<meta property="og:url" content="http://blog.coder.love/2022/03/24/%E5%85%B3%E4%BA%8E%E5%86%85%E5%B5%8C%E6%9C%8D%E5%8A%A1%E5%99%A8/index.html">
<meta property="og:site_name" content="青马流光的博客">
<meta property="og:description" content="1. 内嵌服务器是如何注入的？注入ServletWebServerFactory实例 spring-boot-autoconfigure -&gt; spring.factory   -&gt; EnableAutoConfiguration&#x3D;ServletWebServerFactoryAutoConfiguration    -&gt; ServletWebServerFactoryAutoC">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/TomcatWebServer-start.jpg">
<meta property="og:image" content="https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/DispatcherServletRegistrationBean.jpg">
<meta property="og:image" content="https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/DispatcherServlet.jpg">
<meta property="og:image" content="https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/ServletWebServerApplicationContext-createWebServer.jpg">
<meta property="og:image" content="https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/TomcatServletWebServerFactory.jpg">
<meta property="og:image" content="https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/tomcat-embed-%E6%A6%82%E5%BF%B5%E5%85%B3%E7%B3%BB.jpg">
<meta property="og:image" content="https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/tomcat-embed%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B-20220402181017928.jpg">
<meta property="og:image" content="https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/ServletRequest.jpg">
<meta property="og:image" content="https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/DispatcherServlet-init.jpg">
<meta property="og:image" content="https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/DispatcherServlet-doService.jpg">
<meta property="article:published_time" content="2022-03-24T09:12:25.000Z">
<meta property="article:modified_time" content="2023-04-29T03:17:09.321Z">
<meta property="article:author" content="青马流光">
<meta property="article:tag" content="SpringBoot">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/TomcatWebServer-start.jpg">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  <script id="baidu_analytics">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?65a3f3228e88e62009896032ddcfdf2b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



    <title> 关于内嵌服务器 - 青马流光的博客 </title>
  <meta name="generator" content="Hexo 5.4.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">青马流光的博客</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          关于内嵌服务器
        
      </h1>

      <time class="post-time">
          3月 24 2022
      </time>
    </header>



    
            <div class="post-content">
            <h1 id="1-内嵌服务器是如何注入的？"><a href="#1-内嵌服务器是如何注入的？" class="headerlink" title="1. 内嵌服务器是如何注入的？"></a>1. 内嵌服务器是如何注入的？</h1><h2 id="注入ServletWebServerFactory实例"><a href="#注入ServletWebServerFactory实例" class="headerlink" title="注入ServletWebServerFactory实例"></a>注入ServletWebServerFactory实例</h2><ul>
<li><p>spring-boot-autoconfigure -&gt; spring.factory</p>
</li>
<li><p> -&gt; EnableAutoConfiguration=ServletWebServerFactoryAutoConfiguration</p>
</li>
</ul>
<ul>
<li><p>-&gt; ServletWebServerFactoryAutoConfiguration</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(ServletRequest.class)</span></span><br><span class="line"><span class="comment">// 应用类型推断为SERVLET</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span></span><br><span class="line"><span class="comment">// 注册ServerProperties bean 用于web服务器的配置。</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(ServerProperties.class)</span></span><br><span class="line"><span class="comment">// 导入组件类：</span></span><br><span class="line"><span class="comment">// - ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar注册一个WebServerFactoryCustomizerBeanPostProcessor，通过ImportBeanDefinitionRegistrar提前注册</span></span><br><span class="line"><span class="comment">// - EmbeddedTomcat、EmbeddedJetty、EmbeddedUndertow根据条件会启用一个，用于注册一个ServletWebServerFactory实例。</span></span><br><span class="line"><span class="meta">@Import(&#123; ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,</span></span><br><span class="line"><span class="meta">		ServletWebServerFactoryConfiguration.EmbeddedTomcat.class,</span></span><br><span class="line"><span class="meta">		ServletWebServerFactoryConfiguration.EmbeddedJetty.class,</span></span><br><span class="line"><span class="meta">		ServletWebServerFactoryConfiguration.EmbeddedUndertow.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletWebServerFactoryAutoConfiguration</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 通过@Bean注入ServletWebServerFactoryCustomizer、TomcatServletWebServerFactoryCustomizer、    FilterRegistrationBean【@ConditionalOnMissingFilterBean(ForwardedHeaderFilter.class)】</span></span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>ServletWebServerFactoryConfiguration -&gt; 以Tomcat为例 -&gt; ServletWebServerFactoryConfiguration.EmbeddedTomcat</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">  <span class="comment">// 都是tomcat-embed中的类，即添加tomcat-embed依赖的情况下生效。</span></span><br><span class="line">	<span class="meta">@ConditionalOnClass(&#123; Servlet.class, Tomcat.class, UpgradeProtocol.class &#125;)</span></span><br><span class="line">  <span class="comment">// ServletWebServerFactory实例当前上下文中只需要一个。</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT)</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmbeddedTomcat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="function">TomcatServletWebServerFactory <span class="title">tomcatServletWebServerFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      // ObjectProvider为一种依赖注入方式容器会自动将T类型beans包装成一个ObjectProvider，然后注入到依赖ObjectProvider&lt;T&gt;中。</span></span></span><br><span class="line"><span class="params"><span class="function">				ObjectProvider&lt;TomcatConnectorCustomizer&gt; connectorCustomizers,</span></span></span><br><span class="line"><span class="params"><span class="function">				ObjectProvider&lt;TomcatContextCustomizer&gt; contextCustomizers,</span></span></span><br><span class="line"><span class="params"><span class="function">				ObjectProvider&lt;TomcatProtocolHandlerCustomizer&lt;?&gt;&gt; protocolHandlerCustomizers)</span> </span>&#123;</span><br><span class="line">			TomcatServletWebServerFactory factory = <span class="keyword">new</span> TomcatServletWebServerFactory();</span><br><span class="line">			factory.getTomcatConnectorCustomizers()</span><br><span class="line">					.addAll(connectorCustomizers.orderedStream().collect(Collectors.toList()));</span><br><span class="line">			factory.getTomcatContextCustomizers()</span><br><span class="line">					.addAll(contextCustomizers.orderedStream().collect(Collectors.toList()));</span><br><span class="line">			factory.getTomcatProtocolHandlerCustomizers()</span><br><span class="line">					.addAll(protocolHandlerCustomizers.orderedStream().collect(Collectors.toList()));</span><br><span class="line">			<span class="keyword">return</span> factory;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>-&gt; 注册 TomcatServletWebServerFactory 实例 （即TomcatWebServer的工厂bean）</p>
</li>
</ul>
<h2 id="创建WebServer实例"><a href="#创建WebServer实例" class="headerlink" title="创建WebServer实例"></a>创建WebServer实例</h2><ul>
<li><p>AnnotationConfigServletWebServerApplicationContext.refresh()</p>
</li>
<li><p>-&gt; ServletWebServerApplicationContext.onRefresh()</p>
</li>
<li><p>-&gt; ServletWebServerApplicationContext.createWebServer()</p>
<blockquote>
<ul>
<li><p>创建WebServer实例</p>
<blockquote>
<ul>
<li>注意TomcatServer构造函数中调用了initialize()，调用了tomcat.start()。</li>
</ul>
</blockquote>
</li>
<li><p>将获取的WebServer实例，分别构造WebServerGracefulShutdownLifecycle和WebServerStartStopLifecycle单例注册到beanFactory，用于管理其生命周期，即服务器的启动、关闭等。</p>
</li>
</ul>
</blockquote>
</li>
<li><p>-&gt; 单例：webServerGracefulShutdown、webServerStartStop</p>
</li>
</ul>
<h2 id="启动服务器webServer"><a href="#启动服务器webServer" class="headerlink" title="启动服务器webServer"></a>启动服务器webServer</h2><ul>
<li><p>-&gt; AbstractApplicationContext.finishRefresh()</p>
<blockquote>
<p>完成这个上下文的刷新，调用LifecycleProcessor的onRefresh()方法并发布ContextRefreshedEvent</p>
</blockquote>
</li>
<li><p>-&gt; getLifecycleProcessor().onRefresh();</p>
<blockquote>
<p>首先将刷新传播到生命周期处理器。</p>
</blockquote>
</li>
<li><p>-&gt; DefaultLifecycleProcessor.onRefresh();</p>
<blockquote>
<p>上下文刷新的通知，例如自动启动组件</p>
</blockquote>
</li>
<li><p>-&gt; DefaultLifecycleProcessor.startBeans()</p>
<blockquote>
<ul>
<li><p>webServerGracefulShutdown：getPhase() == Integer.MAX_VALUE;</p>
</li>
<li><p>webServerStartStop：getPhase() == Integer.MAX_VALUE - 1;</p>
</li>
</ul>
</blockquote>
</li>
<li><p>LifecycleGroup.start() -&gt; LifecycleGroup.doStart()</p>
</li>
<li><p>-&gt; webServerStartStop.start()</p>
<blockquote>
<ul>
<li>其后也会触发webServerGracefulShutdown.start()，但只是修改其自身标志位，用于webServer关闭，与webServer启动无关。</li>
<li>在WebServer就绪之后还会发布一个<strong>ServletWebServerInitializedEvent</strong>事件，用于获取运行中的服务器的本地端口。</li>
</ul>
</blockquote>
</li>
<li><p>-&gt; webServer.start() 【TomcatWebServer.start()】</p>
</li>
</ul>
<h2 id="TomcatWebServer启动过程"><a href="#TomcatWebServer启动过程" class="headerlink" title="TomcatWebServer启动过程"></a>TomcatWebServer启动过程</h2><ul>
<li><p>start() 方法体全部通过 synchronized 进行同步控制。</p>
</li>
<li><p>启动流程图</p>
<blockquote>
<p><img src="https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/TomcatWebServer-start.jpg" alt="TomcatWebServer-start"></p>
<ul>
<li>由于servlet实例dispatcherServlet的创建交给了Spring容器，所以实际流程中通常不会执行wrapper.load()。</li>
<li>可以看到performDeferredLoadOnStartup()实际并没有触发什么特殊的操作。</li>
<li>TomcatWebServer.start()的实际效果就只剩了设置connectors和设置启动标志started。</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="Wrapper是什么时候构造的，加载的哪个Servlet实例？"><a href="#Wrapper是什么时候构造的，加载的哪个Servlet实例？" class="headerlink" title="Wrapper是什么时候构造的，加载的哪个Servlet实例？"></a>Wrapper是什么时候构造的，加载的哪个Servlet实例？</h2><ul>
<li><p>spring-boot-autoconfigure -&gt; spring.factory</p>
</li>
<li><p>-&gt; EnableAutoConfiguration=org.springframework.boot.autoconfigure.web.servlet.<strong>DispatcherServletAutoConfiguration</strong></p>
</li>
<li><p>-&gt; <strong>DispatcherServletAutoConfiguration</strong></p>
<blockquote>
<p>Spring DispatcherServlet的自动配置。应该适用于已经有嵌入式web服务器的独立应用程序，也适用于使用SpringBootServletInitializer的可部署应用程序。</p>
</blockquote>
</li>
<li><p>-&gt; 生成DispatcherServlet 实例 dispatcherServlet 和 DispatcherServletRegistrationBean 实例 dispatcherServletRegistration。</p>
<blockquote>
<ul>
<li><p><strong>DispatcherServletRegistrationBean</strong></p>
<blockquote>
<img src="https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/DispatcherServletRegistrationBean.jpg" alt="DispatcherServletRegistrationBean" style="zoom: 50%;" /></blockquote>
</li>
<li><p><strong>DispatcherServlet</strong></p>
<blockquote>
<img src="https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/DispatcherServlet.jpg" alt="DispatcherServlet" style="zoom:50%;" /></blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p>-&gt; ServletWebServerApplicationContext.createWebServer()</p>
</li>
<li><p>-&gt; TomcatServletWebServerFactory.getWebServer(ServletContextInitializer… initializers)</p>
</li>
<li><p>-&gt; TomcatServletWebServerFactory.getTomcatWebServer(tomcat)</p>
<blockquote>
<p>构造并初始化TomcatWebServer实例。</p>
</blockquote>
</li>
<li><p>-&gt; TomcatWebServer.initialize()</p>
</li>
<li><p>-&gt; Tomcat.start()</p>
</li>
<li><p>-&gt; StandardServer.start()</p>
</li>
<li><p>-&gt; StandardContext.startInternal()</p>
<blockquote>
<p>实际为TomcatEmbeddedContext实例。</p>
</blockquote>
</li>
<li><p>-&gt; TomcatStarter.onStartUp()</p>
<p>遍历initializers，依次调用其onStartup</p>
</li>
<li><p>-&gt; ServletWebServerApplicationContext.selfInitialize((ServletContext servletContext))</p>
</li>
<li><p>-&gt; RegistrationBean.onStartUp()</p>
<blockquote>
<ul>
<li>实际为<strong>DispatcherServletRegistrationBean</strong>实例dispatcherServletRegistration，其通过自动配置实例化时有设置servlet，即<strong>DispatcherServlet</strong>实例dispatcherServlet。</li>
</ul>
</blockquote>
</li>
<li><p>-&gt; ApplicationContext.addServlet(String servletName, Servlet servlet)</p>
<blockquote>
<ol>
<li>通过StandardContext.createWrapper()生成Wrapper实例，没有填充servlet等属性。</li>
<li>对Wrapper实例填充name、servlet、servletClass等属性。</li>
</ol>
</blockquote>
</li>
<li><p>参考下面的ServletWebServerApplicationContext.createWebServer()流程图</p>
<blockquote>
<p><img src="https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/ServletWebServerApplicationContext-createWebServer.jpg" alt="ServletWebServerApplicationContext-createWebServer"></p>
</blockquote>
</li>
</ul>
<h2 id="相关配置文件"><a href="#相关配置文件" class="headerlink" title="相关配置文件"></a>相关配置文件</h2><ul>
<li><p>启用自动配置都是通过spring-boot-autoconfigure -&gt; spring.factory 的 EnableAutoConfiguration。</p>
</li>
<li><p>自动配置类</p>
<ul>
<li><p>ServerProperties</p>
<blockquote>
<ul>
<li>prefix：“server”</li>
<li>用于servlet web服务器的自动配置</li>
</ul>
</blockquote>
</li>
<li><p>WebMvcProperties</p>
<blockquote>
<ul>
<li>prefix：“spring.mvc” </li>
<li>Spring MVC的属性。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="都添加了哪些ServletContextInitializer"><a href="#都添加了哪些ServletContextInitializer" class="headerlink" title="都添加了哪些ServletContextInitializer"></a>都添加了哪些ServletContextInitializer</h2><ul>
<li><p>ServletWebServerApplicationContext$lambda</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">selfInitialize</span><span class="params">(ServletContext servletContext)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">		prepareWebApplicationContext(servletContext);</span><br><span class="line">		registerApplicationScope(servletContext);</span><br><span class="line">		WebApplicationContextUtils.registerEnvironmentBeans(getBeanFactory(), servletContext);</span><br><span class="line">		<span class="keyword">for</span> (ServletContextInitializer beans : getServletContextInitializerBeans()) &#123;</span><br><span class="line">			beans.onStartup(servletContext);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>AbstractServletWebServerFactory$lambda</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(servletContext) -&gt; <span class="keyword">this</span>.initParameters.forEach(servletContext::setInitParameter)</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>AbstractServletWebServerFactory.SessionConfiguringInitializer</p>
<blockquote>
<p>ServletContextInitializer，应用合适部分的Session配置。</p>
<p><img src="https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/TomcatServletWebServerFactory.jpg" alt="TomcatServletWebServerFactory"></p>
</blockquote>
</li>
</ul>
<p>以上三者都是在AbstractServletWebServerFactory.mergeInitializers(ServletContextInitializer… initializers)方法中合并与添加的。</p>
<p><strong>在哪里生效的？</strong>：TomcatStarter.onStartUp()</p>
<h1 id="2-内嵌服务器是怎么提供服务的？"><a href="#2-内嵌服务器是怎么提供服务的？" class="headerlink" title="2. 内嵌服务器是怎么提供服务的？"></a>2. 内嵌服务器是怎么提供服务的？</h1><h2 id="是谁监听的请求？"><a href="#是谁监听的请求？" class="headerlink" title="是谁监听的请求？"></a>是谁监听的请求？</h2><blockquote>
<img src="https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/tomcat-embed-%E6%A6%82%E5%BF%B5%E5%85%B3%E7%B3%BB.jpg" alt="tomcat-embed-概念关系" style="zoom: 33%;" />

<ul>
<li><p>概念的理解：</p>
<ul>
<li><p>Server是tomcat中服务器的概念，实现为StandardServer。</p>
</li>
<li><p>Service为提供的服务的概念，实现为StandardService。</p>
</li>
<li><p>Servlet为服务提供者。</p>
</li>
<li><p>从 Engine 到 Wrapper 为承载Servlet的四级容器，即servlet容器。</p>
</li>
<li><p>Connector 连接器</p>
<blockquote>
<ul>
<li>在Tomcat.getConnector()中可看到服务端口port被通过Connector.setPort配置到Connector实例中。</li>
<li>Connector.setPort将port设置为 ProtocolHandler 成员 protocolHandler 的“port”属性。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>猜测：请求监听者一定与port有关，Connector中并没有相关内容，那么可能是 protocolHandler。</p>
<blockquote>
<ul>
<li><p>Connector是在Tomcat.getConnector()时创建的，在StandardServer.start过程中完成的初始化（initInternal）和启动（startInternal）。</p>
</li>
<li><p>Connector创建时通过ProtocolHandler.create(protocol)创建了protocolHandler，对于默认的“HTTP/1.1”，对应<strong>Http11NioProtocol</strong>实例。</p>
</li>
<li><p>Connector.startInternal()注释中提到“通过这个连接器开始处理请求”，其中主要处理为protocolHandler.start();</p>
</li>
<li><p>protocolHandler.start();  - &gt;  endpoint.start()</p>
<blockquote>
<p>Http11NioProtocol的默认构造中的endpoint为<strong>NioEndpoint</strong>的实例。</p>
</blockquote>
</li>
<li><p><strong>NioEndpoint</strong></p>
<blockquote>
<p>NIO定制线程池，提供以下服务:</p>
<ul>
<li><p>Socket acceptor thread  套接字受体线程</p>
<blockquote>
<p>单个线程，线程名称以“-Acceptor”结尾。</p>
</blockquote>
</li>
<li><p>Socket poller thread  套接字轮询器线程</p>
<blockquote>
<p>单个线程，线程名称以“-Poller”结尾。</p>
</blockquote>
</li>
<li><p>Worker threads pool  工作线程池</p>
<blockquote>
<p>基于ThreadPoolExecutor的线程池 executor，名称含“-exec-”，形如“http-nio-8080-exec-3”。</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p>结论：NioEndpoint中的 acceptor 线程负责监听请求。</p>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="请求处理过程-如何传递到dispatcherServlet？"><a href="#请求处理过程-如何传递到dispatcherServlet？" class="headerlink" title="请求处理过程-如何传递到dispatcherServlet？"></a>请求处理过程-如何传递到dispatcherServlet？</h2><blockquote>
<ul>
<li><p>tomcat-embed请求处理流程：</p>
<blockquote>
<p><img src="https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/tomcat-embed%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B-20220402181017928.jpg" alt="tomcat-embed请求处理流程"></p>
</blockquote>
</li>
<li><p>简要描述：</p>
<blockquote>
<ul>
<li><p>-&gt; endpoint的acceptor线程负责监听服务端口port，将接收到的请求包装成NioSocketWrapper对象向poller实例注册为PollerEvent对象，添加到poller的events队列中，唤醒poller的selector。</p>
</li>
<li><p>-&gt; poller的selector获取到sk，转换回NioSocketWrapper对象。</p>
</li>
<li><p>-&gt; 通过Http11Processor实例来处理NioSocketWrapper对象，转换为Request。</p>
</li>
<li><p>-&gt; 委托给Coyote处理器处理该请求。</p>
</li>
<li><p>-&gt; 通过connector调用service关联各级容器（自上而下）关联Valve pipeline，处理请求。</p>
</li>
<li><p>-&gt; 调用此请求的过滤器链</p>
</li>
<li><p>-&gt; 过滤器链执行完之后调用servlet（即dispatcherServlet）的service方法，真正服务于该请求以获取响应。</p>
<blockquote>
<p>dispatcherServlet继承的超类的service方法，doGet、doPost、doPut、do Delete等方法最终会调用dispatcherServlet的doService方法来处理请求。</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>Http11Processor中的request为org.apache.coyote.Request，是在哪里转换成ServletRequest的，具体ServletRequest实现又是哪个？</strong></p>
<ul>
<li><p>org.apache.coyote.Request </p>
<blockquote>
<ul>
<li>其service方法检查notes[1]是否已有org.apache.catalina.connector.Request对象，没有的话，通过connector.createRequest()创建。</li>
</ul>
</blockquote>
</li>
<li><p>-&gt; org.apache.catalina.connector.Request</p>
<blockquote>
<ul>
<li><p>其存储在org.apache.coyote.Request的notes[1]中。</p>
</li>
<li><p>内部包装了org.apache.coyote.Request成员coyoteRequest。</p>
</li>
</ul>
</blockquote>
</li>
<li><p>-&gt; org.apache.catalina.connector.RequestFacade</p>
<blockquote>
<ul>
<li>通过org.apache.catalina.connector.Request#getRequest()方法获取。</li>
<li>实现了HttpServletRequest接口。</li>
<li>包装Coyote请求对象的Facade类。所有方法都被委托给包装的请求。</li>
<li>内部包装了org.apache.catalina.connector.Request成员request。</li>
</ul>
</blockquote>
</li>
<li><p>其它相关</p>
<blockquote>
<ul>
<li><p>CoyoteAdapter实例是在哪里初始化的？</p>
<blockquote>
<p>Connector#initInternal()</p>
</blockquote>
</li>
<li><p>Http11Processor实例是在哪里初始化的？</p>
<blockquote>
<p>AbstractProtocol#process(SocketWrapperBase<S> wrapper, SocketEvent status) </p>
<p>-&gt; getProtocol().createProcessor();</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>ServletRequest 类图</strong></p>
<blockquote>
<p><img src="https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/ServletRequest.jpg" alt="ServletRequest"></p>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="DispatcherServlet的处理过程"><a href="#DispatcherServlet的处理过程" class="headerlink" title="DispatcherServlet的处理过程"></a>DispatcherServlet的处理过程</h2><blockquote>
<ul>
<li><p>初始化过程</p>
<blockquote>
<p><img src="https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/DispatcherServlet-init.jpg" alt="DispatcherServlet-init"></p>
</blockquote>
</li>
<li><p>处理过程</p>
<blockquote>
<p><img src="https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/DispatcherServlet-doService.jpg" alt="DispatcherServlet-doService"></p>
</blockquote>
</li>
</ul>
</blockquote>
<h2 id="Filter-amp-HandlerInterceptor"><a href="#Filter-amp-HandlerInterceptor" class="headerlink" title="Filter &amp; HandlerInterceptor"></a>Filter &amp; HandlerInterceptor</h2><blockquote>
<ul>
<li><p>Filter</p>
<blockquote>
<ul>
<li><p>jakarta.servlet.Filter</p>
</li>
<li><p>位于tomcat-embed-core包中</p>
</li>
<li><p>过滤器是一种对象，它对资源的请求(servlet或静态内容)或来自资源的响应执行过滤任务，或者两者都执行。过滤器在doFilter方法中执行过滤。每个Filter都可以访问一个FilterConfig 对象，它可以从中获取它的初始化参数，一个对ServletContext的引用，例如，它可以使用它来加载过滤任务所需的资源。<br>过滤器在web应用程序的部署描述符中配置<br>为该设计确定的示例如下：</p>
<ol>
<li>认证过滤器</li>
<li>日志和审计过滤器</li>
<li>图像转换过滤器</li>
<li>数据压缩过滤器</li>
<li>加密过滤器</li>
<li>令牌过滤器</li>
<li>触发资源访问事件的过滤器</li>
<li>XSL/T过滤器</li>
<li>模式链过滤器</li>
</ol>
</li>
<li><p>由服务器调用，其doFilter先于servlet的doService执行。见<strong>ApplicationFilterChain#doFilter</strong>。</p>
</li>
<li><p>方法：</p>
<blockquote>
<ul>
<li><p>init(FilterConfig filterConfig)</p>
</li>
<li><p>doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</p>
<blockquote>
<p>每次由于客户端请求链末端的资源而在链中传递请求/响应对时，容器都会调用Filter的doFilter方法。传入此方法的FilterChain允许Filter将请求和响应传递给链中的下一个实体。<br>这种方法的典型实现将遵循以下模式:</p>
<p>1.检查请求</p>
<p>2.可以选择使用自定义实现包装请求对象，以过滤内容或报头进行输入过滤</p>
<p>3.可选地使用自定义实现包装响应对象以过滤内容或报头以进行输出过滤</p>
<p>4.a)要么使用FilterChain对象(chain. dofilter())调用链中的下一个实体</p>
<p>4.B)或者不将请求/响应对传递给过滤器链中的下一个实体，以阻止请求处理</p>
<p>5.在调用过滤器链中的下一个实体后，直接在响应上设置报头。</p>
</blockquote>
</li>
<li><p>destroy()</p>
<blockquote>
<p>由web容器调用，以指示过滤器将其从服务中取出。只有当筛选器的doFilter方法中的所有线程都退出或经过超时时间后，才会调用此方法。在web容器调用这个方法之后，它将不会在这个过滤器实例上再次调用doFilter 方法。 这个方法让过滤器有机会清理任何被占用的资源(例如，内存、文件句柄、线程)，并确保任何持久状态与过滤器在内存中的当前状态同步。默认的实现是NO-OP。 </p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p>HandlerInterceptor</p>
<blockquote>
<ul>
<li><p>org.springframework.web.servlet.HandlerInterceptor</p>
</li>
<li><p>位于spring-webmvc包中</p>
</li>
<li><p>其执行是在DispatcherServlet#doService方法中。</p>
</li>
<li><p>方法：</p>
<blockquote>
<ul>
<li><p>preHandle</p>
<blockquote>
<p>处理程序执行前的拦截点。在HandlerMapping确定适当的处理程序对象之后调用，但在HandlerAdapter调用处理程序之前调用。 DispatcherServlet在执行链中处理一个处理程序，该执行链由任意数量的拦截器组成，处理程序本身在最后。使用这种方法，每个拦截器都可以决定中止执行链，通常是发送HTTP错误或编写自定义响应。 注意:特殊考虑适用于异步请求处理。要了解更多细节，请参见AsyncHandlerInterceptor</p>
<p>默认实现返回true。</p>
</blockquote>
</li>
<li><p>postHandle</p>
<blockquote>
<p>成功执行处理程序后的拦截点。在HandlerAdapter之后调用实际上调用了处理程序，但在DispatcherServlet呈现视图之前。可以通过给定的ModelAndView向视图公开额外的模型对象。<br>DispatcherServlet在执行链中处理一个处理程序，该执行链由任意数量的拦截器组成，处理程序本身在最后。使用这种方法，每个拦截器都可以对执行进行后处理，以执行链的逆顺序应用。<br>注意:特殊考虑适用于异步请求处理。要了解更多细节，请参见AsyncHandlerInterceptor。<br>默认实现为空。</p>
</blockquote>
</li>
<li><p>afterCompletion</p>
<blockquote>
<p>在请求处理完成后的回调，即在呈现视图之后。将在处理程序执行的任何结果上调用，从而允许适当的资源清理。<br>注意:只有当这个拦截器的preHandle方法成功完成并返回true时才会被调用!<br>与postHandle方法一样，该方法将在链中的每个拦截器上以倒序调用，因此第一个拦截器将是最后一个被调用的。<br>注意:特殊考虑适用于异步请求处理。要了解更多细节，请参见AsyncHandlerInterceptor。<br>默认实现为空。</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p>它的pre、post、completion所相对应地handle，指HandlerAdapter#handle。</p>
<blockquote>
<ul>
<li><p>HandlerAdapter</p>
<blockquote>
<p>MVC框架SPI，允许参数化的核心MVC工作流。 必须为处理请求的每个处理程序类型实现的接口。这个接口用于允许DispatcherServlet无限扩展。DispatcherServlet通过这个接口访问所有安装的处理程序，这意味着它不包含特定于任何处理程序类型的代码。 注意，处理程序可以是Object类型的。这使得来自其他框架的处理程序无需自定义编码就可以与该框架集成，并且允许不遵守任何特定Java接口的注释驱动的处理程序对象。 此接口不适合应用程序开发人员使用。它适用于那些想要开发自己的web工作流的处理程序。 注意:HandlerAdapter实施者可以实现org.springframework.core.Ordered接口，以便能够指定DispatcherServlet应用的排序顺序(因此是优先级)。Non-Ordered实例被视为最低优先级。 </p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p>Y：对比</p>
<blockquote>
<p>两者虽都是处于请求处理过程某个节点，但是各有侧重。Filter处于servlet提供服务之前，侧重通用式的过滤；HandlerInterceptor则处于servlet服务中，更细化一些，而且可以针对HandlerAdapter处理结果进一步处理。</p>
</blockquote>
</li>
</ul>
</blockquote>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/SpringBoot/">SpringBoot</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2022/04/07/Spring%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B-2/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Spring应用启动过程-2</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2022/03/21/JVM%E8%B0%83%E4%BC%98/">
        <span class="next-text nav-default">JVM调优</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2014 -
    
    2023
    <span class="footer-author">青马流光.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
