<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="HashMap中的红黑树实现-TreeNode"/>




  <meta name="keywords" content="Java," />





  <link rel="alternate" href="/default" title="青马流光的博客" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="http://blog.coder.love/2021/08/12/HashMap-TreeNode/"/>


<meta name="description" content="红黑树源于对2-3-4树的简易实现。参考《Sedgewick的红黑树》 TreeNode 同时实现了两种数据结构：  双向链表：prev、next 红黑树：parent、left、right、red  ​      方便了不同场景的应用，也方便了上层即HashMap中的封装，比如在没有HashMap的containsValue()方法中遍历冲突链表就没有特别去判断是否为树结构，因为TreeNode">
<meta property="og:type" content="article">
<meta property="og:title" content="HashMap中的红黑树实现-TreeNode">
<meta property="og:url" content="http://blog.coder.love/2021/08/12/HashMap-TreeNode/index.html">
<meta property="og:site_name" content="青马流光的博客">
<meta property="og:description" content="红黑树源于对2-3-4树的简易实现。参考《Sedgewick的红黑树》 TreeNode 同时实现了两种数据结构：  双向链表：prev、next 红黑树：parent、left、right、red  ​      方便了不同场景的应用，也方便了上层即HashMap中的封装，比如在没有HashMap的containsValue()方法中遍历冲突链表就没有特别去判断是否为树结构，因为TreeNode">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A5-%E5%AF%B9%E6%A0%872-3-4%E6%A0%91.jpg">
<meta property="og:image" content="https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4-%E5%AF%B9%E8%A1%A82-3-4%E6%A0%91.jpg">
<meta property="article:published_time" content="2021-08-12T03:30:25.000Z">
<meta property="article:modified_time" content="2022-04-01T05:44:06.990Z">
<meta property="article:author" content="青马流光">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A5-%E5%AF%B9%E6%A0%872-3-4%E6%A0%91.jpg">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  <script id="baidu_analytics">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?65a3f3228e88e62009896032ddcfdf2b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



    <title> HashMap中的红黑树实现-TreeNode - 青马流光的博客 </title>
  <meta name="generator" content="Hexo 5.4.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">青马流光的博客</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          HashMap中的红黑树实现-TreeNode
        
      </h1>

      <time class="post-time">
          8月 12 2021
      </time>
    </header>



    
            <div class="post-content">
            <p>红黑树源于对2-3-4树的简易实现。参考《<a target="_blank" rel="noopener" href="https://www.cnblogs.com/eniac12/p/5558848.html">Sedgewick的红黑树</a>》</p>
<p>TreeNode 同时实现了两种数据结构：</p>
<ul>
<li>双向链表：prev、next</li>
<li>红黑树：parent、left、right、red</li>
</ul>
<p>​      方便了不同场景的应用，也方便了上层即HashMap中的封装，比如在没有HashMap的containsValue()方法中遍历冲突链表就没有特别去判断是否为树结构，因为TreeNode本身也还是链表结构。</p>
<p>​      这两种结构字段是相互独立的，可以看做两条线，但在发生节点位置变化时，需同时维护两条线的正确。如树结构的平衡性调整之后，root节点可能会变更，root变更即意味了链表结构的头节点变更，所以有了moveRootToFront()方法，将新的头节点（root节点）移动到链表头部。</p>
<p>TreeNode 中元素是如何排序的？</p>
<ol>
<li>通过元素key的hash值：HashMap.hash(key)。（记为1级排序方式）</li>
<li>若hash相同，且元素key为可比较类型，则使用compareComparables方法比较其key。（记为2级排序方式）</li>
<li>若hash相同，且元素key为不可比较类型，则使用tieBreakOrder来 比较两个元素的key。（记为3级排序方式）<ol>
<li>先使用类名即getClass().getName()进行比较</li>
<li>若相同则使用由System.identityHashCode(key)生成的key对象的hashCode。</li>
</ol>
</li>
</ol>
<p><strong>find方法源码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用给定的散列和键查找从根 p 开始的节点。 kc 参数在第一次使用比较key时缓存的其可比较类型。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">            TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">          <span class="comment">// 1. 先使用key的hash进行比较排序，即1级排序方式。</span></span><br><span class="line">            <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                p = pl;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                p = pr;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 2. 执行到此处说明其左右子树的节点均与key的hash相等，但是与key不等，需要使用其它方式进一步排序</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 左节点为空的情况，直接将右节点作为下次循环比较的节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">                p = pr;</span><br><span class="line">          <span class="comment">// 右节点为空的情况，直接将左节点作为下次循环比较的节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">                p = pl;</span><br><span class="line">          <span class="comment">// 左右节点均不为空，根据二级排序方式重新比较pk与k以决定方向，选取下一次循环的比较节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                      (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                     (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 执行到这里说明无法通过comparable比较，或者比较之后还是相等</span></span><br><span class="line">          <span class="comment">// 此处未采用3级比较，而是直接后序遍历其子节点，找到即刻返回，应该是考虑到这样效率更高。</span></span><br><span class="line">          </span><br><span class="line">       <span class="comment">// 从右节点递归遍历右子树，如果找到了匹配的则返回</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> q;</span><br><span class="line">          <span class="comment">// 右子树未找到，从左节点进入下一个循环</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = pl;</span><br><span class="line">        &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">      <span class="comment">// 未找到匹配元素，返回null。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>putTreeVal方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">				  <span class="comment">// searched记录是否遍历查找过该元素，最多查找一次</span></span><br><span class="line">            <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">            TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">              <span class="comment">// dir 记录方向</span></span><br><span class="line">                <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">              <span class="comment">// 1级排序方式</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">	              <span class="comment">// 采用1级排序方式找到对应元素</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">              <span class="comment">// 2级排序方式</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">// 2级排序方式</span></span><br><span class="line">                    <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                      <span class="comment">//最多执行一次</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                        searched = <span class="keyword">true</span>;</span><br><span class="line">	                      <span class="comment">// 基于find方法找到了对应元素</span></span><br><span class="line">                        <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                            ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                            <span class="keyword">return</span> q;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="comment">// 3级排序方式</span></span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">              <span class="comment">// p循环到叶子节点，即树中无该元素且找到了插入节点x可能的父节点xp。</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// 构造待插入节点x</span></span><br><span class="line">	                  Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                  <span class="comment">// 在树结构中插入x（平衡前位置），此时插入的位置一定是空的。</span></span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                  <span class="comment">// 在链表结构中插入x</span></span><br><span class="line">                    xp.next = x;</span><br><span class="line">                    x.parent = x.prev = xp;</span><br><span class="line">                    <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                  <span class="comment">// 插入再平衡</span></span><br><span class="line">                    moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>对标2-3-4树看红黑树的插入平衡性调整逻辑：</p>
<p><img src="https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A5-%E5%AF%B9%E6%A0%872-3-4%E6%A0%91.jpg" alt="红黑树插入-对标2-3-4树"></p>
<p>balanceInsertion方法源码：</p>
<ul>
<li>并没有严格按照左倾或右倾红黑树来实现，效率优先，只有左右旋时左右倾才是必要的，所以将统一左右倾整合到了左右旋方法中）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 新插入节点初始状态：红色</span></span><br><span class="line">    x.red = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">      <span class="comment">// parent为null说明x为root，调整为黑色并返回，对应所有最终引起root节点变更的情况的最后一步。</span></span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 父节点为黑色，不需要调整（对应情况1及2.3）。</span></span><br><span class="line">      <span class="comment">// Y: 父节点为root，且为红色，这是为什么？这种情况又是怎么出现的？</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">      <span class="comment">// 父节点为左倾，则按左倾进行平衡。</span></span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">          <span class="comment">// 有叔叔节点且叔叔节点为红色，对应情况3.3和3.4（只是并没有将3.4调整为左倾，因为没有必要）</span></span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">          		<span class="comment">// 爷爷节点xpp及其左右节点变色：上红下黑。</span></span><br><span class="line">                xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">              <span class="comment">// 爷爷节点xpp等价于2-3-4树合并到4节点分裂上提的那个节点，其插入上一层节点可能引起新的不平衡。</span></span><br><span class="line">              <span class="comment">// 爷爷节点xpp作为新的插入节点x，进入平衡性插入的下一次迭代。</span></span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 类似情况2</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 如果x为右倾，通过以xp左旋调整为左倾。类似情况2.2的第一次旋转</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                    root = rotateLeft(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">// 因为上一步可能发生左旋而引起xp的变化，所以此处做了非空判断。</span></span><br><span class="line">              <span class="comment">// 变色 + 第二次旋转，类似情况2.1 与 2.2第一次旋转后</span></span><br><span class="line">              <span class="comment">// 即xp、xpp的变色 + 涉及xp的以xpp开启的旋转</span></span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateRight(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 父节点为右倾，则按右倾进行平衡。</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 有叔叔节点，且叔叔节点为红色，对应情况3.1和3.2（只是并没有将3.2调整为左倾，因为没有必要）</span></span><br><span class="line">          <span class="comment">// 2-3-4树中分裂上提之后新插入节点都会与另一个节点组成一个3-节点，等价到红黑树中两者上下关系并不重要。</span></span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">          		<span class="comment">// 爷爷节点xpp及其左右节点变色：上红下黑。</span></span><br><span class="line">                xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">              <span class="comment">// 爷爷节点xpp等价于2-3-4树合并到4节点时分裂上提的那个节点，其插入上一层节点可能引起新的不平衡。</span></span><br><span class="line">              <span class="comment">// 爷爷节点xpp作为新的插入节点x，进入平衡性插入的下一次迭代。</span></span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//对应情况2.2，第一次右旋调整后变为情况2.1</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                    root = rotateRight(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">// 情况2.1</span></span><br><span class="line">              <span class="comment">// xp、xpp的变色 + 涉及xp的以xpp开启的左旋</span></span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                      <span class="comment">// 以xpp左旋</span></span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rotateLeft方法源码：（右旋同理）</p>
<p>注意：TreeNode实现中的左右旋将，实际可能做了两次旋转，如下面注释中的旋转1和2.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">/** 旋转1，父节点为右倾，需先统一调整为右倾，才能做下边的旋转2。</span></span><br><span class="line"><span class="comment">           *   5        5</span></span><br><span class="line"><span class="comment">           *    \        \</span></span><br><span class="line"><span class="comment">           *     7  =&gt;    6</span></span><br><span class="line"><span class="comment">           *    /          \</span></span><br><span class="line"><span class="comment">           *   6            7</span></span><br><span class="line"><span class="comment">           * */</span></span><br><span class="line">            <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)</span><br><span class="line">                rl.parent = p;</span><br><span class="line">          <span class="comment">// 若p为根节点，则此次旋转root变更，并将新的root变为黑色。</span></span><br><span class="line">            <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">                (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">          <span class="comment">/** 旋转2</span></span><br><span class="line"><span class="comment">           * 5            6</span></span><br><span class="line"><span class="comment">           *  \          / \</span></span><br><span class="line"><span class="comment">           *   6    =&gt;  5   7</span></span><br><span class="line"><span class="comment">           *    \</span></span><br><span class="line"><span class="comment">           *     7</span></span><br><span class="line"><span class="comment">           * */</span></span><br><span class="line">          <span class="comment">// 若p不是根节点，变更pp与p、r的关系</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">                pp.left = r;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pp.right = r;</span><br><span class="line">          <span class="comment">// 变更r与p的关系</span></span><br><span class="line">            r.left = p;</span><br><span class="line">            p.parent = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>moveRootToFront方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 确保给定的根是其冲突链表的头节点。Y: 注意理解链接结构字段与树结构字段是独立的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; tab != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="comment">// 找到当前该冲突链表头节点。</span></span><br><span class="line">            <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; root.hash;</span><br><span class="line">            TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">          <span class="comment">// 如果当前该冲突头节点不是给定root节点，则将root移到该冲突链表头部。</span></span><br><span class="line">            <span class="keyword">if</span> (root != first) &#123;</span><br><span class="line">                Node&lt;K,V&gt; rn;</span><br><span class="line">                tab[index] = root;</span><br><span class="line">                TreeNode&lt;K,V&gt; rp = root.prev;</span><br><span class="line">                <span class="keyword">if</span> ((rn = root.next) != <span class="keyword">null</span>)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)rn).prev = rp;</span><br><span class="line">                <span class="keyword">if</span> (rp != <span class="keyword">null</span>)</span><br><span class="line">                    rp.next = rn;</span><br><span class="line">                <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                    first.prev = root;</span><br><span class="line">                root.next = first;</span><br><span class="line">                root.prev = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 递归不变检查。</span></span><br><span class="line">            <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>checkInvariants方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归不变检查。 t非空。该检查可保证树结构与链表结构是统一的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">checkInvariants</span><span class="params">(TreeNode&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right,</span><br><span class="line">            tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next;</span><br><span class="line">     <span class="comment">// 检查前驱节点：若存在前驱节点，前驱节点的后继必须为t。</span></span><br><span class="line">        <span class="keyword">if</span> (tb != <span class="keyword">null</span> &amp;&amp; tb.next != t)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 检查后继节点：若存在后继节点，后继节点的前驱必须为t。</span></span><br><span class="line">        <span class="keyword">if</span> (tn != <span class="keyword">null</span> &amp;&amp; tn.prev != t)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 检查父节点：若存在父节点，父节点的左右子节点中必有一个是t。</span></span><br><span class="line">        <span class="keyword">if</span> (tp != <span class="keyword">null</span> &amp;&amp; t != tp.left &amp;&amp; t != tp.right)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 检查左节点：若存在左节点，其父节点必须为t且其hash必须小于等于t的hash。1级排序，左小</span></span><br><span class="line">        <span class="keyword">if</span> (tl != <span class="keyword">null</span> &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 检查右节点：若存在右节点，其父节点必须为t且其hash必须大于等于t的hash。1级排序，右大</span></span><br><span class="line">        <span class="keyword">if</span> (tr != <span class="keyword">null</span> &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 检查t的颜色：若为红色，则其左右节点不能都为红色。</span></span><br><span class="line">      <span class="comment">// Y: 若一个不存在，另一个子节点为红色呢？也不符合红黑树定义啊。</span></span><br><span class="line">      <span class="comment">// 对应查看balanceInsertion方法，存在红色root上插入节点的可能，不明原因？</span></span><br><span class="line">        <span class="keyword">if</span> (t.red &amp;&amp; tl != <span class="keyword">null</span> &amp;&amp; tl.red &amp;&amp; tr != <span class="keyword">null</span> &amp;&amp; tr.red)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 递归检查左子树</span></span><br><span class="line">        <span class="keyword">if</span> (tl != <span class="keyword">null</span> &amp;&amp; !checkInvariants(tl))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 递归检查右子树</span></span><br><span class="line">        <span class="keyword">if</span> (tr != <span class="keyword">null</span> &amp;&amp; !checkInvariants(tr))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>removeTreeNode方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除给定节点，该节点必须在此调用之前存在。 这比典型的红黑删除代码更混乱，因为我们无法将内部节点的内容与叶后继交换，该				 * 后继由在遍历期间可独立访问的“下一个”指针固定。 因此，我们交换树链接。 如果当前树的节点似乎太少，则将 bin 转换回普通 				 * bin。 （测试会在 2 到 6 个节点之间触发，具体取决于树结构）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">  <span class="comment">// 空映射，返回</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">    TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">  <span class="comment">// next为待删除节点的后继节点，prev为待删除节点的前驱节点。succ -&gt; succeed 继......之后</span></span><br><span class="line">    TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 首先链表结构上删除该节点。前驱、后继直接相连</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 1. 前驱为空，说明为root</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        tab[index] = first = succ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = succ;</span><br><span class="line">    <span class="keyword">if</span> (succ != <span class="keyword">null</span>)</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">  <span class="comment">// first为空，说明链表为空，唯一的一个节点已被删除。</span></span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2. 树结构上删除该节点</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// root存在父节点说明此时root不是真实的根节点，需要更新为当前的根节点。（Y: 是怎么产生的？）</span></span><br><span class="line">    <span class="keyword">if</span> (root.parent != <span class="keyword">null</span>)</span><br><span class="line">        root = root.root();</span><br><span class="line">  <span class="comment">// 冲突元素太少，从红黑树降级为单链表HashMap.Node。</span></span><br><span class="line">  <span class="comment">// movable 可移动的，若为false则删除元素时不移动其它节点。</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span></span><br><span class="line">        || (movable</span><br><span class="line">            &amp;&amp; (root.right == <span class="keyword">null</span></span><br><span class="line">                || (rl = root.left) == <span class="keyword">null</span></span><br><span class="line">                || rl.left == <span class="keyword">null</span>))) &#123;</span><br><span class="line">        tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 直接删除节点p，转换成找到其替代节点replacement，将replacement与p节点互换位置，再删除p，使树结构变动最小。</span></span><br><span class="line">  </span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">  <span class="comment">// 情况1：p有两个子节点，找到它右子树中的最小值，为replacement。</span></span><br><span class="line">    <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">      <span class="comment">// 找到p的替代者，即其右子树中最小值s</span></span><br><span class="line">        <span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">// find successor</span></span><br><span class="line">            s = sl;</span><br><span class="line">      <span class="comment">// 交换s与其替代者的颜色</span></span><br><span class="line">        <span class="keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="comment">// swap colors</span></span><br><span class="line">        TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">      <span class="comment">// 若找到的替代者为p的子节点即右节点，把p挂到s的右节点（Y：为什么是右节点？因为左节点要与p的左节点建立链接）。</span></span><br><span class="line">        <span class="keyword">if</span> (s == pr) &#123; <span class="comment">// p was s&#x27;s direct parent</span></span><br><span class="line">            p.parent = s;</span><br><span class="line">            s.right = p;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 否则，把p与sp建立链接，s与pr建立链接</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">            <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                    sp.left = p;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sp.right = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>)</span><br><span class="line">                pr.parent = s;</span><br><span class="line">        &#125;</span><br><span class="line">        p.left = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// s的右节点作为p的右节点与p建立双向链接。</span></span><br><span class="line">        <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)</span><br><span class="line">            sr.parent = p;</span><br><span class="line">      <span class="comment">// p的原左节点作为s的左节点，两者建立双向链接。</span></span><br><span class="line">        <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)</span><br><span class="line">            pl.parent = s;</span><br><span class="line">      <span class="comment">// s与p的父节点pp建立双向链接。且若p原为root，则更新s为root。</span></span><br><span class="line">        <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>)</span><br><span class="line">            root = s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = s;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = s;</span><br><span class="line">      <span class="comment">// sr存在时，等同于情况2，再次用sr替代p</span></span><br><span class="line">        <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">            replacement = sr;</span><br><span class="line">      <span class="comment">// sr不存在，等同于情况3</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            replacement = p;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 情况2: p有一个子节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">        replacement = pl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">        replacement = pr;</span><br><span class="line">  <span class="comment">// 情况3: p为叶子节点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        replacement = p;</span><br><span class="line">  <span class="comment">// replacement非p时，还需要一次位置互换，将replacement与pp建立双向链接，删除p与树的关系。</span></span><br><span class="line">    <span class="keyword">if</span> (replacement != p) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (pp == <span class="keyword">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = replacement;</span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 若替换后p最终为红色，则删除不影响树结构，不调整，否则进行删除的平衡性调整。</span></span><br><span class="line">  <span class="comment">// 到此处，replacement或者为p本身或者已代替了p的位置，且replacement一定是叶子节点。</span></span><br><span class="line">    TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// replacement即为p时，清除p与树之间可能存在的任何引用。</span></span><br><span class="line">  <span class="comment">// 如p的原父亲节点若仍保留有对p的引用，则删除它，删除p对pp的引用。</span></span><br><span class="line">    <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">// detach</span></span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        p.parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                pp.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                pp.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (movable)</span><br><span class="line">        moveRootToFront(tab, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对标2-3-4树看红黑树删除平衡性调整逻辑：</p>
<p><img src="https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4-%E5%AF%B9%E8%A1%A82-3-4%E6%A0%91.jpg" alt="红黑树删除-对表2-3-4树"></p>
<p>balanceDeletion方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该方法实际所做的事情与删除无直接关系，实际是x子树黑高矮一层，向上借一个黑色节点，达到黑色平衡。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceDeletion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 进入这个方法，说明被替代的节点p之前是黑色的，因为红色的不需要调整</span></span><br><span class="line"><span class="comment">    * 进入该方法的时候，替代节点可能与删除节点相等：x == replacement == p</span></span><br><span class="line"><span class="comment">    *                  替代节点可能与删除节点不相等：x == replacement ！= p</span></span><br><span class="line"><span class="comment">    * 此处可不在考虑删除，而将x视为借东西的节点，在向父亲xp借，xp帮忙从兄弟节点乃至上层去借。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">     <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) &#123;</span><br><span class="line">       <span class="comment">// x为空或root时</span></span><br><span class="line">         <span class="keyword">if</span> (x == <span class="keyword">null</span> || x == root)</span><br><span class="line">             <span class="keyword">return</span> root;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">             x.red = <span class="keyword">false</span>;</span><br><span class="line">             <span class="keyword">return</span> x;</span><br><span class="line">         &#125;</span><br><span class="line">       <span class="comment">// 相当于自己有，不用借，置为黑，可能自己开始就有，也可能是向上迭代中指向了富裕的祖先节点。</span></span><br><span class="line">       <span class="comment">// x初始状态为红色的情况的终点；再有就是情况1、情况2.1、情况4.1可能的终点</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (x.red) &#123;</span><br><span class="line">             x.red = <span class="keyword">false</span>;</span><br><span class="line">             <span class="keyword">return</span> root;</span><br><span class="line">         &#125;</span><br><span class="line">       <span class="comment">// 若x在其父节点的左侧</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> ((xpl = xp.left) == x) &#123;</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 情况3：x有兄弟节点xpr，且为红色，则xpr必有两个黑色子节点（对比2-3-4树的3-节点可知）。</span></span><br><span class="line"><span class="comment">            *   1. 将兄弟节点设为黑色；</span></span><br><span class="line"><span class="comment">            *   2. 将父节点设为红色；</span></span><br><span class="line"><span class="comment">            *   3. 以父节点进行左旋，更新xp、xpr，如此借到了原xprl为新的xpr，转化为情况4。</span></span><br><span class="line"><span class="comment">            **/</span> </span><br><span class="line">             <span class="keyword">if</span> ((xpr = xp.right) != <span class="keyword">null</span> &amp;&amp; xpr.red) &#123;</span><br><span class="line">                 xpr.red = <span class="keyword">false</span>;</span><br><span class="line">                 xp.red = <span class="keyword">true</span>;</span><br><span class="line">                 root = rotateLeft(root, xp);</span><br><span class="line">                 xpr = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.right;</span><br><span class="line">             &#125;</span><br><span class="line">           <span class="comment">// 情况1 x无兄弟节点，则x指向父节点，向上调整</span></span><br><span class="line">             <span class="keyword">if</span> (xpr == <span class="keyword">null</span>)</span><br><span class="line">                 x = xp;</span><br><span class="line">           <span class="comment">// x有兄弟节点xpr，非情况1和情况3，则只能是情况2和情况4</span></span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                 TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</span><br><span class="line">               <span class="comment">// 情况2.1和情况4.1 无子节点</span></span><br><span class="line">               <span class="comment">// x的兄弟节点xpr没有子节点，可将xpr设为红色，xp局部平衡但高度整体少1，x指向xp，向上调整。</span></span><br><span class="line">                 <span class="keyword">if</span> ((sr == <span class="keyword">null</span> || !sr.red) &amp;&amp;</span><br><span class="line">                     (sl == <span class="keyword">null</span> || !sl.red)) &#123;</span><br><span class="line">                     xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                     x = xp;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="keyword">if</span> (sr == <span class="keyword">null</span> || !sr.red) &#123;</span><br><span class="line">                       <span class="comment">// 情况2.2和情况4.2 xpr只左节点sl</span></span><br><span class="line">                         <span class="keyword">if</span> (sl != <span class="keyword">null</span>)</span><br><span class="line">                             sl.red = <span class="keyword">false</span>;</span><br><span class="line">                         xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                       <span class="comment">// 以xpr右旋，变为右倾，目的是保证有右节点。更新xp与xpr，转化为情况2.3和4.3</span></span><br><span class="line">                       <span class="comment">// 旋转操作可能会引起root变化，若变化则更新root。</span></span><br><span class="line">                         root = rotateRight(root, xpr);</span><br><span class="line">                         xpr = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                             <span class="keyword">null</span> : xp.right;</span><br><span class="line">                     &#125;</span><br><span class="line">                    <span class="comment">// 情况2.3 和情况4.3 xpr有右节点</span></span><br><span class="line">                     <span class="keyword">if</span> (xpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">// 让兄弟节点xpr变为父节点的颜色，因为在让它代替父节点的位置时不改变树的平衡状态</span></span><br><span class="line">                         xpr.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                         <span class="keyword">if</span> ((sr = xpr.right) != <span class="keyword">null</span>)</span><br><span class="line">                           <span class="comment">// 将xpr的右节点，设为黑色，保证xp右子树的黑色树高不变。</span></span><br><span class="line">                             sr.red = <span class="keyword">false</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">//将xp设为黑色，以xp左旋，补充到新xp的左子树，树高增加一层。整体平衡。</span></span><br><span class="line">                         xp.red = <span class="keyword">false</span>;</span><br><span class="line">                         root = rotateLeft(root, xp);</span><br><span class="line">                     &#125;</span><br><span class="line">                   <span class="comment">// 令x为root，进入下一次循环时终止循环。</span></span><br><span class="line">                     x = root;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123; <span class="comment">// symmetric 对称</span></span><br><span class="line">             <span class="keyword">if</span> (xpl != <span class="keyword">null</span> &amp;&amp; xpl.red) &#123;</span><br><span class="line">                 xpl.red = <span class="keyword">false</span>;</span><br><span class="line">                 xp.red = <span class="keyword">true</span>;</span><br><span class="line">                 root = rotateRight(root, xp);</span><br><span class="line">                 xpl = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.left;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (xpl == <span class="keyword">null</span>)</span><br><span class="line">                 x = xp;</span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                 TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;</span><br><span class="line">                 <span class="keyword">if</span> ((sl == <span class="keyword">null</span> || !sl.red) &amp;&amp;</span><br><span class="line">                     (sr == <span class="keyword">null</span> || !sr.red)) &#123;</span><br><span class="line">                     xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                     x = xp;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="keyword">if</span> (sl == <span class="keyword">null</span> || !sl.red) &#123;</span><br><span class="line">                         <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                             sr.red = <span class="keyword">false</span>;</span><br><span class="line">                         xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                         root = rotateLeft(root, xpl);</span><br><span class="line">                         xpl = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                             <span class="keyword">null</span> : xp.left;</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">if</span> (xpl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         xpl.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                         <span class="keyword">if</span> ((sl = xpl.left) != <span class="keyword">null</span>)</span><br><span class="line">                             sl.red = <span class="keyword">false</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         xp.red = <span class="keyword">false</span>;</span><br><span class="line">                         root = rotateRight(root, xp);</span><br><span class="line">                     &#125;</span><br><span class="line">                     x = root;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<hr>
<blockquote>
<p><strong>感谢参考的文章及作者：</strong></p>
<ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41725090/article/details/82147576">【源码分析】hashmap中的红黑树是如何进行排序的2</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42340670/article/details/80753826">JDK8：HashMap源码解析：TreeNode类的find方法</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/eniac12/p/5558848.html">Sedgewick的红黑树</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/c159cc/article/details/107227842">java的HashMap中TreeNode节点的删除复杂性分析</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40722604/article/details/107792636">10、JDK1.8HashMap源码分析系列文章（balanceDeletion）</a></li>
</ol>
<p>推荐一个期间使用的：<a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">红黑树操作可视化网站</a></p>
</blockquote>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/Java/">Java</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2021/08/14/mysql-transaction/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Mysql事务</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2021/08/11/start/">
        <span class="next-text nav-default">Start</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2014 -
    
    2022
    <span class="footer-author">青马流光.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
