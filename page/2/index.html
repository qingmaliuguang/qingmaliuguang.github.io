<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.coder.love","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="青马流光的博客">
<meta property="og:url" content="http://blog.coder.love/page/2/index.html">
<meta property="og:site_name" content="青马流光的博客">
<meta property="og:description" content="学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="青马流光">
<meta property="article:tag" content="Java、数据">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://blog.coder.love/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>青马流光的博客</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">青马流光的博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Code the love to the world.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">青马流光</p>
  <div class="site-description" itemprop="description">学习笔记</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.coder.love/2021/09/06/JVM-ReadNote/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="青马流光">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="青马流光的博客">
      <meta itemprop="description" content="学习笔记">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 青马流光的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/06/JVM-ReadNote/" class="post-title-link" itemprop="url">JVM-ReadNote</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-06 12:54:04" itemprop="dateCreated datePublished" datetime="2021-09-06T12:54:04+08:00">2021-09-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-21 15:14:11" itemprop="dateModified" datetime="2022-03-21T15:14:11+08:00">2022-03-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-散点记录"><a href="#1-散点记录" class="headerlink" title="1. 散点记录"></a>1. 散点记录</h1><ul>
<li><p>-Xms &amp; -Xmx</p>
</li>
<li><p>-XX:+HeapDumpOnOutOfMemoryError</p>
<p>当抛出java.lang.OutOfMemoryError异常时，Dump出当前的<strong>内存堆转储快照</strong>以便进行事后分析。</p>
</li>
<li><p>从Java7开始字符串常量池从方法区移到了Java堆中，通过String.intern方法填充字符串常量池因此的OutOfMemoryError: Java heap space。</p>
</li>
<li><p>从Java8开始，永久代已没有了，方法区中剩余信息移到通过直接内存创建的元空间。字符串常量池仍在堆中不在方法区中。</p>
<ul>
<li><p>元空间相关参数</p>
<ul>
<li><p>-XX:MaxMetaspaceSize=size</p>
<p>元空间最大值，默认为-1，即不限制。</p>
</li>
<li><p>-XX:MetaspaceSize=size</p>
<p>元空间初始大小</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>字符串常量池虽然物理上存放在堆中，但逻辑上仍属于方法区。</p>
</li>
<li><p>-XX:MaxDirectMemorySize=size</p>
<p>直接内存容量最大值，默认与Java堆最大值（-Xmx指定）一致。</p>
</li>
<li><p>垃圾回收</p>
<ul>
<li><p>对象存活判定算法</p>
<ul>
<li>引用计数算法</li>
<li>可达性分析算法</li>
</ul>
</li>
<li><p>分代收集理论</p>
<ul>
<li>基于三条经验假说：弱分代假说、强分代假说、跨代引用假说</li>
</ul>
</li>
<li><p>垃圾收集算法</p>
</li>
<li><p>算法实现——垃圾收集器</p>
<ul>
<li>可达性分析算法<ul>
<li>根节点枚举<ul>
<li>HotSpot：使用一组称为OopMap的数据结构。</li>
</ul>
</li>
<li>安全点<ul>
<li>安全点的选定：“长时间执行”的最明显特征就是指令序列的复用，如方法调用、循环跳转、异常跳转等。</li>
<li>在垃圾收集发生时让所有线程都跑到最近的安全点：主动式中断<ul>
<li>HotSpot使用内存保护陷阱的方式，把轮询操作精简至只有一条汇编指令的程度。</li>
</ul>
</li>
</ul>
</li>
<li>安全区<ul>
<li>执行到安全区时，标识自己已经进入了安全区。</li>
<li>离开安全区域前，检查虚拟机是否已经完成了根节点枚举。</li>
</ul>
</li>
<li>跨代引用及部分区域收集（Partial GC）行为的跨区域引用问题<ul>
<li>Remembered Set 记忆集  -&gt; 常用实现：卡表（Card Table）<ul>
<li>卡表元素维护问题：HotSpot虚拟机里是通过写后屏障技术（非并发中的内存屏障）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>JVM规范中定义的指令集：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se16/html/jvms-2.html#jvms-2.11">2.11. Instruction Set Summary</a></p>
<p>Java虚拟机指令集中的类型支持：</p>
<table>
<thead>
<tr>
<th>pcode</th>
<th><code>byte</code></th>
<th><code>short</code></th>
<th><code>int</code></th>
<th><code>long</code></th>
<th><code>float</code></th>
<th><code>double</code></th>
<th><code>char</code></th>
<th><code>reference</code></th>
</tr>
</thead>
<tbody><tr>
<td><em>Tipush</em></td>
<td><em>bipush</em></td>
<td><em>sipush</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>Tconst</em></td>
<td></td>
<td></td>
<td><em>iconst</em></td>
<td><em>lconst</em></td>
<td><em>fconst</em></td>
<td><em>dconst</em></td>
<td></td>
<td><em>aconst</em></td>
</tr>
<tr>
<td><em>Tload</em></td>
<td></td>
<td></td>
<td><em>iload</em></td>
<td><em>lload</em></td>
<td><em>fload</em></td>
<td><em>dload</em></td>
<td></td>
<td><em>aload</em></td>
</tr>
<tr>
<td><em>Tstore</em></td>
<td></td>
<td></td>
<td><em>istore</em></td>
<td><em>lstore</em></td>
<td><em>fstore</em></td>
<td><em>dstore</em></td>
<td></td>
<td><em>astore</em></td>
</tr>
<tr>
<td><em>Tinc</em></td>
<td></td>
<td></td>
<td><em>iinc</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>Taload</em></td>
<td><em>baload</em></td>
<td><em>saload</em></td>
<td><em>iaload</em></td>
<td><em>laload</em></td>
<td><em>faload</em></td>
<td><em>daload</em></td>
<td><em>caload</em></td>
<td><em>aaload</em></td>
</tr>
<tr>
<td><em>Tastore</em></td>
<td><em>bastore</em></td>
<td><em>sastore</em></td>
<td><em>iastore</em></td>
<td><em>lastore</em></td>
<td><em>fastore</em></td>
<td><em>dastore</em></td>
<td><em>castore</em></td>
<td><em>aastore</em></td>
</tr>
<tr>
<td><em>Tadd</em></td>
<td></td>
<td></td>
<td><em>iadd</em></td>
<td><em>ladd</em></td>
<td><em>fadd</em></td>
<td><em>dadd</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>Tsub</em></td>
<td></td>
<td></td>
<td><em>isub</em></td>
<td><em>lsub</em></td>
<td><em>fsub</em></td>
<td><em>dsub</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>Tmul</em></td>
<td></td>
<td></td>
<td><em>imul</em></td>
<td><em>lmul</em></td>
<td><em>fmul</em></td>
<td><em>dmul</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>Tdiv</em></td>
<td></td>
<td></td>
<td><em>idiv</em></td>
<td><em>ldiv</em></td>
<td><em>fdiv</em></td>
<td><em>ddiv</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>Trem</em></td>
<td></td>
<td></td>
<td><em>irem</em></td>
<td><em>lrem</em></td>
<td><em>frem</em></td>
<td><em>drem</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>Tneg</em></td>
<td></td>
<td></td>
<td><em>ineg</em></td>
<td><em>lneg</em></td>
<td><em>fneg</em></td>
<td><em>dneg</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>Tshl</em></td>
<td></td>
<td></td>
<td><em>ishl</em></td>
<td><em>lshl</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>Tshr</em></td>
<td></td>
<td></td>
<td><em>ishr</em></td>
<td><em>lshr</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>Tushr</em></td>
<td></td>
<td></td>
<td><em>iushr</em></td>
<td><em>lushr</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>Tand</em></td>
<td></td>
<td></td>
<td><em>iand</em></td>
<td><em>land</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>Tor</em></td>
<td></td>
<td></td>
<td><em>ior</em></td>
<td><em>lor</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>Txor</em></td>
<td></td>
<td></td>
<td><em>ixor</em></td>
<td><em>lxor</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>i2T</em></td>
<td><em>i2b</em></td>
<td><em>i2s</em></td>
<td></td>
<td><em>i2l</em></td>
<td><em>i2f</em></td>
<td><em>i2d</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>l2T</em></td>
<td></td>
<td></td>
<td><em>l2i</em></td>
<td></td>
<td><em>l2f</em></td>
<td><em>l2d</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>f2T</em></td>
<td></td>
<td></td>
<td><em>f2i</em></td>
<td><em>f2l</em></td>
<td></td>
<td><em>f2d</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>d2T</em></td>
<td></td>
<td></td>
<td><em>d2i</em></td>
<td><em>d2l</em></td>
<td><em>d2f</em></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>Tcmp</em></td>
<td></td>
<td></td>
<td></td>
<td><em>lcmp</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>Tcmpl</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><em>fcmpl</em></td>
<td><em>dcmpl</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>Tcmpg</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><em>fcmpg</em></td>
<td><em>dcmpg</em></td>
<td></td>
<td></td>
</tr>
<tr>
<td><em>if_TcmpOP</em></td>
<td></td>
<td></td>
<td><em>if_icmpOP</em></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><em>if_acmpOP</em></td>
</tr>
<tr>
<td><em>Treturn</em></td>
<td></td>
<td></td>
<td><em>ireturn</em></td>
<td><em>lreturn</em></td>
<td><em>freturn</em></td>
<td><em>dreturn</em></td>
<td></td>
<td><em>areturn</em></td>
</tr>
</tbody></table>
<p>Java虚拟机实际类型与Java虚拟机计算类型的对应关系如表所示：</p>
<table>
<thead>
<tr>
<th>Actual type</th>
<th>Computational type</th>
<th>Category</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolean</code></td>
<td><code>int</code></td>
<td>1</td>
</tr>
<tr>
<td><code>byte</code></td>
<td><code>int</code></td>
<td>1</td>
</tr>
<tr>
<td><code>char</code></td>
<td><code>int</code></td>
<td>1</td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>int</code></td>
<td>1</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>int</code></td>
<td>1</td>
</tr>
<tr>
<td><code>float</code></td>
<td><code>float</code></td>
<td>1</td>
</tr>
<tr>
<td><code>reference</code></td>
<td><code>reference</code></td>
<td>1</td>
</tr>
<tr>
<td><code>returnAddress</code></td>
<td><code>returnAddress</code></td>
<td>1</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>long</code></td>
<td>2</td>
</tr>
<tr>
<td><code>double</code></td>
<td><code>double</code></td>
<td>2</td>
</tr>
</tbody></table>
<p>Java里面final关键字通常在以下几种情况下被使用</p>
<ul>
<li>Final Variables</li>
<li>Final Methods</li>
<li>Final Classes</li>
</ul>
<p>在Java里面final常量不能被改变，final类不能被继承，final方法不能被重写。</p>
<h1 id="2-JVM内存模型"><a href="#2-JVM内存模型" class="headerlink" title="2. JVM内存模型"></a>2. JVM内存模型</h1><p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/JVM%20Memory.jpg" alt="JVM Memory"></p>
<h2 id="2-1-局部变量表"><a href="#2-1-局部变量表" class="headerlink" title="2.1 局部变量表"></a>2.1 局部变量表</h2><p>**局部变量表(Local Variable Table)**是一组变量值存储空间，用于存放方法参数和方法内定义的局部变量。局部变量表的容量以变量槽(Variable Slot)为最小单位，Java虚拟机规范并没有定义一个槽所应该占用内存空间的大小，但是规定了一个槽应该可以存放一个32位以内的数据类型。</p>
<blockquote>
<p>在Java程序编译为Class文件时,就在方法的Code属性中的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。(最大Slot数量)</p>
</blockquote>
<p>一个局部变量可以保存一个类型为boolean、byte、char、short、int、float、reference和returnAddress类型的数据。reference类型表示对一个对象实例的引用。returnAddress类型是为jsr、jsr_w和ret指令服务的，目前已经很少使用了。</p>
<p>虚拟机通过索引定位的方法查找相应的局部变量，索引的范围是从0~局部变量表最大容量。如果Slot是32位的，则遇到一个64位数据类型的变量(如long或double型)，则会连续使用两个连续的Slot来存储。</p>
<h2 id="2-2-操作数栈"><a href="#2-2-操作数栈" class="headerlink" title="2.2 操作数栈"></a>2.2 操作数栈</h2><p>**操作数栈(Operand Stack)**也常称为操作栈，它是一个后入先出栈(LIFO)。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到方法的Code属性的max_stacks数据项中。</p>
<p>操作数栈的每一个元素可以是任意Java数据类型，32位的数据类型占一个栈容量，64位的数据类型占2个栈容量,且在方法执行的任意时刻，操作数栈的深度都不会超过max_stacks中设置的最大值。</p>
<p>当一个方法刚刚开始执行时，其操作数栈是空的，随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。一个完整的方法执行期间往往包含多个这样出栈/入栈的过程。</p>
<h2 id="2-3-动态连接"><a href="#2-3-动态连接" class="headerlink" title="2.3 动态连接"></a>2.3 动态连接</h2><p>在一个class文件中，一个方法要调用其他方法，需要将这些方法的符号引用转化为其在内存地址中的直接引用，而符号引用存在于方法区中的运行时常量池。</p>
<p>Java虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的**动态连接(Dynamic Linking)**。</p>
<p>这些符号引用一部分会在类加载阶段或者第一次使用时就直接转化为直接引用，这类转化称为<strong>静态解析</strong>。另一部分将在每次运行期间转化为直接引用，这类转化称为动态连接。</p>
<h2 id="2-4-方法返回"><a href="#2-4-方法返回" class="headerlink" title="2.4 方法返回"></a>2.4 方法返回</h2><p><strong>当一个方法开始执行时，可能有两种方式退出该方法：</strong></p>
<ul>
<li><strong>正常完成出口</strong></li>
<li><strong>异常完成出口</strong></li>
</ul>
<p><strong>正常完成出口</strong>是指方法正常完成并退出，没有抛出任何异常(包括Java虚拟机异常以及执行时通过throw语句显示抛出的异常)。如果当前方法正常完成，则根据当前方法返回的字节码指令，这时有可能会有返回值传递给方法调用者(调用它的方法)，或者无返回值。具体是否有返回值以及返回值的数据类型将根据该方法返回的字节码指令确定。</p>
<p><strong>异常完成出口</strong>是指方法执行过程中遇到异常，并且这个异常在方法体内部没有得到处理，导致方法退出。</p>
<blockquote>
<p>无论是Java虚拟机抛出的异常还是代码中使用athrow指令产生的异常，只要在本方法的异常表中没有搜索到相应的异常处理器，就会导致方法退出。</p>
</blockquote>
<p>无论方法采用何种方式退出，在方法退出后都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在当前栈帧中保存一些信息，用来帮他恢复它的上层方法执行状态。</p>
<blockquote>
<p>方法退出过程实际上就等同于把当前栈帧出栈，因此退出可以执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压如调用者的操作数栈中，调整PC计数器的值以指向方法调用指令后的下一条指令。</p>
</blockquote>
<p>一般来说，方法正常退出时，调用者的PC计数值可以作为返回地址，栈帧中可能保存此计数值。而方法异常退出时，返回地址是通过异常处理器表确定的，栈帧中一般不会保存此部分信息。</p>
<h2 id="2-5-附加信息"><a href="#2-5-附加信息" class="headerlink" title="2.5 附加信息"></a>2.5 附加信息</h2><p>虚拟机规范允许具体的虚拟机实现增加一些规范中没有描述的信息到栈帧之中，例如和调试相关的信息，这部分信息完全取决于不同的虚拟机实现。在实际开发中，一般会把动态连接，方法返回地址与其他附加信息一起归为一类，称为栈帧信息。</p>
<h2 id="2-6-方法区"><a href="#2-6-方法区" class="headerlink" title="2.6 方法区"></a>2.6 方法区</h2><ul>
<li>全局字符串池（string pool也有叫做string literal pool）</li>
<li>class文件常量池（class constant pool）</li>
<li>运行时常量池（runtime constant pool）</li>
</ul>
<p><strong>物理存储位置变更</strong>：</p>
<ul>
<li>在<strong>JDK1.7之前</strong>运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代。</li>
<li>在<strong>JDK1.7</strong> 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代。</li>
<li>在<strong>JDK1.8</strong> hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace) 。</li>
</ul>
<h1 id="3-可能与并发相关的点"><a href="#3-可能与并发相关的点" class="headerlink" title="3. 可能与并发相关的点"></a>3. 可能与并发相关的点</h1><h2 id="3-1-对象创建过程-new指令"><a href="#3-1-对象创建过程-new指令" class="headerlink" title="3.1 对象创建过程 new指令"></a>3.1 对象创建过程 new指令</h2><ol>
<li><p>当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
</li>
<li><p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。  </p>
<blockquote>
<p>【此处涉及-XX +/- UseTLAB】</p>
</blockquote>
</li>
<li><p>内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。</p>
</li>
<li><p>接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用Object::hashCode()方法时才计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。  </p>
<blockquote>
<p>【此处涉及是否启用偏向锁】</p>
</blockquote>
</li>
<li><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从Java程序的视角看来，对象创建才刚刚开始——构造函数，即Class文件中的<init>()方法还没有执行，所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。new指令之后会接着执行<init>()方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。</p>
</li>
</ol>
<blockquote>
<p>此过程描述见《深入理解Java虚拟机 第三版》2.3.1。</p>
</blockquote>
<h2 id="3-2-对象内存布局"><a href="#3-2-对象内存布局" class="headerlink" title="3.2  对象内存布局"></a>3.2  对象内存布局</h2><ul>
<li>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</li>
<li>HotSpot虚拟机对象的对象头部分包括两类信息。第一类是用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特，官方称它为“Mark Word”。</li>
<li>接下来实例数据部分是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。这部分的存储顺序会受到虚拟机分配策略参数（-XX：FieldsAllocationStyle参数）和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers，OOPs），从以上默认的分配策略中可以看到，相同宽度的字段总是被分配到一起存放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果HotSpot虚拟机的+XX：CompactFields参数值为true（默认就为true），那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。</li>
</ul>
<blockquote>
<p>涉及-XX：FieldsAllocationStyle 和 +XX：CompactFields</p>
</blockquote>
<ul>
<li>对象的第三部分是对齐填充，由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数（1倍或者2倍），因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</li>
</ul>
<p>HotSpot虚拟机对象头Mark Word</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/%E6%88%AA%E5%B1%8F%202021-10-12%20%E4%B8%8B%E5%8D%882.30.21.png" alt="截屏 2021-10-12 下午2.30.21"></p>
<ul>
<li>此外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。</li>
</ul>
<h1 id="4-JVM工具-与-调优"><a href="#4-JVM工具-与-调优" class="headerlink" title="4. JVM工具 与 调优"></a>4. JVM工具 与 调优</h1><h2 id="4-1-JVM-异常"><a href="#4-1-JVM-异常" class="headerlink" title="4.1 JVM 异常"></a>4.1 JVM 异常</h2><p>JVM只会抛出两种异常：OutOfMemoryError、StackOverflowError。</p>
<ul>
<li><p>程序计数器：不会产生异常。</p>
</li>
<li><p><strong>方法区</strong></p>
<ul>
<li><p>OutOfMemoryError</p>
<blockquote>
<p>Y：可能常出现的是字符串常量池发生OutOfMemoryError，如大量使用String.intern方法向字符串常量池添加字符串。</p>
<p>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，若加载大量类型，而无法下载的情况下也会内存溢出。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>堆</strong></p>
<ul>
<li><p>OutOfMemoryError</p>
<blockquote>
<p><strong>java.lang.OutOfMemoryError: Java heap space</strong></p>
<p>-Xms 和 -Xmx 设置堆大小限制。</p>
<p>-XX:+HeapDumpOnOutOfMemoryError  让虚拟机在发生内存溢出时Dump出当前的内存堆转储快照以便进行事后分析。</p>
<p>测试：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/image-20211012153546322.png" alt="image-20211012153546322"></p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/image-20211012153650569.png" alt="image-20211012153650569"></p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/image-20211012153730127.png" alt="image-20211012153730127"></p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>虚拟机栈和本地方法栈</strong></p>
<blockquote>
<ul>
<li>Hotspot中共用虚拟机栈和本地方法栈</li>
<li>Hotspot中不支持栈的动态扩展</li>
</ul>
</blockquote>
<ul>
<li><p>OutOfMemoryError：只可能是在<strong>创建线程</strong>申请内存时无法获得足够内存而出现OutOfMemoryError。</p>
<blockquote>
<p>通过工具分析堆转储文件：</p>
<ol>
<li>首先确认是出现了内存溢出（Memory Overflow）还是内存泄漏（Memory Leak）。</li>
<li>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链，找到泄漏对象是通过怎样的引用路径、与哪些GC Roots相关联，才导致垃圾收集器无法回收它们，根据泄漏对象的类型信息以及它到GC Roots引用链的信息，一般可以比较准确地定位到这些对象创建的位置，进而找出产生内存泄漏的代码的具体位置。</li>
</ol>
</blockquote>
</li>
<li><p>StackOverflowError：栈容量不足以容纳新的栈帧。</p>
<blockquote>
<p>-Xss 参数设定栈容量。</p>
<p>Y：很可能是方法调用链过深，如递归程序层次过深或未定义终止条件等。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>本机直接内存</strong></p>
<ul>
<li><p>OurOfMemoryError</p>
<blockquote>
<p>java.lang.OutOfMemoryError</p>
<pre><code>at sun.misc.Unsafe.allocateMemory(Native Method)
</code></pre>
<p>-XX：MaxDirectMemorySize  直接内存的容量大小可通过该参数来指定，如果不去指定，则默认与Java堆最大值（由-Xmx指定）一致。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="4-2-工具"><a href="#4-2-工具" class="headerlink" title="4.2 工具"></a>4.2 工具</h2><h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>生成指定进程当前的内存堆转储文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:file=javaDump.hprof,format=b pid</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如下，其中3614为进程ID</span></span><br><span class="line">jmap -dump:file=./javaDump.hprof,format=b 3614</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Y：配合-XX:+HeapDumpOnOutOfMemoryError使用，-XX:+HeapDumpOnOutOfMemoryError在系统发生内存溢出时自动生成堆转储文件，jmap可在平时生成以时常观察有没有隐患。</p>
</blockquote>
<p>命令详情jmap -h 或者参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/sxdcgaq8080/p/11089664.html">https://www.cnblogs.com/sxdcgaq8080/p/11089664.html</a></p>
<h3 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3><p>分析内存堆转储文件，提供一个本地服务，可通过浏览器查看。</p>
<blockquote>
<p>Y：基本不会使用。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如下，通过http://localhost:7000查看分析结果。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> jhat java_pid97001.hprof</span></span><br><span class="line">Reading from java_pid97001.hprof...</span><br><span class="line">Dump file created Tue Oct 12 15:22:00 CST 2021</span><br><span class="line">Snapshot read, resolving...</span><br><span class="line">Resolving 818254 objects...</span><br><span class="line">WARNING:  Failed to resolve object id 0x7bf3aab60 for field type (signature L)</span><br><span class="line">Chasing references, expect 163 dots...................................................................................................................................................................</span><br><span class="line">Eliminating duplicate references...................................................................................................................................................................</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port 7000</span><br><span class="line">Server is ready.</span><br></pre></td></tr></table></figure>

<blockquote>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/image-20211012155934401.png" alt="image-20211012155934401"></p>
<p>点击Show heap histogram</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/image-20211012160026138.png" alt="image-20211012160026138"></p>
<p>Y：也可使用JProfiler等工具打开堆转储文件，进行查看。</p>
</blockquote>
<h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhaozheng7758/article/details/8623549">https://blog.csdn.net/zhaozheng7758/article/details/8623549</a></p>
<h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8d5782bc596e">https://www.jianshu.com/p/8d5782bc596e</a></p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/kongzhongqijing/articles/3630264.html">https://www.cnblogs.com/kongzhongqijing/articles/3630264.html</a></p>
<h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p>jinfo 是 JDK 自带的命令，可以用来查看正在运行的 java 应用程序的扩展参数，包括Java System属性和JVM命令行参数；也可以动态的修改正在运行的 JVM 一些参数。当系统崩溃时，jinfo可以从core文件里面知道崩溃的Java应用程序的配置信息。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8d8aef212b25">https://www.jianshu.com/p/8d8aef212b25</a></p>
<h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>jps是查看java进程信息的命令。</p>
<p>格式  jps [ options ] [ hostid ]<br>参数说明<br>     options<br>          -q   只输出java进程的进程id<br>          -l    输出java进程的进程id和main方法的类全名<br>          -m  输出java进程的进程id和main方法的入参<br>          -v   输出java进程的进程id和jvm的入参<br>          -V   输出java进程的进程id和通过flag文件传入jvm的参数<br>     hostid<br>          命令对应的服务器ip，默认不加参数，代码查看本机</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 用来查看Java进程，及其jvm入参，比如查看IDEA、Hive等应用进程的jvm设置。</span></span><br><span class="line">jps -v</span><br></pre></td></tr></table></figure>

<h3 id="JProfiler"><a href="#JProfiler" class="headerlink" title="JProfiler"></a>JProfiler</h3><h3 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h3><h2 id="4-3-垃圾收集器与内存分配策略"><a href="#4-3-垃圾收集器与内存分配策略" class="headerlink" title="4.3 垃圾收集器与内存分配策略"></a>4.3 垃圾收集器与内存分配策略</h2><p><strong>回收区域</strong>：堆、方法区。</p>
<h3 id="4-3-1-堆的回收"><a href="#4-3-1-堆的回收" class="headerlink" title="4.3.1 堆的回收"></a>4.3.1 堆的回收</h3><p><strong>判断对象是否需要回收</strong></p>
<ul>
<li><p>引用计数算法  -&gt;  存在对象循环引用问题</p>
</li>
<li><p>可达性分析算法  -&gt; JVM 采用该算法</p>
<ul>
<li><p>起始节点集：<font color="FF0000">GC Roots</font></p>
<ol>
<li><p>在<strong>虚拟机栈</strong>（栈帧中的<strong>本地变量表</strong>）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</p>
</li>
<li><p>在<strong>方法区</strong>中<strong>类静态属性</strong>引用的对象，譬如Java类的<strong>引用类型静态变量</strong>。</p>
</li>
<li><p>在<strong>方法区</strong>中<strong>常量引用</strong>的对象，譬如字符串常量池（String Table）里的引用。</p>
</li>
<li><p>在<strong>本地方法栈</strong>中JNI（即通常所说的<strong>Native方法</strong>）引用的对象。</p>
<blockquote>
<p>Y：如在调用Unsafe.compareAndSwapInt方法时传入的参数。</p>
</blockquote>
</li>
<li><p><strong>Java虚拟机内部的引用</strong>，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。</p>
</li>
<li><p>所有被<strong>同步锁（synchronized关键字）持有的对象</strong>。</p>
</li>
<li><p>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</p>
</li>
<li><p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。</p>
<blockquote>
<p>Y：比如基于分代收集的垃圾收集器在mirror GC时，RemberSet中的老年代对象也会算作GC Roots。</p>
</blockquote>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><strong>分代收集理论</strong></p>
<ul>
<li>基于三条经验假说：弱分代假说、强分代假说、跨代引用假说<ol>
<li>弱分代假说：绝大多数对象都是朝生夕灭的。 </li>
<li>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。</li>
<li>跨代引用假说：跨代引用相对于同代引用来说仅占极少数。</li>
</ol>
</li>
</ul>
<p><strong>垃圾收集算法</strong></p>
<ul>
<li><p>标记清除</p>
</li>
<li><p>标记复制</p>
<blockquote>
<p>新生代采用的Appel式回收采用的该方法。（通常Eden：Survivor1：Survivor=8:1:1，老年代进行分配担保。）</p>
</blockquote>
</li>
<li><p>标记整理</p>
</li>
</ul>
<p><strong>对象进入老年代的情况</strong></p>
<ul>
<li><p>新生代回收率不足90%，当Survivor空间满了以后，剩余存活对象进入老年代。【老年代对新生代的分配担保】</p>
</li>
<li><p>大对象直接进入老年代</p>
<ul>
<li><p>G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。-XX:G1HeapRegionSize可设置Region大小。</p>
</li>
<li><p>对于Serial和ParNew，-XX:PretenureSizeThreshold设置大对象的阈值。</p>
<blockquote>
<p>Y：在jdk文档中没有找到该参数。<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BGBCIEFC">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BGBCIEFC</a></p>
</blockquote>
</li>
</ul>
</li>
<li><p>长期存活的对象进入老年代</p>
<ul>
<li><p>新生代的对象熬过一次minor GC，年龄加1（对象头中记录年龄），增加到一定程度，进入老年代。</p>
<blockquote>
<p>-XX:MaxTenuringThreshold 来设定年龄阈值。并行(吞吐量)收集器的默认值是15,CMS收集器的默认值是6。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到-XX：MaxTenuringThreshold中要求的年龄。【动态年龄判定】</p>
</li>
</ul>
<p><strong>HotSpot的算法实现细节</strong></p>
<ul>
<li><p>OopMap -&gt; 解决根节点枚举 “Stop The World”的问题</p>
</li>
<li><p>安全点 -&gt; 解决OopMap更新频率与时机的问题（解决如何停顿用户线程让虚拟机进入垃圾回收状态的问题）</p>
</li>
<li><p>安全区域 -&gt; 对安全点机制的补充</p>
</li>
<li><p>记忆集与卡表 -&gt; 解决对象跨代引用或者跨区域引用（对于跨区域收集的GC行为）的问题</p>
</li>
<li><p>写屏障 -&gt; 解决卡表元素如何维护的问题</p>
<blockquote>
<p>卡表在高并发场景下还面临着“伪共享”（False Sharing）问题。</p>
<p>XX：+UseCondCardMark，用来决定是否开启卡表更新的条件判断。开启会增加一次额外判断的开销，但能够避免伪共享问题，</p>
</blockquote>
</li>
<li><p>三色标记 &amp;&amp; ( 增量更新 || 原始快照 ) -&gt; 并发的可达性分析</p>
<ul>
<li>CMS 增量更新</li>
<li>G1 原始快照</li>
</ul>
</li>
</ul>
<p><strong>HotSpot 的经典垃圾收集器</strong></p>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/%E6%88%AA%E5%B1%8F%202021-10-12%20%E4%B8%8B%E5%8D%885.54.50.png" alt="截屏 2021-10-12 下午5.54.50" style="zoom: 25%;" />

<ul>
<li><p>ParNew/CMS/Serial Old【JDK8默认的组合方式】</p>
<blockquote>
<p>-XX:+UseConcMarkSweepGC，启用CMS之后新生代默认使用ParNew。</p>
<p>-XX:SurvivorRatio</p>
</blockquote>
<p>CMS：</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/%E6%88%AA%E5%B1%8F%202021-10-12%20%E4%B8%8B%E5%8D%888.03.22.png" alt="截屏 2021-10-12 下午8.03.22"></p>
<p>优点：并发收集、低停顿</p>
<p>缺点：</p>
<ul>
<li>处理器资源敏感；</li>
<li>无法处理“浮动垃圾”，有可能出现“Concurrent Mode Failure”失败进而导致另一次完全“Stop The World” 的Full GC</li>
</ul>
<blockquote>
<p>-XX:CMSInitiatingOccupancyFraction，默认值-1，即无效值，则使用-XX:CMSTriggerRatio的值。</p>
<p>-XX:CMSTriggerRatio 默认值80%</p>
</blockquote>
</li>
<li><p>G1【JDK9到目前的JDK17的默认GC】</p>
<blockquote>
<p>-XX:G1HeapRegionSize -&gt; 设置Region容量大小，该值是2的幂，范围从1mb到32mb。默认的区域大小是根据堆大小决定的，目标大约是2048个区域。</p>
<p>-XX:MaxGCPauseMillis -&gt; 设置最大G1收集器GC暂停时间的目标(以毫秒为单位)。默认200ms，</p>
</blockquote>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/%E6%88%AA%E5%B1%8F%202021-10-12%20%E4%B8%8B%E5%8D%888.43.09.png" alt="截屏 2021-10-12 下午8.43.09" style="zoom:25%;" />

<img src="https://gitee.com/qmlg/image-bed/raw/master/images/%E6%88%AA%E5%B1%8F%202021-10-12%20%E4%B8%8B%E5%8D%888.42.12.png" alt="截屏 2021-10-12 下午8.42.12" style="zoom: 25%;" />

<ul>
<li><p>Region中还有一类特殊的<strong>Humongous区域，专门用来存储大对象</strong>。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数-XX：G1HeapRegionSize设定，取值范围为1MB～32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把<strong>Humongous Region作为老年代的一部分来进行看待</strong>。</p>
</li>
<li><p>G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程的，换言之，它并非纯粹地追求低延迟，官方给它设定的目标是<strong>在延迟可控的情况下获得尽可能高的吞吐量</strong>，所以才能担当起“全功能收集器”的重任与期望。</p>
</li>
<li><p>通常把期望停顿时间设置为一两百毫秒或者两三百毫秒会是比较合理的。</p>
</li>
<li><p>如果内存回收的速度赶不上内存分配的速度，G1收集器也要被迫冻结用户线程执行，导致<strong>Full GC</strong>而产生长时间“Stop The World”。</p>
</li>
<li><p>G1从<strong>整体</strong>来看是基于“<strong>标记-整理</strong>”算法实现的收集器，但从<strong>局部</strong>（两个Region之间）上看又是基于“<strong>标记-复制</strong>”算法实现，无论如何，这两种算法都意味着G1运作期间<strong>不会产生内存空间碎片</strong>。</p>
</li>
<li><p>按照《深入理解JVM》作者的实践经验，目前在<strong>小内存应用</strong>上<strong>CMS</strong>的表现大概率仍然要会优于G1，而在<strong>大内存</strong>应用上<strong>G1</strong>则大多能发挥其优势，这个优劣势的<strong>Java堆容量平衡点</strong>通常在<strong>6GB至8GB</strong>之间。</p>
<blockquote>
<p>Y：若堆为8G，则默认Region的大小约为4M。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>ZGC</p>
<ul>
<li><p>我们可以给ZGC下一个这样的定义来概括它的主要特征：ZGC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可<strong>并发的标记-整理</strong>算法的，<strong>以低延迟为首要目标</strong>的一款垃圾收集器。</p>
</li>
<li><p>将会成为服务端、大内存、低延迟应用的首选收集器的有力竞争者。</p>
<blockquote>
<p>Y：可见内存要求也比较高。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="4-3-2-方法区的回收"><a href="#4-3-2-方法区的回收" class="headerlink" title="4.3.2 方法区的回收"></a>4.3.2 方法区的回收</h3><p>方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。</p>
<blockquote>
<p>Y：判断类型不再需要的条件苛刻，包括三个方面，实例、加载它的类加载器已被回收，Class对象不再被引用。</p>
</blockquote>
<p>关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose：class以及-XX：+TraceClass-Loading、-XX：+TraceClassUnLoading查看类加载和卸载信息，其中-verbose：class和-XX：+TraceClassLoading可以在Product版的虚拟机中使用，-XX：+TraceClassUnLoading参数需要FastDebug版[1]的虚拟机支持。</p>
<p>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p>
<h2 id="4-4-调优"><a href="#4-4-调优" class="headerlink" title="4.4 调优"></a>4.4 调优</h2><p>一般的项目应该都是不需要调优的：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/362201242">https://www.zhihu.com/question/362201242</a></p>
<ul>
<li><p>-Xms &amp; -Xmx 最大堆 最小堆</p>
</li>
<li><p>GC算法：jdk8默认CMS，jdk9到目前的jdk17默认G1</p>
</li>
<li><p>-Xmn</p>
<p>为分代收集器中的年轻代设置堆的初始大小和最大大小(以字节为单位)。堆的年轻代区域用于新对象。与其他区域相比，该区域执行GC的频率更高。如果年轻代的大小太小，那么将执行大量minor GC。如果大小太大，则只执行full GC，这可能需要很长时间才能完成。建议您不要为G1收集器设置年轻代的大小，并且对于其它收集器保持年轻代的大小大于总体堆大小的25%而小于50%。</p>
</li>
<li><p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/image-20211012212915394.png" alt="image-20211012212915394"></p>
</li>
</ul>
<hr>
<blockquote>
<p>内容来源：</p>
<ul>
<li>《深入理解Java虚拟机》</li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se16/html/index.html">The Java® Virtual Machine Specification-<em>Java SE 16 Edition</em></a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/45354152">Java虚拟机—栈帧、操作数栈和局部变量表</a></li>
<li><a target="_blank" rel="noopener" href="http://tangxman.github.io/2015/07/27/the-difference-of-java-string-pool/">Java中几种常量池的区分</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/q5706503/article/details/84640762">JDK1.8关于运行时常量池, 字符串常量池的要点</a></li>
</ul>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.coder.love/2021/09/03/Design-Patterns/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="青马流光">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="青马流光的博客">
      <meta itemprop="description" content="学习笔记">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 青马流光的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/03/Design-Patterns/" class="post-title-link" itemprop="url">Design Patterns</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-03 20:08:41" itemprop="dateCreated datePublished" datetime="2021-09-03T20:08:41+08:00">2021-09-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-21 13:19:24" itemprop="dateModified" datetime="2022-03-21T13:19:24+08:00">2022-03-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-设计模式六大原则"><a href="#1-设计模式六大原则" class="headerlink" title="1. 设计模式六大原则"></a>1. 设计模式六大原则</h1><p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/design_pattern_principle.png" alt="img"></p>
<p>1.1 单一职责原则</p>
<p>There should never be more than one reason for a class to change.</p>
<p>理解：不同的类具备不同的职责，各司其职。做系统设计是，如果发现有一个类拥有了两种职责，那么就要问一个问题：可以将这个类分成两个类吗？如果真的有必要，那就分开，千万不要让一个类干的事情太多。</p>
<p>总结：一个类只承担一个职责</p>
<p>1.2 开放封闭原则</p>
<p>Software entities like classes,modules and functions should be open for extension but closed for modifications.</p>
<p>理解：类、模块、函数，可以去扩展，但不要去修改。如果要修改代码，尽量用继承或组合的方式来扩展类的功能，而不是直接修改类的代码。当然，如果能保证对整个架构不会产生任何影响，那就没必要搞的那么复杂，直接改这个类吧。</p>
<p>总结：对软件实体的改动，最好用扩展而非修改的方式。</p>
<p>1.3 里式替换原则</p>
<p>Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.</p>
<p>理解：父类可被子类替换，但反之不一定成立。也就是说，代码中可以将父类全部替换为子类，程序不会出现异常，但反过来就不一定了。</p>
<p>总结：在继承类是，务必重写（override）父类中所有的方法，尤其需要注意父类的protected方法（它们往往是让你重写的），子类尽量不要暴露自己的public方法供外界调用。</p>
<p>1.4 最少知识原则</p>
<p>Only talk to you immediate friends.</p>
<p>理解：尽量减少对象之间的交互，从而减小类之间的耦合。在做系统设计时，不要让一个类依赖于太多其他的类，需尽量减小依赖关系，否则死都不知道怎么死的。</p>
<p>总结：一定要做到：低耦合、高内聚。</p>
<p>1.5 接口隔离原则</p>
<p>The dependency of one class to another one should depend on the smallest possible interface.</p>
<p>理解：不要对外暴露没有实际意义的接口。也就是说，尽量保证接口的实用性。当需要对外暴露接口时，需要再三斟酌，若没必要对外提供就删了吧，因为一旦提供了就意味着，将来要多做一件事情，何苦给自己找事做呢。</p>
<p>总结：不要对外暴露没有实际意义的接口。</p>
<p>1.6 依赖倒置原则</p>
<p>High level modules should not depends upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions.</p>
<p>理解：高层模块不应该依赖于底层模块，而应该依赖于抽象。抽象不应依赖于细节，细节应依赖于抽象。应该面向接口编程，不该面向实现类编程。面向实现类编程相当于就事论事，那是正向依赖；面向接口编程，相当于透过现象看本质，抓住事务的共性，那就是反向依赖，即依赖倒置。</p>
<p>总结：面向接口编程，提取出事务的本质和共性。</p>
<p>1.7 合成复用原则</p>
<p>合成复用原则（Composite Reuse Principle，CRP）又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP）。它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p>
<h1 id="2-分类"><a href="#2-分类" class="headerlink" title="2. 分类"></a>2. 分类</h1><ul>
<li><p><strong>创建型</strong></p>
<p>创建型模式抽象了实例化过程。它们帮助一个系统独立于如何创建、组合和表示它的那些对象。</p>
<p>一个类创建型模式使用继承改变被实例化的类；而一个对象创建型模式将实例化委托给另一个对象。</p>
</li>
<li><p><strong>结构型</strong></p>
<p>结构型模式涉及如何组合类和对象以获得更大的结构。</p>
<p>结构型类模式采用继承机制来组合接口或实现。</p>
<p>结构型对象模式不是对接口和实现进行组合，而是描述了如何对一些对象进行组合，从而实现新功能的一些方法。因为可以在运行时改变对象组合关系，所以对象组合方式具有更大的灵活性，而这种机制用静态类组合是不可能实现的。</p>
</li>
<li><p><strong>行为型</strong></p>
<p>行为型模式涉及算法和对象间职责的分配。行为型模式不仅描述对象或类的模式，还描述它们之间的通信模式。这些模式刻画了在运行时难以跟踪的复杂的控制流。它们将你的注意力从控制流转移到对象间的联系方式上来。</p>
<p>类行为型模式使用继承机制在类间分派行为。</p>
<p>对象行为型模式使用对象组合而不是继承。</p>
</li>
</ul>
<p><strong>三者之间的联系：</strong></p>
<ol>
<li>创建型模式为其他两种模式使用提供了环境，好比VS软件提供了.net环境和操作平台，是各种编程语言能随心所欲地在这个平台上编译执行；</li>
<li>结构型模式侧重于接口的使用，它做的一切工作都是对象或是类之间的交互，提供一个门，成就一个你来我往，协同合作的地球村；</li>
<li>行为型模式顾名思义，侧重于具体行为，所以概念中才会出现职责分配和算法通信等内容。</li>
</ol>
<p>将三者结合起来成为故事，中美合作的故事——创建型模式提供国际环境，无战争，求发展；结构型模式为中美合作提供理由，即和平时代的互利共赢，行为型模式就具体到两个大国之间是如何合作，比如经济合作、文化合作等。</p>
<ul>
<li><p>创建型（5种）</p>
<ul>
<li>Factory Method（工厂方法）</li>
<li>Abstract Factory（抽象工厂）</li>
<li>Builder（生成器）</li>
<li>Prototype（原型）</li>
<li>Singleton（单例）</li>
</ul>
</li>
<li><p>结构型（7种）</p>
<ul>
<li>Adapter Class/Object（适配器）</li>
<li>Bridge（桥接）</li>
<li>Composite（组合）</li>
<li>Decorator（装饰）</li>
<li>Facade（外观）</li>
<li>Flyweight（享元）</li>
<li>Proxy（代理）</li>
</ul>
</li>
<li><p>行为型（11种）</p>
<ul>
<li>Interpreter（解释器）</li>
<li>Template Method（模板方法）</li>
<li>Chain of Responsibility（责任链）</li>
<li>Command（命令）</li>
<li>Iterator（迭代器）</li>
<li>Mediator（中介者）</li>
<li>Memento（备忘录）</li>
<li>Observer（观察者）</li>
<li>State（状态）</li>
<li>Strategy（策略）</li>
<li>Visitor（访问者）</li>
</ul>
</li>
</ul>
<h2 id="2-2-GOF-结构图"><a href="#2-2-GOF-结构图" class="headerlink" title="2.2 GOF 结构图"></a>2.2 GOF 结构图</h2><h3 id="2-2-1-创建型（5种）"><a href="#2-2-1-创建型（5种）" class="headerlink" title="2.2.1 创建型（5种）"></a>2.2.1 创建型（5种）</h3><ul>
<li><p>Factory Method（工厂方法）</p>
<blockquote>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/Factory%20Method%20%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Factory Method 模式结构图" style="zoom: 50%;" /></blockquote>
</li>
<li><p>Abstract Factory（抽象工厂）</p>
<blockquote>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/Abstract%20Factory%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Abstract Factory模式结构图" style="zoom:50%;" /></blockquote>
</li>
<li><p>Builder（生成器）</p>
<blockquote>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/Builder%20%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Builder 模式结构图" style="zoom:50%;" /></blockquote>
</li>
<li><p>Prototype（原型）</p>
<blockquote>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/Prototype%20%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Prototype 模式结构图" style="zoom: 50%;" /></blockquote>
</li>
<li><p> Singleton（单例）</p>
</li>
</ul>
<blockquote>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/Singleton%20%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Singleton 模式结构图" style="zoom: 50%;" />
</blockquote>
<h3 id="2-2-2-结构型（7种）"><a href="#2-2-2-结构型（7种）" class="headerlink" title="2.2.2 结构型（7种）"></a>2.2.2 结构型（7种）</h3><ul>
<li><p>Adapter Class/Object（适配器）</p>
<blockquote>
<p>类适配器使用多重继承对一个接口与另一个接口进行匹配：</p>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/Adaptor%20%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Adaptor 模式结构图" style="zoom:50%;" />

<p>对象匹配器依赖于对象组合：</p>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/Adaptor%20%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Adaptor 对象适配器模式结构图" style="zoom:50%;" /></blockquote>
</li>
<li><p>Bridge（桥接）</p>
<blockquote>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/Bridge%20%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Bridge 模式结构图" style="zoom:50%;" /></blockquote>
</li>
<li><p>Composite（组合）</p>
<blockquote>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/Composite%20%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Composite 模式结构图" style="zoom:50%;" />

<p>典型的Composite对象结构图如下：</p>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/%E5%85%B8%E5%9E%8B%20Composite%20%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="典型 Composite 对象结构图" style="zoom: 33%;" /></blockquote>
</li>
<li><p>Decorator（装饰）</p>
<blockquote>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/Decorator%20%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Decorator 模式结构图" style="zoom:50%;" /></blockquote>
</li>
<li><p>Facade（外观）</p>
<blockquote>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/Facade%20%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Facade 模式结构图" style="zoom: 50%;" /></blockquote>
</li>
<li><p>Flyweight（享元）</p>
<blockquote>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/Flyweight%20%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Flyweight 模式结构图" style="zoom:50%;" />

<p>下面的对象图说明了如何共享flyweight：</p>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/%E5%85%B1%E4%BA%ABflyweight%20%E5%AF%B9%E8%B1%A1%E5%9B%BE.png" alt="共享flyweight 对象图" style="zoom:50%;" /></blockquote>
</li>
<li><p>Proxy（代理）</p>
<blockquote>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/Proxy%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Proxy模式结构图" style="zoom:50%;" />

<p>Y：这种应该是基于接口的代理；还可以基于继承实现。</p>
</blockquote>
</li>
</ul>
<h3 id="2-2-3-行为型（11种）"><a href="#2-2-3-行为型（11种）" class="headerlink" title="2.2.3 行为型（11种）"></a>2.2.3 行为型（11种）</h3><ul>
<li><p>Interpreter（解释器）</p>
<blockquote>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/Interpreter%20%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Interpreter 模式结构图" style="zoom: 50%;" /></blockquote>
</li>
<li><p>Template Method（模板方法）</p>
<blockquote>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/Template%20Method%20%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Template Method 模式结构图" style="zoom: 50%;" /></blockquote>
</li>
<li><p>Chain of Responsibility（责任链）</p>
<blockquote>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/Chain%20of%20Responsibility%20%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Chain of Responsibility 模式结构图" style="zoom:50%;" /></blockquote>
</li>
<li><p>Command（命令）</p>
<blockquote>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/Command%20%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Command 模式结构图" style="zoom:50%;" /></blockquote>
</li>
<li><p>Iterator（迭代器）</p>
<blockquote>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/Iterator%20%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Iterator 模式结构图" style="zoom:50%;" /></blockquote>
</li>
<li><p>Mediator（中介者）</p>
<blockquote>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/Mediator%20%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Mediator 模式结构图" style="zoom:50%;" />

<p>典型对象结构：</p>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/Mediator%20%E5%85%B8%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84.png" alt="Mediator 典型对象结构" style="zoom: 50%;" /></blockquote>
</li>
<li><p>Memento（备忘录）</p>
<blockquote>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/Memento%20%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F%E5%9B%BE.png" alt="Memento 结构模式图" style="zoom:50%;" /></blockquote>
</li>
<li><p>Observer（观察者）</p>
<blockquote>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/Observer%20%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Observer 模式结构图" style="zoom:50%;" /></blockquote>
</li>
<li><p>State（状态）</p>
<blockquote>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/State%20%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="State 模式结构图" style="zoom: 50%;" /></blockquote>
</li>
<li><p>Strategy（策略）</p>
<blockquote>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/Strategy%20%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Strategy 模式结构图" style="zoom:50%;" /></blockquote>
</li>
<li><p>Visitor（访问者）</p>
<blockquote>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/Visitor%20%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="Visitor 模式结构图"/></blockquote>
</li>
</ul>
<h2 id="2-3-Some-Think"><a href="#2-3-Some-Think" class="headerlink" title="2.3 Some Think"></a>2.3 Some Think</h2><blockquote>
<p>Y：</p>
<p>创建型：</p>
<ul>
<li><p>单例侧重于共享行为；</p>
</li>
<li><p>原型模式侧重以内存复制的方式替代对象创建过程，提高效率；</p>
</li>
<li><p>生成器模式侧重对一个复杂的包含多个组成部分或环节的创建过程进行定制化拼装；</p>
</li>
<li><p>工厂方法模式侧重封装对象的实例化过程和屏蔽实例化的子类；</p>
</li>
<li><p>抽象工厂侧重一系列对象的整体变更，如产品线或主题变更。</p>
</li>
</ul>
<p>结构型：</p>
<p>行为型：</p>
</blockquote>
<p><strong>AbstractFactory</strong></p>
<blockquote>
<p>Y：强调灵活变更一系列产品的创建，即灵活而统一的变更一条产品线。在Spring中通过@Configuration和@Condition注解来实现的产品线切换（如AspectJ代理、webFlux方式等）是否可以看作AbstractFactory的一种实现形式  </p>
<p>GOF：一个具体的工厂通常是一个Singleton。</p>
</blockquote>
<p><strong>FactoryMethod</strong></p>
<blockquote>
<p>Y：Creator 的抽象意在支持同一产品的多种创建方式的灵活替换；ConcreateCreator来表示该产品具体的某种创建方式，如通过某个Prototype实例的复制，或者通过Redis数据反序列化而来等。</p>
</blockquote>
<p><strong>Builder（生成器）</strong></p>
<blockquote>
<p>Y：Builder提供复杂对象X各组成部分的创建接口，其子类负责X各组成部分的具体创建的实现。Director即使用方，基于Builder提供的X各组成部分的创建接口灵活拼装X的组成部分及顺序。</p>
<p>Y：若把该复杂产品看作同一系列产品，那么Builder及其实现与AbstractFactory模式中的AbstractFactory及其实现相似。而X每个部分的创建也都是基于FactoryMethod。</p>
<p>GOF：Builder在最后一步返回产品，而对于Abstract Factory来说，产品是立即返回的。</p>
</blockquote>
<p><strong>Singleton</strong></p>
<p><strong>Prototype</strong></p>
<blockquote>
<p>Y：注意是通过原型实例拷贝自身来创建新的对象。所以说原型实例是Singleton。多个原型实例可作为一个对象组，替代Abstract Factory完成一系列产品的创建。</p>
</blockquote>
<blockquote>
<p>Y：引申深拷贝、浅拷贝？</p>
<ul>
<li>浅拷贝：仅对象本身及其值类型的成员，引用类型的成员拷贝的地址，指向原成员实例。</li>
<li>深拷贝：对向本身及其所有成员全部拷贝，成员也是深拷贝。引用型成员指向新拷贝的实例。</li>
</ul>
<p>通过实现Cloneable接口，调用super.clone()方法实现某对象的拷贝。最终调用的Object的clone()方法，native方法。</p>
</blockquote>
<p><strong>创建型模式讨论</strong></p>
<blockquote>
<p>GOF：通常设计以使用Factory Method开始，并且当设计者发现需要更大的灵活性时，设计便会向其它创建型模式演化。</p>
</blockquote>
<p><strong>Adapter</strong></p>
<blockquote>
<p>又名包装器（Wrapper）。通过包装，使一个原本不兼容的接口可以一同工作。</p>
<p>Y：类似转接头？强调利用已有接口或对象。</p>
</blockquote>
<p><strong>Bridge</strong></p>
<blockquote>
<p>又名Handle/Body。</p>
<p>Y：分离接口与实现部分。通过对底层差异化实现的封装，对外提供统一而易于使用的接口。就好像Java native方法屏蔽了平台的差异，对外提供了统一的接口。</p>
</blockquote>
<p><strong>Composite</strong></p>
<blockquote>
<p>Y：从clone方法角度看，Cloneable接口即可看作Component，它的实现类则可能为Leaf或Composite。TreeNode也应该算是。</p>
<p>GOF：几乎在所有面向对象系统中都有Composite模式的应用实例。</p>
</blockquote>
<p><strong>Decorator</strong></p>
<blockquote>
<p>又名包装器（wrapper）。</p>
<p>Y：通过包装，添加功能而不改变接口。</p>
<p>GOF：</p>
<ul>
<li>Composite（4.3）：可以将装饰视为一个退化的、仅有一个组件的组合。然而，装饰仅给对象添加一些额外的职责——它的目的不在于对象聚集。</li>
</ul>
</blockquote>
<p><strong>Facade</strong>   [fəˈsɑːd]</p>
<blockquote>
<p>Y：Gateway 接口路由应该是吧？可能不是，但算不算是中介者模式呢？</p>
</blockquote>
<p><strong>Flyweight</strong></p>
<blockquote>
<p>Y：注意内部状态、外部状态的概念。UnsharedConcreateFlyweight对象由Client创建。</p>
<p>GOF：</p>
<ul>
<li> Flyweight模式通常和Composite（4.3）模式结合起来，用共享叶结点的有向无环图实现一个逻辑上的层次结构。 </li>
<li>通常，最好用flyweight实现State（5.8）和Strategy（5.9）对象。</li>
</ul>
</blockquote>
<p><strong>Proxy</strong></p>
<blockquote>
<p>Y：基于Fegin的远程接口调用，就是通过一个代理来实现远程接口的访问。</p>
<p>GOF：</p>
<ul>
<li>Decorator（4.4）：尽管装饰的实现部分与代理相似，但装饰的目的不一样。装饰为对象添加一个或多个功能，而代理则控制对对象的访问。</li>
</ul>
</blockquote>
<p><strong>结构型模式讨论</strong></p>
<p><strong>Chain of Responsibility</strong></p>
<blockquote>
<p>GOF: 职责链常与Composite（4.3）一起使用。这种情况下，一个构件的父构件可作为它的后继。</p>
<p>Y：这样的话，Spring BeanFactory中查询给定类的BeanDefinition时，也是先使用当前工厂，查不到会向上递归使用父工厂查询，那这也是Composite与责任链模式结合使用了？</p>
<p>Y：定义一个list chains存储所有handler，遍历处理request，算是责任链模式吗？应该是的。</p>
</blockquote>
<p><strong>Command</strong></p>
<blockquote>
<p>Y：领域驱动设计中会使用到。</p>
</blockquote>
<p><strong>Interpreter</strong></p>
<blockquote>
<p>GOF：一般只有在用一个类层次来定义某个语言时，才强调使用解释器模式。</p>
</blockquote>
<p><strong>Iterator</strong></p>
<blockquote>
<p>GOF：提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</p>
<p>Y：迭代器类ConcreateIterator应该是作为聚合类ConcreateAggregate的内部类，以保证ConcreateAggregate不需要暴露其内部表示，而ConcreateIterator又可以访问ConcreateAggregate的内部结构以完成遍历。</p>
</blockquote>
<p><strong>Mediator</strong></p>
<p><strong>Memento</strong></p>
<blockquote>
<p>Y：常与Command一起使用，Command用于回退，而Memento则用来备份Command执行前的状态。</p>
<p>GOF：</p>
<ul>
<li>1）语言支持　备忘录有两个接口：一个为原发器所使用的宽接口，一个为其他对象所使用的窄接口。理想的实现语言应可支持两级的静态保护。</li>
</ul>
<p>Y：Java中可以使用内部类来实现，Memento作为Originator的内部类。</p>
</blockquote>
<p><strong>Observer</strong></p>
<p><strong>State</strong></p>
<p><strong>Strategy</strong></p>
<p><strong>Template Method</strong></p>
<p><strong>Visitor</strong></p>
<blockquote>
<p>Y：Lambada表达式，如map()。</p>
</blockquote>
<h1 id="3-源码中的应用"><a href="#3-源码中的应用" class="headerlink" title="3. 源码中的应用"></a>3. 源码中的应用</h1><h2 id="3-1-创建型"><a href="#3-1-创建型" class="headerlink" title="3.1 创建型"></a>3.1 创建型</h2><h2 id="3-2-结构型"><a href="#3-2-结构型" class="headerlink" title="3.2 结构型"></a>3.2 结构型</h2><h3 id="3-2-6-Flyweight"><a href="#3-2-6-Flyweight" class="headerlink" title="3.2.6 Flyweight"></a>3.2.6 Flyweight</h3><p><strong>JDK：Integer.IntegerCache</strong></p>
<ul>
<li><pre><code class="java">// 存储了 -128 and 127 范围的Integer包装类实例。在类加载时初始化。
static final Integer cache[];
</code></pre>
</li>
</ul>
<hr>
<blockquote>
<p>内容来源：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lqmblog/p/8549833.html">GOF23种设计模式精解</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhanduo0118/article/details/85602983">创建型、行为型、结构型有什么区别和联系？</a></li>
<li>《设计模式 可复用面向对象软件的基础》</li>
</ul>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.coder.love/2021/09/02/JDK-utility-class-collection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="青马流光">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="青马流光的博客">
      <meta itemprop="description" content="学习笔记">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 青马流光的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/09/02/JDK-utility-class-collection/" class="post-title-link" itemprop="url">JDK中好用的工具类收集</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-09-02 08:06:06 / 修改时间：08:15:51" itemprop="dateCreated datePublished" datetime="2021-09-02T08:06:06+08:00">2021-09-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="数组复制"><a href="#数组复制" class="headerlink" title="数组复制"></a>数组复制</h3><ul>
<li><p>Arrays.copyOf：基于System.arraycopy实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArrayList::grow</span></span><br><span class="line">elementData = Arrays.copyOf(elementData, newCapacity);</span><br></pre></td></tr></table></figure></li>
<li><p>System.arraycopy: native方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ArrayList::add(int index, E element)</span></span><br><span class="line">System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.coder.love/2021/08/29/Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="青马流光">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="青马流光的博客">
      <meta itemprop="description" content="学习笔记">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 青马流光的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/29/Spring/" class="post-title-link" itemprop="url">Spring</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-29 22:07:06" itemprop="dateCreated datePublished" datetime="2021-08-29T22:07:06+08:00">2021-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-09-03 20:05:39" itemprop="dateModified" datetime="2021-09-03T20:05:39+08:00">2021-09-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-Spring-循环依赖及三级缓存"><a href="#1-Spring-循环依赖及三级缓存" class="headerlink" title="1. Spring 循环依赖及三级缓存"></a>1. Spring 循环依赖及三级缓存</h1><p>DefaultSingletonBeanRegistry</p>
<ul>
<li>singletonObjects【一级缓存】<ul>
<li>单例对象的缓存: beanName-&gt;bean 实例</li>
</ul>
</li>
<li>singletonFactories【三级缓存】<ul>
<li>单例工厂的缓存: beanName-&gt;ObjectFactory 实例</li>
</ul>
</li>
<li>earlySingletonObjects【二级缓存】<ul>
<li>早期单例对象的缓存: beanName-&gt;bean 实例</li>
</ul>
</li>
</ul>
<p>Spring启动过程大致如下：</p>
<ol>
<li>创建beanFactory，加载配置文件；</li>
<li>解析配置文件转化beanDefination，获取到bean的所有属性、依赖及初始化用到的各类处理器等；</li>
<li>刷新beanFactory容器，初始化所有单例bean；</li>
<li>注册所有的单例bean并返回可用的容器，一般为扩展的applicationContext。</li>
</ol>
<p><strong>一级缓存</strong></p>
<p>在第三步中，所有单例的bean初始化完成后会存放在一个Map(singletonObjects)中，beanName为key，单例bean为value。</p>
<p>第三步单例bean的初始化过程大致如下：</p>
<ol>
<li>标记bean为创建中；</li>
<li>new出bean对象；</li>
<li>如果支持循环依赖则生成三级缓存，可以提前暴露bean；</li>
<li>填充bean属性，解决属性依赖；</li>
<li>初始化bean，处理Aware接口并执行各类bean后处理器，执行初始化方法，如果需要生成aop代理对象；</li>
<li>如果存在循环依赖，解决之 – 这里有点问题，这一步是如果之前解决了aop循环依赖，则缓存中放置了提前生成的代理对象，然后使用原始bean继续执行初始化，所以需要再返回最终bean前，把原始bean置换为代理对象返回；</li>
<li>此时bean已经可以被使用，进行bean注册(标记)并注册销毁方法；</li>
<li>将bean放入容器中(一级缓存)，移除创建中标记及二三级缓存(后面再具体分析)。</li>
</ol>
<h3 id="getBean-lt-AbstractBeanFactory"><a href="#getBean-lt-AbstractBeanFactory" class="headerlink" title="getBean   &lt;-  AbstractBeanFactory"></a>getBean   &lt;-  AbstractBeanFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Implementation of BeanFactory interface  </span></span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> doGetBean(name, requiredType, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, args, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="doGetBean-lt-AbstractBeanFactory"><a href="#doGetBean-lt-AbstractBeanFactory" class="headerlink" title="doGetBean  &lt;-  AbstractBeanFactory"></a>doGetBean  &lt;-  AbstractBeanFactory</h3><ul>
<li>返回指定 bean 的一个实例，该实例可以是共享的，也可以是独立的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"> <span class="comment">// 将别名解析为规范名称。</span></span><br><span class="line"> String beanName = transformedBeanName(name);</span><br><span class="line"> Object beanInstance;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 检查bean是否已经存在了缓存中</span></span><br><span class="line"> Object sharedInstance = getSingleton(beanName);</span><br><span class="line"> <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="comment">// 表明之前被创建过</span></span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">   <span class="comment">// 检查该bean单例是否正在创建中（整个工厂范围内）。</span></span><br><span class="line">   <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">    logger.trace(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line">      <span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">    logger.trace(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取给定 bean 实例的对象，如果是 FactoryBean，则是 bean 实例本身或其创建的对象。</span></span><br><span class="line">  <span class="comment">// 这里对于普通的bean，则会直接的返回，</span></span><br><span class="line">  <span class="comment">// 如果是FactoryBean类型的则会创建对应的实例返回</span></span><br><span class="line">  beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 指定的原型bean是否正在创建中(在当前线程中)。</span></span><br><span class="line">  <span class="comment">// 如果是正在创建的Prototype类型的bean,无法处理该类型循环依赖的问题，则直接抛出异常信息</span></span><br><span class="line">  <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">  <span class="comment">// 对IOC容器中是否存在指定名称的BeanDefinition进行检查，首先检查是否能在当前的BeanFactory中获取到所需要的Bean定义，如果不能则委托当前容器的父级容器去查找，如果还是找不到则沿着容器的继承体系向父级容器查找。</span></span><br><span class="line">  BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">  <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">   <span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">   String nameToLookup = originalBeanName(name);</span><br><span class="line">   <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line">    <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">      nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">    <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">    <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 到此处，说明当前IOC容器中有该bean的定义。开始创建bean。</span></span><br><span class="line">   </span><br><span class="line">	<span class="comment">// typeCheckOnly: 实例是否为类型检查获取，不用于实际使用。</span></span><br><span class="line">  <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">   <span class="comment">// 将指定的 bean 标记为已创建（或即将创建）。这允许 bean 工厂优化其缓存以重复创建指定 bean。</span></span><br><span class="line">   markBeanAsCreated(beanName);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Start：开始创建该beanName对应实例</span></span><br><span class="line">  StartupStep beanCreation = <span class="keyword">this</span>.applicationStartup.start(<span class="string">&quot;spring.beans.instantiate&quot;</span>)</span><br><span class="line">    .tag(<span class="string">&quot;beanName&quot;</span>, name);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (requiredType != <span class="keyword">null</span>) &#123;</span><br><span class="line">    beanCreation.tag(<span class="string">&quot;beanType&quot;</span>, requiredType::toString);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//根据指定Bean名称获取其父级的Bean定义</span></span><br><span class="line">   <span class="comment">//主要解决Bean继承时子类合并父类公共属性问题</span></span><br><span class="line">   RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">   checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取此bean所依赖的beanNames。</span></span><br><span class="line">   <span class="comment">// 保证对当前bean所依赖的bean进行初始化。</span></span><br><span class="line">   String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">   <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">     <span class="comment">// 如果dep依赖或者间接依赖beanName，则说明发生了环状依赖，即循环引用，抛出异常。</span></span><br><span class="line">     <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">        <span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 将beanName注册到dep的依赖和被依赖集合中。</span></span><br><span class="line">     registerDependentBean(dep, beanName);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 获取beanName的依赖dep的实例。</span></span><br><span class="line">      getBean(dep);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">        <span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Create bean instance.</span></span><br><span class="line">   <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">    sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">      <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">      <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">      <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">      destroySingleton(beanName);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">   &#125;</span><br><span class="line">		</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">    <span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">    Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">     beforePrototypeCreation(beanName);</span><br><span class="line">     prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">     afterPrototypeCreation(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">    String scopeName = mbd.getScope();</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasLength(scopeName)) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No scope name defined for bean ´&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">    <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">     Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">      beforePrototypeCreation(beanName);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">       afterPrototypeCreation(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> ScopeNotActiveException(beanName, scopeName, ex);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">   beanCreation.tag(<span class="string">&quot;exception&quot;</span>, ex.getClass().toString());</span><br><span class="line">   beanCreation.tag(<span class="string">&quot;message&quot;</span>, String.valueOf(ex.getMessage()));</span><br><span class="line">   cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">   <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">   <span class="comment">// End：bean 创建结束。</span></span><br><span class="line">   beanCreation.end();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 若beanInstance不是所需类型requiredType，则将其转化为requiredType型。 </span></span><br><span class="line"> <span class="keyword">return</span> adaptBeanInstance(name, beanInstance, requiredType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getSingleton-lt-DefaultSingletonBeanRegistry"><a href="#getSingleton-lt-DefaultSingletonBeanRegistry" class="headerlink" title="getSingleton  &lt;-  DefaultSingletonBeanRegistry"></a>getSingleton  &lt;-  DefaultSingletonBeanRegistry</h3><ul>
<li>返回在给定名称下注册的（原始）单例对象。检查已经实例化的单例，并允许早期引用当前正在创建的单例（解决循环引用）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> getSingleton(beanName, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回在给定名称下注册的(原始)单例对象。</span></span><br><span class="line"><span class="comment"> * 检查已经实例化的单例对象，并允许对当前创建的单例对象的早期引用(解析循环引用)。</span></span><br><span class="line"><span class="comment"> * 早起引用即对未完全实例化（如未完成属性设置）的引用。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"> <span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Quick check for existing instance without full singleton lock</span></span><br><span class="line">	Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">   <span class="comment">// 若 一级缓存中没有，且该bean单例正在被创建</span></span><br><span class="line">	<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">     <span class="comment">// 检查二级缓存</span></span><br><span class="line">		singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">		<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">				<span class="comment">// Consistent creation of early reference within full singleton lock</span></span><br><span class="line">         <span class="comment">// 在完整的单例锁中一致地创建早期引用。</span></span><br><span class="line">				singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">				<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">					singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">           <span class="comment">// 若二级缓存中没有，查询三级缓存。</span></span><br><span class="line">					<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">						ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">             <span class="comment">// 若三级缓存中存在。</span></span><br><span class="line">						<span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 使用三级缓存中其对应的ObjectFactory实例，获取单例实例。</span></span><br><span class="line">							singletonObject = singletonFactory.getObject();</span><br><span class="line">               <span class="comment">// 将单例实例添加到二级缓存中。</span></span><br><span class="line">							<span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">               <span class="comment">// 将三级缓存中的该beanName映射移除。</span></span><br><span class="line">							<span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getSingleton-lt-DefaultSingletonBeanRegistry-1"><a href="#getSingleton-lt-DefaultSingletonBeanRegistry-1" class="headerlink" title="getSingleton &lt;- DefaultSingletonBeanRegistry"></a>getSingleton &lt;- DefaultSingletonBeanRegistry</h3><ul>
<li>返回以给定名称注册的（原始）单例对象，如果尚未注册，则创建并注册一个新对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">	Assert.notNull(beanName, <span class="string">&quot;Bean name must not be null&quot;</span>);</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">		Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">		<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationNotAllowedException(beanName,</span><br><span class="line">						<span class="string">&quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot;</span> +</span><br><span class="line">						<span class="string">&quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Creating shared instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">       <span class="comment">// 单例创建之前的回调。默认实现将单例注册为当前正在创建中。</span></span><br><span class="line">			beforeSingletonCreation(beanName);</span><br><span class="line">			<span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">boolean</span> recordSuppressedExceptions = (<span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>);</span><br><span class="line">			<span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">				<span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 生成实例对象。</span></span><br><span class="line">				singletonObject = singletonFactory.getObject();</span><br><span class="line">				newSingleton = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">				<span class="comment">// Has the singleton object implicitly appeared in the meantime -&gt;</span></span><br><span class="line">				<span class="comment">// if yes, proceed with it since the exception indicates that state.</span></span><br><span class="line">				singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">				<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">throw</span> ex;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">				<span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">					<span class="keyword">for</span> (Exception suppressedException : <span class="keyword">this</span>.suppressedExceptions) &#123;</span><br><span class="line">						ex.addRelatedCause(suppressedException);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">					<span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">				&#125;</span><br><span class="line">         <span class="comment">// 创建单例后回调，默认实现将单例标记为不再创建。</span></span><br><span class="line">				afterSingletonCreation(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">         <span class="comment">// 将给定的单例对象添加到该工厂的单例缓存中。要求对单例进行紧急注册。</span></span><br><span class="line">				addSingleton(beanName, singletonObject);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> singletonObject;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="addSingleton-lt-DefaultSingletonBeanRegistry"><a href="#addSingleton-lt-DefaultSingletonBeanRegistry" class="headerlink" title="addSingleton &lt;- DefaultSingletonBeanRegistry"></a>addSingleton &lt;- DefaultSingletonBeanRegistry</h3><ul>
<li>将给定的单例对象添加到该工厂的单例缓存中。要求对单例进行紧急注册。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">      <span class="comment">// 添加到一级缓存中</span></span><br><span class="line">			<span class="keyword">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">      <span class="comment">// 从三级缓存中移除</span></span><br><span class="line">			<span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">      <span class="comment">// 从二级缓存中移除</span></span><br><span class="line">			<span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">      <span class="comment">// 添加到registeredSingletons</span></span><br><span class="line">			<span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getObjectForBeanInstance-lt-AbstractAutowireCapableBeanFactory"><a href="#getObjectForBeanInstance-lt-AbstractAutowireCapableBeanFactory" class="headerlink" title="getObjectForBeanInstance &lt;- AbstractAutowireCapableBeanFactory"></a>getObjectForBeanInstance &lt;- AbstractAutowireCapableBeanFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">			Object beanInstance, String name, String beanName, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		String currentlyCreatedBean = <span class="keyword">this</span>.currentlyCreatedBean.get();</span><br><span class="line">		<span class="keyword">if</span> (currentlyCreatedBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 为给定bean注册一个依赖bean，以便在给定bean销毁之前销毁它。</span></span><br><span class="line">			registerDependentBean(beanName, currentlyCreatedBean);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getObjectForBeanInstance(beanInstance, name, beanName, mbd);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="registerDependentBean-lt-DefaultSingletonBeanRegistry"><a href="#registerDependentBean-lt-DefaultSingletonBeanRegistry" class="headerlink" title="registerDependentBean &lt;- DefaultSingletonBeanRegistry"></a>registerDependentBean &lt;- DefaultSingletonBeanRegistry</h3><ul>
<li>维护dependentBeanMap和dependenciesForBean</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerDependentBean</span><span class="params">(String beanName, String dependentBeanName)</span> </span>&#123;</span><br><span class="line">		String canonicalName = canonicalName(beanName);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.dependentBeanMap) &#123;</span><br><span class="line">			Set&lt;String&gt; dependentBeans =</span><br><span class="line">					<span class="keyword">this</span>.dependentBeanMap.computeIfAbsent(canonicalName, k -&gt; <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">8</span>));</span><br><span class="line">      <span class="comment">// 若已存在则直接返回。</span></span><br><span class="line">			<span class="keyword">if</span> (!dependentBeans.add(dependentBeanName)) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.dependenciesForBeanMap) &#123;</span><br><span class="line">			Set&lt;String&gt; dependenciesForBean =</span><br><span class="line">					<span class="keyword">this</span>.dependenciesForBeanMap.computeIfAbsent(dependentBeanName, k -&gt; <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">8</span>));</span><br><span class="line">			dependenciesForBean.add(canonicalName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getObjectForBeanInstance-lt-AbstractBeanFactory"><a href="#getObjectForBeanInstance-lt-AbstractBeanFactory" class="headerlink" title="getObjectForBeanInstance &lt;- AbstractBeanFactory"></a>getObjectForBeanInstance &lt;- AbstractBeanFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取给定 bean 实例的对象，如果是 FactoryBean，则是 bean 实例本身或其创建的对象。</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">			Object beanInstance, String name, String beanName, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Don&#x27;t let calling code try to dereference the factory if the bean isn&#x27;t a factory.</span></span><br><span class="line">		<span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">      <span class="comment">// NullBean是空bean实例的内部表示。</span></span><br><span class="line">			<span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">				<span class="keyword">return</span> beanInstance;</span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">//name的前缀是&amp;,但是类型不是FactoryBean，就报错</span></span><br><span class="line">			<span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanIsNotAFactoryException(beanName, beanInstance.getClass());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (mbd != <span class="keyword">null</span>) &#123;</span><br><span class="line">				mbd.isFactoryBean = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> beanInstance;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 现在我们有了bean实例，它可以是普通bean或FactoryBean。如果它是FactoryBean，我们使用它来创建bean实例，除非调用者实际上想要一个对工厂的引用。</span></span><br><span class="line">		<span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">			<span class="keyword">return</span> beanInstance;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Object object = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (mbd != <span class="keyword">null</span>) &#123;</span><br><span class="line">			mbd.isFactoryBean = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 从给定的FactoryBean获取要公开的对象（如果缓存中有的话）。</span></span><br><span class="line">			object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// Return bean instance from factory.</span></span><br><span class="line">			FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">			<span class="comment">// Caches object obtained from FactoryBean if it is a singleton.</span></span><br><span class="line">			<span class="keyword">if</span> (mbd == <span class="keyword">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">        <span class="comment">// 返回合并的 RootBeanDefinition，如果指定的 bean 对应于子 bean 定义，则遍历其父 bean 定义。</span></span><br><span class="line">				mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">      <span class="comment">// 此 bean 定义是否是“合成的”，即不是由应用程序本身定义的</span></span><br><span class="line">			<span class="keyword">boolean</span> synthetic = (mbd != <span class="keyword">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">      <span class="comment">// 从给定的 FactoryBean 获取要公开的对象。</span></span><br><span class="line">			object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> object;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="isFactoryDereference-lt-BeanFactoryUtils"><a href="#isFactoryDereference-lt-BeanFactoryUtils" class="headerlink" title="isFactoryDereference &lt;- BeanFactoryUtils"></a>isFactoryDereference &lt;- BeanFactoryUtils</h3><ul>
<li>返回给定的名称是否为工厂的间接引用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFactoryDereference</span><span class="params">(<span class="meta">@Nullable</span> String name)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// BeanFactory.FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;</span></span><br><span class="line">	<span class="keyword">return</span> (name != <span class="keyword">null</span> &amp;&amp; name.startsWith(BeanFactory.FACTORY_BEAN_PREFIX));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="createBean-lt-AbstractAutowireCapableBeanFactory"><a href="#createBean-lt-AbstractAutowireCapableBeanFactory" class="headerlink" title="createBean &lt;- AbstractAutowireCapableBeanFactory"></a>createBean &lt;- AbstractAutowireCapableBeanFactory</h3><ul>
<li>在AbstractBeanFactory中该方法为抽象方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 此类的中心方法：创建 bean 实例、填充 bean 实例、应用后处理器等。</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">		logger.trace(<span class="string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 确保此时实际解析了bean class，并在动态解析class的情况下克隆无法存储在共享合并bean定义中的bean定义。</span></span><br><span class="line">   <span class="comment">// 解析指定bean definition的bean class，将bean class name 解析为Class引用(如果需要)，并将解析后的Class存储在bean definition中以供进一步使用。</span></span><br><span class="line">	Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">	<span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">		mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Prepare method overrides.</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		mbdToUse.prepareMethodOverrides();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">				beanName, <span class="string">&quot;Validation of method overrides failed&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 让BeanPostProcessors有机会返回一个代理而不是目标bean实例。（InstantiationAwareBeanPostProcessor）</span></span><br><span class="line">		Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">		<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> bean;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">				<span class="string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// 不同于默认的bean实例化，使用工厂方法和自动装配构造函数。</span></span><br><span class="line">		Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> beanInstance;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line">		<span class="comment">// A previously detected exception with proper bean creation context already,</span></span><br><span class="line">		<span class="comment">// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span></span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">				mbdToUse.getResourceDescription(), beanName, <span class="string">&quot;Unexpected exception during bean creation&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="resolveBeforeInstantiation-lt-AbstractAutowireCapableBeanFactory"><a href="#resolveBeforeInstantiation-lt-AbstractAutowireCapableBeanFactory" class="headerlink" title="resolveBeforeInstantiation &lt;- AbstractAutowireCapableBeanFactory"></a>resolveBeforeInstantiation &lt;- AbstractAutowireCapableBeanFactory</h3><ul>
<li>应用before-instantiation post-processors，解析指定bean是否有实例化之前的shortcut。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">resolveBeforeInstantiation</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">	Object bean = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;</span><br><span class="line">		<span class="comment">// 确保bean class在此时已实际解析。</span></span><br><span class="line">		<span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">       <span class="comment">// 确定bean的目标类型</span></span><br><span class="line">			Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);</span><br><span class="line">			<span class="keyword">if</span> (targetType != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 实例化前的后处理器，这里生成bean或其代理后交给 实例化后的后处理器加工。</span></span><br><span class="line">				bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line">				<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 实例化后的后处理器   加工完之后 这个bean会用来替换原本正常逻辑中的bean</span></span><br><span class="line">					bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">     <span class="comment">// 设置beforeInstantiationResolved，其为true表示实例化前的后处理器已经启动。</span></span><br><span class="line">		mbd.beforeInstantiationResolved = (bean != <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="doCreateBean-lt-AbstractAutowireCapableBeanFactory"><a href="#doCreateBean-lt-AbstractAutowireCapableBeanFactory" class="headerlink" title="doCreateBean &lt;- AbstractAutowireCapableBeanFactory"></a>doCreateBean &lt;- AbstractAutowireCapableBeanFactory</h3><ul>
<li>实际创建指定的bean。此时已经进行了创建前处理，例如检查postProcessBeforeInstantiation回调。</li>
<li>区别默认bean实例化、使用工厂方法和自动装配构造函数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Instantiate the bean.</span></span><br><span class="line">	BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">     <span class="comment">// 如果RootBeanDefinition是单例的，则移除未完成的FactoryBean实例的缓存。</span></span><br><span class="line">		instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">// 使用适当的实例化策略为指定的 bean 创建一个新实例：工厂方法、构造函数自动装配或简单实例化。</span></span><br><span class="line">		instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">	&#125;</span><br><span class="line">	Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">	Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">	<span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">		mbd.resolvedTargetType = beanType;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">	<span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 将 MergedBeanDefinitionPostProcessors 应用于指定的 bean 定义，调用它们的postProcessMergedBeanDefinition方法。</span></span><br><span class="line">				applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">						<span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 主动缓存单例，以便能够解析循环引用，即使是在BeanFactoryAware等生命周期接口触发的情况下。</span></span><br><span class="line">   <span class="comment">// 是否暴露早期单例 early singleton。当需要创建单例，且允许循环引用，且该beanName已在创建之中，则暴露其early singleton。</span></span><br><span class="line">	<span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">			isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">					<span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化bean实例。</span></span><br><span class="line">	Object exposedObject = bean;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">// 使用 bean 定义中的属性值填充给定 BeanWrapper 中的 bean 实例。</span></span><br><span class="line">		populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">     <span class="comment">// 初始化给定的 bean 实例，应用工厂回调以及 init 方法和 bean 后处理器。</span></span><br><span class="line">     <span class="comment">// Called from createBean for traditionally defined beans, and from initializeBean for existing bean instances.</span></span><br><span class="line">		exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">			<span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">					mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果允许公开early singleton</span></span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">     <span class="comment">// 获取early singleton</span></span><br><span class="line">		Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">				exposedObject = earlySingletonReference;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">				String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">				Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">				<span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">					<span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">						actualDependentBeans.add(dependentBean);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">           <span class="comment">// 存在beans引用了该bean的原始版本，而没有使用其最终版本。</span></span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">							<span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">							StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">							<span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">							<span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">							<span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">							<span class="string">&quot;&#x27;getBeanNamesForType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register bean as disposable.</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">				mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="createBeanInstance-lt-AbstractAutowireCapableBeanFactory"><a href="#createBeanInstance-lt-AbstractAutowireCapableBeanFactory" class="headerlink" title="createBeanInstance &lt;- AbstractAutowireCapableBeanFactory"></a>createBeanInstance &lt;- AbstractAutowireCapableBeanFactory</h3><ul>
<li>使用适当的实例化策略为指定的 bean 创建一个新实例：工厂方法、构造函数自动装配或简单实例化。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">		Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">					<span class="string">&quot;Bean class isn&#x27;t public, and non-public access not allowed: &quot;</span> + beanClass.getName());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line">		<span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Shortcut when re-creating the same bean...</span></span><br><span class="line">		<span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">				<span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">					resolved = <span class="keyword">true</span>;</span><br><span class="line">					autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">			<span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">				<span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Candidate constructors for autowiring?</span></span><br><span class="line">		Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">		<span class="keyword">if</span> (ctors != <span class="keyword">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">				mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line">			<span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Preferred constructors for default construction?</span></span><br><span class="line">		ctors = mbd.getPreferredConstructors();</span><br><span class="line">		<span class="keyword">if</span> (ctors != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, <span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line">		<span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="addSingletonFactory-lt-DefaultSingletonBeanRegistry"><a href="#addSingletonFactory-lt-DefaultSingletonBeanRegistry" class="headerlink" title="addSingletonFactory &lt;- DefaultSingletonBeanRegistry"></a>addSingletonFactory &lt;- DefaultSingletonBeanRegistry</h3><ul>
<li>如果需要的话，添加给定的单例工厂来构建指定的单例。用于单例的紧急注册，例如能够解析循环引用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">	Assert.notNull(singletonFactory, <span class="string">&quot;Singleton factory must not be null&quot;</span>);</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">       <span class="comment">// 添加三级缓存</span></span><br><span class="line">			<span class="keyword">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">       <span class="comment">// 移除二级缓存</span></span><br><span class="line">			<span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">       <span class="comment">// 注册该单例</span></span><br><span class="line">			<span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getEarlyBeanReference-lt-AbstractAutowireCapableBeanFactory"><a href="#getEarlyBeanReference-lt-AbstractAutowireCapableBeanFactory" class="headerlink" title="getEarlyBeanReference &lt;- AbstractAutowireCapableBeanFactory"></a>getEarlyBeanReference &lt;- AbstractAutowireCapableBeanFactory</h3><ul>
<li>获取对指定 bean 的早期访问的引用，通常用于解析循环引用。</li>
<li>SmartInstantiationAwareBeanPostProcessor</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">		Object exposedObject = bean;</span><br><span class="line">		<span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">			<span class="keyword">for</span> (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) &#123;</span><br><span class="line">				exposedObject = bp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> exposedObject;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h3 id="initializeBean-lt-AbstractAutowireCapableBeanFactory"><a href="#initializeBean-lt-AbstractAutowireCapableBeanFactory" class="headerlink" title="initializeBean &lt;- AbstractAutowireCapableBeanFactory"></a>initializeBean &lt;- AbstractAutowireCapableBeanFactory</h3><ul>
<li>初始化给定的 bean 实例，应用工厂回调以及 init 方法和 bean 后处理器。</li>
<li>Called from createBean for traditionally defined beans, and from initializeBean for existing bean instances.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// Aware 方法调用：BeanNameAware、BeanClassLoaderAware、BeanFactoryAware</span></span><br><span class="line"> <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">  AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">   invokeAwareMethods(beanName, bean);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;, getAccessControlContext());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  invokeAwareMethods(beanName, bean);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> Object wrappedBean = bean;</span><br><span class="line"> <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">  <span class="comment">// 对wrappedBean应用所有已注册的BeanPostProcessor的postProcessBeforeInitialization方法。</span></span><br><span class="line">  wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 现在，所有属性都设置好了，让bean有机会作出反应，并有机会了解其所属的bean工厂(此对象)。这意味着检查bean是否实现了InitializingBean或定义了自定义的init方法，如果实现了，则调用必要的回调。</span></span><br><span class="line">  invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">    (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">    beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">  <span class="comment">// 对wrappedBean应用所有已注册的BeanPostProcessor的 postProcessAfterInitialization 方法。</span></span><br><span class="line">  wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="invokeInitMethods-lt-AbstractAutowireCapableBeanFactory"><a href="#invokeInitMethods-lt-AbstractAutowireCapableBeanFactory" class="headerlink" title="invokeInitMethods &lt;- AbstractAutowireCapableBeanFactory"></a>invokeInitMethods &lt;- AbstractAutowireCapableBeanFactory</h3><ul>
<li>现在，所有属性都设置好了，让bean有机会作出反应，并有机会了解其所属的bean工厂(此对象)。这意味着检查bean是否实现了InitializingBean或定义了自定义的init方法，如果实现了，则调用必要的回调。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line"> <span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">&quot;afterPropertiesSet&quot;</span>))) &#123;</span><br><span class="line">  <span class="comment">// 调用 afterPropertiesSet方法。此方法允许 bean 实例在设置所有 bean 属性后执行其整体配置和最终初始化的验证。</span></span><br><span class="line">  <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">   logger.trace(<span class="string">&quot;Invoking afterPropertiesSet() on bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">    AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">     ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;, getAccessControlContext());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">    <span class="keyword">throw</span> pae.getException();</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">   ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (mbd != <span class="keyword">null</span> &amp;&amp; bean.getClass() != NullBean.class) &#123;</span><br><span class="line">  String initMethodName = mbd.getInitMethodName();</span><br><span class="line">  <span class="keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;&amp;</span><br><span class="line">    !(isInitializingBean &amp;&amp; <span class="string">&quot;afterPropertiesSet&quot;</span>.equals(initMethodName)) &amp;&amp;</span><br><span class="line">    !mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">   <span class="comment">// 在给定的bean上调用指定的自定义init方法。叫invokeInitMethods。可以在子类中重写，以便自定义带有参数的init方法解析。</span></span><br><span class="line">   invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-Spring-与-设计模式"><a href="#2-Spring-与-设计模式" class="headerlink" title="2. Spring 与 设计模式"></a>2. Spring 与 设计模式</h1><h2 id="2-1-模版方法模式"><a href="#2-1-模版方法模式" class="headerlink" title="2.1 模版方法模式"></a>2.1 模版方法模式</h2><p>定义：模板方法模式定义了一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些步骤。</p>
<hr>
<blockquote>
<p>内容来源：</p>
<p><a target="_blank" rel="noopener" href="https://itsoku.blog.csdn.net/article/details/113977261">Spring系列第56篇：一文搞懂spring到底为什么要用三级缓存</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.coder.love/2021/08/29/Spring-Abstract/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="青马流光">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="青马流光的博客">
      <meta itemprop="description" content="学习笔记">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 青马流光的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/29/Spring-Abstract/" class="post-title-link" itemprop="url">Spring 抽象</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-29 14:37:01" itemprop="dateCreated datePublished" datetime="2021-08-29T14:37:01+08:00">2021-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-21 15:26:14" itemprop="dateModified" datetime="2022-03-21T15:26:14+08:00">2022-03-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-BeanFactory"><a href="#1-BeanFactory" class="headerlink" title="1. BeanFactory"></a>1. BeanFactory</h1><p>用于访问Spring bean容器的 root 接口。</p>
<p>这是bean容器的基本客户端视图;其他接口如ListableBeanFactory和org.springframework.beans.factory.config.ConfigurableBeanFactory可用于特定用途。</p>
<p>该接口由包含许多bean定义的对象实现，每个bean定义都由一个String名称唯一标识。根据bean定义，工厂将返回被包含对象的独立实例(Prototype设计模式)，或单个共享实例(Singleton设计模式的更好选择，在该模式中，实例是工厂范围内的一个单例)。返回哪种类型的实例取决于bean工厂配置:API是相同的。从Spring 2.0开始，根据具体的应用程序上下文(例如。web环境中的“请求”和“会话”范围)。</p>
<p>这种方法的要点在于，BeanFactory是应用程序组件的中央注册中心，并集中应用程序组件的配置(例如，单个对象不再需要读取属性文件)。</p>
<p>请注意，依赖依赖项注入(“push”配置)通过setters或constructors配置应用程序对象通常比使用任何形式的“pull”配置(如BeanFactory查找)更好。Spring的依赖注入功能是使用这个BeanFactory接口及其子接口实现的。</p>
<p><strong>Bean工厂实现应该尽可能支持标准的Bean生命周期接口。完整的初始化方法及其标准顺序为:</strong></p>
<ol>
<li>BeanNameAware的setBeanName</li>
<li>BeanClassLoaderAware的setBeanClassLoader</li>
<li>BeanFactoryAware的setBeanFactory</li>
<li>EnvironmentAware的setEnvironment</li>
<li>EmbeddedValueResolverAware的setEmbeddedValueResolver</li>
<li>ResourceLoaderAware的setResourceLoader(仅适用于在应用程序上下文中运行时)</li>
<li>ApplicationEventPublisherAware的setApplicationEventPublisher(仅适用于在应用程序上下文中运行时)</li>
<li>MessageSourceAware的setMessageSource(仅适用于在应用程序上下文中运行时)</li>
<li>ApplicationContextAware的setApplicationContext(仅适用于在应用程序上下文中运行时)</li>
<li>ServletContextAware的setServletContext(仅适用于运行在web应用程序上下文时)</li>
<li><strong>BeanPostProcessors</strong>的<strong>postProcessBeforeInitialization</strong>方法</li>
<li><strong>InitializingBean</strong>的<strong>afterPropertiesSet</strong></li>
<li>自定义的 <strong>init-method</strong> 定义</li>
<li><strong>BeanPostProcessors</strong>的<strong>postProcessAfterInitialization</strong>方法</li>
</ol>
<p><strong>在关闭bean工厂时，应用以下生命周期方法:</strong></p>
<ol>
<li>DestructionAwareBeanPostProcessors的postProcessBeforeDestruction方法</li>
<li>DisposableBean 的 destroy</li>
<li>自定义的 destroy-method 定义</li>
</ol>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/1731892-20210610131522589-2144305263.png" alt="BeanFactoryUML_01"></p>
<h2 id="AbstractAutowireCapableBeanFactory"><a href="#AbstractAutowireCapableBeanFactory" class="headerlink" title="AbstractAutowireCapableBeanFactory"></a>AbstractAutowireCapableBeanFactory</h2><p>实现默认 bean 创建的抽象 bean 工厂超类，具有RootBeanDefinition类指定的全部功能。 除了 AbstractBeanFactory 的createBean方法之外，还实现AutowireCapableBeanFactory接口。<br>提供 bean 创建（具有构造函数解析）、属性填充、wiring（包括autowiring）和初始化。 处理运行时 bean 引用、解析托管集合、调用初始化方法等。支持自动装配构造函数、按名称的属性和按类型的属性。</p>
<p>子类要实现的主要<strong>模板方法</strong>是<strong>resolveDependency</strong>(DependencyDescriptor, String, Set, TypeConverter) ，用于按类型自动装配。 如果工厂能够搜索其 bean 定义，匹配 bean 通常将通过这样的搜索来实现。 对于其他工厂样式，可以实现简化的匹配算法。</p>
<p>请注意，此类不承担或实现 bean 定义注册表功能。 有关org.springframework.beans.factory.ListableBeanFactory和BeanDefinitionRegistry接口的实现，请参阅DefaultListableBeanFactory ，它们分别代表此类工厂的 API 和 SPI 视图。</p>
<h3 id="createBean"><a href="#createBean" class="headerlink" title="createBean"></a>createBean</h3><ul>
<li><p>用于对bean生命周期进行细粒度控制的专用方法。</p>
</li>
<li><p>使用非单例bean定义，以避免将bean注册为依赖bean。</p>
</li>
<li><p>此类的中心方法：创建 bean 实例、填充 bean 实例、应用后处理器等。</p>
</li>
</ul>
<h3 id="doCreateBean"><a href="#doCreateBean" class="headerlink" title="doCreateBean"></a>doCreateBean</h3><ul>
<li>实际创建指定的bean。 预创建处理此时已经发生，例如检查postProcessBeforeInstantiation回调。<br>区分默认 bean 实例化、工厂方法的使用和自动装配构造函数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Instantiate the bean.</span></span><br><span class="line">	BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">     <span class="comment">// 如果RootBeanDefinition是单例的，则移除未完成的FactoryBean实例的缓存。</span></span><br><span class="line">		instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="comment">// 使用适当的实例化策略为指定的 bean 创建一个新实例：工厂方法、构造函数自动装配或简单实例化。</span></span><br><span class="line">		instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">	&#125;</span><br><span class="line">	Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">	Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line">	<span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">		mbd.resolvedTargetType = beanType;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">	<span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 将 MergedBeanDefinitionPostProcessors 应用于指定的 bean 定义，调用它们的postProcessMergedBeanDefinition方法。</span></span><br><span class="line">				applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">						<span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 主动缓存单例，以便能够解析循环引用，即使是在BeanFactoryAware等生命周期接口触发的情况下。</span></span><br><span class="line">	<span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">			isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">					<span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize the bean instance.</span></span><br><span class="line">	Object exposedObject = bean;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">		exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">			<span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">					mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">		Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">				exposedObject = earlySingletonReference;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">				String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">				Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">				<span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">					<span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">						actualDependentBeans.add(dependentBean);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">							<span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">							StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">							<span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">							<span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">							<span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">							<span class="string">&quot;&#x27;getBeanNamesForType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register bean as disposable.</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">				mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="DefaultListableBeanFactorys"><a href="#DefaultListableBeanFactorys" class="headerlink" title="DefaultListableBeanFactorys"></a>DefaultListableBeanFactorys</h2><ul>
<li>Spring 对ConfigurableListableBeanFactory和BeanDefinitionRegistry接口的默认实现：一个基于 bean 定义元数据的成熟 bean 工厂，可通过后处理器扩展。</li>
<li>典型用法是在访问 bean 之前首先注册所有 bean 定义（可能从 bean 定义文件中读取）。 因此，按名称查找 Bean 是在本地 bean 定义表中的廉价操作，对预先解析的 bean 定义元数据对象进行操作。</li>
<li>请注意，特定 bean 定义格式的读取器通常是单独实现的，而不是作为 bean 工厂子类实现：例如参见org.springframework.beans.factory.xml.XmlBeanDefinitionReader 。</li>
<li>对于org.springframework.beans.factory.ListableBeanFactory接口的另一种实现，请查看StaticListableBeanFactory ，它管理现有的 bean 实例，而不是根据 bean 定义创建新实例。</li>
</ul>
<h2 id="DefaultSingletonBeanRegistry"><a href="#DefaultSingletonBeanRegistry" class="headerlink" title="DefaultSingletonBeanRegistry"></a>DefaultSingletonBeanRegistry</h2><ul>
<li><p>singletonObjects【一级缓存】</p>
<ul>
<li>单例对象的缓存: beanName -&gt; bean 实例</li>
</ul>
</li>
<li><p>singletonFactories【三级缓存】</p>
<ul>
<li>单例工厂的缓存: beanName -&gt; ObjectFactory 实例</li>
</ul>
</li>
<li><p>earlySingletonObjects【二级缓存】</p>
<ul>
<li>早期单例对象（半成品，属性未填充的）的缓存: beanName -&gt; bean 实例</li>
</ul>
</li>
<li><p>registeredSingletons</p>
<ul>
<li>一组已注册的单例，包含按注册顺序排列的bean名称。</li>
</ul>
</li>
<li><p>singletonsCurrentlyInCreation</p>
<ul>
<li>当前正在创建的bean的名称。</li>
</ul>
</li>
<li><p>inCreationCheckExclusions</p>
<ul>
<li>当前在创建检查中排除的bean的名称。</li>
</ul>
</li>
<li><p>suppressedExceptions</p>
<ul>
<li>被抑制异常的集合，可用于关联相关原因。</li>
</ul>
</li>
<li><p>singletonsCurrentlyInDestruction: boolean = false;</p>
<ul>
<li>标志表明我们目前是否在摧毁singleton。</li>
</ul>
</li>
<li><p>disposableBeans</p>
<ul>
<li>可丢弃的bean实例:bean名称到可丢弃的实例。</li>
</ul>
</li>
<li><p>containedBeanMap</p>
<ul>
<li>包含bean名称之间的映射: bean名称与bean包含的bean名称集之间的映射。</li>
</ul>
</li>
<li><p>dependentBeanMap</p>
<ul>
<li>依赖bean名称之间的映射:bean名称到依赖该bean的bean名称集。即“谁依赖我”。</li>
</ul>
</li>
<li><p>dependenciesForBeanMap</p>
<ul>
<li>依赖bean名称之间的映射:bean名称到bean的依赖项的bean名称集。即“我依赖谁”</li>
</ul>
</li>
</ul>
<h1 id="2-API和SPI视图"><a href="#2-API和SPI视图" class="headerlink" title="2. API和SPI视图"></a>2. API和SPI视图</h1><p>Java 中区分 API 和 SPI，通俗的讲：API 和 SPI 都是相对的概念，他们的差别只在语义上，API 直接被应用开发人员使用，SPI 被框架扩展人员使用。</p>
<p>API （Application Programming Interface）</p>
<ul>
<li>大多数情况下，都是<strong>实现方</strong>来制定接口并完成对接口的不同实现，<strong>调用方</strong>仅仅依赖却无权选择不同实现。</li>
</ul>
<p>SPI (Service Provider Interface)</p>
<ul>
<li>而如果是<strong>调用方</strong>来制定接口，<strong>实现方</strong>来针对接口来实现不同的实现。<strong>调用方</strong>来选择自己需要的实现方。</li>
</ul>
<p>从面向接口编程说起</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/20180909205040343.jpeg" alt="这里写图片描述"></p>
<p>当我们选择在<strong>调用方</strong> 和 <strong>实现方</strong> 中间引入接口。上图没有给出“接口”应该位于哪个“包”中，从纯粹的可能性上考虑，我们有三种选择：</p>
<ol>
<li>接口位于<strong>实现方</strong>所在的包中；</li>
<li>接口位于<strong>调用方</strong>所在的包中；</li>
<li>接口位于独立的包中。</li>
</ol>
<h2 id="2-1-接口位于【调用方】所在的包中"><a href="#2-1-接口位于【调用方】所在的包中" class="headerlink" title="2.1 接口位于【调用方】所在的包中"></a>2.1 接口位于【调用方】所在的包中</h2><p>对于类似这种情况下接口，我们将其称为 SPI, SPI的规则如下：</p>
<ul>
<li>概念上更依赖调用方。</li>
<li>组织上位于调用方所在的包中。</li>
<li>实现位于独立的包中。</li>
</ul>
<p>常见的例子是：插件模式的插件。如：</p>
<ul>
<li>数据库驱动 Driver</li>
<li>日志 Log</li>
<li>dubbo扩展点开发</li>
</ul>
<h2 id="2-2-接口位于【实现方】所在的包中"><a href="#2-2-接口位于【实现方】所在的包中" class="headerlink" title="2.2 接口位于【实现方】所在的包中"></a>2.2 接口位于【实现方】所在的包中</h2><p>对于类似这种情况下的接口，我们将其称作为API，API的规则如下：</p>
<ul>
<li>概念上更接近实现方。</li>
<li>组织上位于实现方所在的包中。</li>
</ul>
<h2 id="2-3-接口位于独立的包中"><a href="#2-3-接口位于独立的包中" class="headerlink" title="2.3 接口位于独立的包中"></a>2.3 接口位于独立的包中</h2><p>如果一个“接口”在一个上下文是API，在另一个上下文是SPI，那么你就可以这么组织</p>
<p>需要注意的事项</p>
<p>SPI 和 API 也不一定是接口，这里都是指狭义的具体的接口。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/70-20210829161437067.png" alt="这里写图片描述"></p>
<p><strong>Java类库中的实例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">Connection conn = DriverManager.getConnection(</span><br><span class="line">              <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">Statement stmt = conn.createStatement();</span><br><span class="line">ResultSet rs = stmt.executeQuery(<span class="string">&quot;select * from Users&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>说明：java.sql.Driver 是 Spi，com.mysql.jdbc.Driver 是 Spi 实现，其它的都是 Api。</p>
<h1 id="3-RootBeanDefinition"><a href="#3-RootBeanDefinition" class="headerlink" title="3. RootBeanDefinition"></a>3. RootBeanDefinition</h1><h1 id="4-ObjectFactory"><a href="#4-ObjectFactory" class="headerlink" title="4. ObjectFactory"></a>4. ObjectFactory</h1><ul>
<li><p>@FunctionalInterface</p>
</li>
<li><p>定义一个工厂，它可以在调用时返回一个 Object 实例（可能是共享的或独立的）。<br>此接口通常用于封装通用工厂，该工厂在每次调用时返回某个目标对象的新实例（原型）。<br>此接口类似于FactoryBean ，但后者的实现通常意味着在BeanFactory定义为 SPI 实例，而此类的实现通常意味着作为 API 提供给其他 bean（通过注入）。 因此， getObject()方法具有不同的异常处理行为。</p>
</li>
<li><p>```java<br>() -&gt; getEarlyBeanReference(beanName, mbd, bean)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">  protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) &#123;</span><br><span class="line">		Object exposedObject = bean;</span><br><span class="line">		if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">			for (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) &#123;</span><br><span class="line">				exposedObject = bp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return exposedObject;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>AbstractAutoProxyCreator是SmartInstantiationAwareBeanPostProcessor的一个抽象实现，其getEarlyBeanReference的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">	Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line">	<span class="keyword">this</span>.earlyProxyReferences.put(cacheKey, bean);</span><br><span class="line">   <span class="comment">// 必要时包装给定的bean，例如，如果它符合被代理的条件。</span></span><br><span class="line">	<span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它也实现了BeanPostProcessor接口。</p>
</li>
</ul>
<h1 id="5-TypeConverter"><a href="#5-TypeConverter" class="headerlink" title="5. TypeConverter"></a>5. TypeConverter</h1><p>SimpleTypeConverter</p>
<h1 id="TypeConverterDelegate"><a href="#TypeConverterDelegate" class="headerlink" title="TypeConverterDelegate"></a>TypeConverterDelegate</h1><ul>
<li>用于将属性值转换为目标类型的内部助手类。</li>
</ul>
<hr>
<blockquote>
<p>内容来源：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZhangZiSheng001/p/13196228.html">Spring源码系列(二)–bean组件的源码分析</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/jyxmust/article/details/82562242">SPI 与 API的区别</a></li>
</ul>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.coder.love/2021/08/29/Spring-Transaction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="青马流光">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="青马流光的博客">
      <meta itemprop="description" content="学习笔记">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 青马流光的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/29/Spring-Transaction/" class="post-title-link" itemprop="url">Spring 事务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-29 12:13:37" itemprop="dateCreated datePublished" datetime="2021-08-29T12:13:37+08:00">2021-08-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-21 15:28:56" itemprop="dateModified" datetime="2022-03-21T15:28:56+08:00">2022-03-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-Spring事务传播特性"><a href="#1-Spring事务传播特性" class="headerlink" title="1. Spring事务传播特性"></a>1. Spring事务传播特性</h1><ul>
<li><p>@Transactional.propagation</p>
</li>
<li><p>enum Propagation</p>
</li>
<li><p>interface TransactionDefinition</p>
</li>
</ul>
<p><strong>REQUIRED</strong></p>
<ul>
<li>支持当前事务，如果不存在则创建一个新事务。</li>
<li>这是事务注解的<strong>默认</strong>设置。</li>
</ul>
<p><strong>SUPPORTS</strong></p>
<ul>
<li>支持当前事务，如果不存在则以非事务方式执行。</li>
<li>注意：对于具有事务同步的事务管理器， SUPPORTS与根本没有事务略有不同，因为它定义了同步将应用的事务范围。 因此，相同的资源（JDBC 连接、Hibernate 会话等）将在整个指定范围内共享。 请注意，这取决于事务管理器的实际同步配置。</li>
<li>See Also:<br>org.springframework.transaction.support.AbstractPlatformTransactionManager.setTransactionSynchronization</li>
</ul>
<p><strong>MANDATORY</strong></p>
<ul>
<li>支持当前事务，如果不存在则抛出异常。</li>
</ul>
<p><strong>REQUIRES_NEW</strong></p>
<ul>
<li>创建一个新事务，如果存在，则暂停当前事务。</li>
<li>注意：实际的事务暂停不会在所有事务管理器上开箱即用。 这尤其适用于org.springframework.transaction.jta.JtaTransactionManager ，它需要javax.transaction.TransactionManager对其可用（这在标准 Java EE 中是特定于服务器的）。</li>
<li>See Also:<br>org.springframework.transaction.jta.JtaTransactionManager.setTransactionManager</li>
<li>场景：比如现在有一段业务代码，方法 A 调用方法 B，我希望的是如果方法 A 出错了，此时仅仅回滚方法 A，不能回滚方法 B，这个时候可以给方法 B 使用 REQUIRES_NEW 传播机制，让他们两的事务是不同的。</li>
</ul>
<p><strong>NOT_SUPPORTED</strong></p>
<ul>
<li>以非事务方式执行，如果存在则暂停当前事务。</li>
<li>注意：实际的事务暂停不会在所有事务管理器上开箱即用。 这尤其适用于org.springframework.transaction.jta.JtaTransactionManager ，它需要javax.transaction.TransactionManager对其可用（这在标准 Java EE 中是特定于服务器的）。</li>
<li>See Also:<br>org.springframework.transaction.jta.JtaTransactionManager.setTransactionManager</li>
</ul>
<p><strong>NEVER</strong></p>
<ul>
<li>以非事务方式执行，如果存在事务则抛出异常。</li>
</ul>
<p><strong><font color='FF0000'>NESTED</font></strong></p>
<ul>
<li>如果当前事务存在，则在一个嵌套事务中执行，否则行为类似于REQUIRED 。<ul>
<li>嵌套事务：是指外层的事务如果回滚，会导致内层的事务也回滚；但是内层的事务如果回滚，仅仅是滚回自己的代码。</li>
</ul>
</li>
<li>注意：嵌套事务的实际创建仅适用于特定的事务管理器。 开箱即用，这仅适用于 JDBC DataSourceTransactionManager。 一些 JTA 提供者也可能支持嵌套事务。</li>
<li>See Also:<br>org.springframework.jdbc.datasource.DataSourceTransactionManager</li>
<li>场景：如果方法 A 调用方法 B，如果出错，方法 B 只能回滚它自己，方法 A 可以带着方法 B 一起回滚。那这种情况可以给方法 B 加上 NESTED 嵌套事务。</li>
</ul>
<blockquote>
<p>Y：也许主要使用REQUIRED与NESTED。</p>
</blockquote>
<p>除了事务的传播行为外，事务的其他特性Spring是借助底层资源的功能来完成的，Spring无非只充当个代理的角色。但是事务的传播行为却是Spring凭借自身的框架提供的功能。</p>
<p><strong>在同一个类中，一个方法调用另外一个有注解（比如@Async，@Transational）的方法，注解是不会生效的</strong></p>
<p>代码示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 例子中，有两方法，一个有<span class="doctag">@Transational</span>注解，一个没有。如果调用了有注解的addPerson()方法，会启动一个Transaction；如果调用 </span></span><br><span class="line"><span class="comment"> * updatePersonByPhoneNo()，因为它内部调用了有注解的addPerson()，如果你以为系统也会为它启动一个Transaction，那就错了，实际上是没有的。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonServiceImpl</span> <span class="keyword">implements</span> <span class="title">PersonService</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line"> PersonDao personDao;</span><br><span class="line"> </span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="meta">@Transactional</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addPerson</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> result = personDao.insertPerson(person)&gt;<span class="number">0</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="comment">//@Transactional</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updatePersonByPhoneNo</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> result = personDao.updatePersonByPhoneNo(person)&gt;<span class="number">0</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">  addPerson(person); <span class="comment">//测试同一个类中@Transactional是否起作用</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原因：</strong></p>
<p>Spring 在扫描bean的时候会扫描方法上是否包含@Transactional注解，如果包含，spring会为这个bean动态地生成一个子类（即代理类，proxy），代理类是继承原来那个bean的。此时，当这个有注解的方法被调用的时候，实际上是由代理类来调用的，<strong>代理类在调用之前就会启动transaction</strong>。然而，<strong>如果这个有注解的方法是被同一个类中的其他方法调用的，那么该方法的调用并没有通过代理类，而是直接通过原来的那个bean，所以就不会启动transaction</strong>，我们看到的现象就是@Transactional注解无效。</p>
<p><strong>为什么一个方法a()调用同一个类中另外一个方法b()的时候，b()不是通过代理类来调用的呢？</strong>可以看下面的例子（为了简化，用伪代码表示）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="meta">@Transactinal</span></span><br><span class="line">    <span class="function">method <span class="title">b</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">method <span class="title">a</span><span class="params">()</span></span>&#123;    <span class="comment">//标记1</span></span><br><span class="line">        b();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Spring扫描注解后，创建了另外一个代理类，并为有注解的方法插入一个startTransaction()方法：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">proxy</span>$<span class="title">A</span></span>&#123;</span><br><span class="line">    A objectA = <span class="keyword">new</span> A();</span><br><span class="line">    <span class="function">method <span class="title">b</span><span class="params">()</span></span>&#123;    <span class="comment">//标记2</span></span><br><span class="line">        startTransaction();</span><br><span class="line">        objectA.b();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">method <span class="title">a</span><span class="params">()</span></span>&#123;    <span class="comment">//标记3</span></span><br><span class="line">        objectA.a();    <span class="comment">//由于a()没有注解，所以不会启动transaction，而是直接调用A的实例的a()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决的方法（两种）：</strong></p>
<ol>
<li>把这两个方法分开到不同的类中；</li>
<li>把注解加到类名上面。</li>
</ol>
<p><strong>结论:</strong></p>
<p>在一个Service内部，事务方法之间的嵌套调用，普通方法和事务方法之间的嵌套调用，都不会开启新的事务。</p>
<ol>
<li><p>Spring采用动态代理机制来实现事务控制，而动态代理最终都是要调用原始对象的，而原始对象在去调用方法时，是不会再触发代理了！</p>
</li>
<li><p>Spring的事务管理是通过AOP实现的，其AOP的实现对于非final类是通过cglib这种方式，即生成当前类的一个子类作为代理类，然后在调用其下的方法时，会判断这个方法有没有@Transactional注解，如果有的话，则通过动态代理实现事务管理(拦截方法调用，执行事务等切面)。当b()中调用a()时，发现b()上并没有@Transactional注解，所以整个AOP代理过程(事务管理)不会发生。</p>
</li>
</ol>
<p><strong>使用AOP 代理后的方法调用执行流程：</strong></p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/%E4%BD%BF%E7%94%A8AOP%20%E4%BB%A3%E7%90%86%E5%90%8E%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="img"></p>
<h2 id="1-2-理解Spring框架事务抽象"><a href="#1-2-理解Spring框架事务抽象" class="headerlink" title="1.2 理解Spring框架事务抽象"></a>1.2 理解Spring框架事务抽象</h2><p>Spring事务抽象的关键是事务策略的概念。事务策略是由一个TransactionManager定义的，特别是</p>
<ul>
<li>用于Servlet事务管理的org.springframework.transaction.PlatformTransactionManager接口</li>
<li>用于响应式事务管理的org.springframework.transaction.ReactiveTransactionManager接口</li>
</ul>
<p>下面的清单显示了PlatformTransactionManager API的定义:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> <span class="keyword">extends</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReactiveTransactionManager</span> <span class="keyword">extends</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Mono&lt;ReactiveTransaction&gt; <span class="title">getReactiveTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Mono&lt;Void&gt; <span class="title">commit</span><span class="params">(ReactiveTransaction status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Mono&lt;Void&gt; <span class="title">rollback</span><span class="params">(ReactiveTransaction status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-声明式事务管理"><a href="#1-3-声明式事务管理" class="headerlink" title="1.3 声明式事务管理"></a>1.3 声明式事务管理</h2><p>Spring框架的TransactionInterceptor为命令式和响应式编程模型提供了事务管理。拦截器通过检查方法返回类型来检测所需的事务管理风格。返回响应类型(如Publisher或Kotlin Flow)的方法(或它们的子类型)符合响应事务管理的条件。包括void在内的所有其他返回类型都使用命令事务管理的代码路径。</p>
<p>事务管理风格会影响需要哪个事务管理器。命条式事务需要一个PlatformTransactionManager，而响应式事务使用ReactiveTransactionManager实现。</p>
<blockquote>
<p>@Transactional通常使用PlatformTransactionManager管理的线程绑定事务，将事务暴露给当前执行线程中的所有数据访问操作。注意:这不会传播到方法中新启动的线程。</p>
<p><code>ReactiveTransactionManager</code>管理的反应式事务使用Reactor上下文而不是线程本地属性。因此，所有参与的数据访问操作都需要在同一响应管道中的同一Reactor上下文中执行。</p>
</blockquote>
<p>下图展示了在事务代理上调用方法的概念视图:</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/tx.png" alt="tx"></p>
<h2 id="1-4-事务传播"><a href="#1-4-事务传播" class="headerlink" title="1.4 事务传播"></a>1.4 事务传播</h2><p>在Spring管理的事务中，注意物理事务和逻辑事务之间的差异，以及传播设置如何适用于此差异。</p>
<h5 id="理解PROPAGATION-REQUIRED"><a href="#理解PROPAGATION-REQUIRED" class="headerlink" title="理解PROPAGATION_REQUIRED"></a>理解<code>PROPAGATION_REQUIRED</code></h5><p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/tx_prop_required.png" alt="需要tx道具"></p>
<p><code>PROPAGATION_REQUIRED</code>执行物理事务，如果不存在事务，则在本地为当前范围执行，或参与为更大范围定义的现有“外”事务。这是同一线程中常见调用堆栈安排中的良好默认值（例如，将服务立面委托给多个存储库方法，所有基础资源都必须参与服务级事务）。</p>
<h5 id="理解PROPAGATION-REQUIRES-NEW"><a href="#理解PROPAGATION-REQUIRES-NEW" class="headerlink" title="理解PROPAGATION_REQUIRES_NEW"></a>理解<code>PROPAGATION_REQUIRES_NEW</code></h5><p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/tx_prop_requires_new.png" alt="tx道具需要新的"></p>
<h1 id="2-Transactional的其它属性"><a href="#2-Transactional的其它属性" class="headerlink" title="2. @Transactional的其它属性"></a>2. @Transactional的其它属性</h1><p><strong>isolation 属性</strong></p>
<p>事务的隔离级别，默认值为 Isolation.DEFAULT。可选的值有：</p>
<ul>
<li>Isolation.DEFAULT：使用底层数据库默认的隔离级别</li>
<li>Isolation.READ_UNCOMMITTED：读取未提交数据（会出现脏读，不可重复读）基本不使用</li>
<li>Isolation.READ_COMMITTED：读取已提交数据（会出现不可重复读和幻读）</li>
<li>Isolation.REPEATABLE_READ：可重复读（会出现幻读）</li>
<li>Isolation.SERIALIZABLE：串行化</li>
</ul>
<p><strong>timeout 属性</strong></p>
<p>事务的超时时间，默认值为 -1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</p>
<p><strong>readOnly 属性</strong></p>
<p>指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。</p>
<p><strong>rollbackFor 属性</strong></p>
<p>用于指定能够触发事务回滚的异常类型，可以指定多个异常类型。</p>
<p><strong>noRollbackFor 属性</strong></p>
<p>抛出指定的异常类型，不回滚事务，也可以指定多个异常类型。</p>
<hr>
<blockquote>
<p>内容来源：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/157646604">Spring 的事务实现原理和传播机制</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#spring-data-tier">Spring框架文档</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/levae1024/article/details/82998386">Spring事务管理嵌套事务详解 : 同一个类中，一个方法调用另外一个有事务的方法</a></li>
</ul>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.coder.love/2021/08/26/Spring-AOP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="青马流光">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="青马流光的博客">
      <meta itemprop="description" content="学习笔记">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 青马流光的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/26/Spring-AOP/" class="post-title-link" itemprop="url">Spring-AOP</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-26 08:44:07" itemprop="dateCreated datePublished" datetime="2021-08-26T08:44:07+08:00">2021-08-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-21 15:26:57" itemprop="dateModified" datetime="2022-03-21T15:26:57+08:00">2022-03-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>@EnableAspectJAutoProxy -&gt; @Import(AspectJAutoProxyRegistrar.class) -&gt; 注册一个适当的AnnotationAwareAspectJAutoProxyCreator 的BeanDefinition。</p>
<p>-&gt; 经过IOC</p>
<p>advice：通知，即增强。</p>
<p>advisor：advice的载体。</p>
<p>spring实现AOP思路:</p>
<p>1： 创建<code>AnnotationAwareAspectJAutoProxyCreator</code>对象</p>
<p>2： 扫描容器中的切面，创建<code>PointcutAdvisor</code>对象<br>3： 生成代理类</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hjMTIzX2phdmE=,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<p>AbstractAutoProxyCreator中实现的postProcessBeforeInstantiation与postProcessAfterInitialization。</p>
<p>postProcessBeforeInstantiation</p>
<p>-&gt; createProxy</p>
<p>postProcessAfterInitialization：如果 bean 被子类标识为代理，则使用配置的拦截器创建一个代理。</p>
<p>-&gt; wrapIfNecessary</p>
<p>-&gt; createProxy</p>
<p>ProxyFactory：AOP 代理工厂，以编程的方式使用，而不是通过 bean 工厂中的声明式设置。 此类提供了一种在自定义用户代码中获取和配置 AOP 代理实例的简单方法。</p>
<ul>
<li>Spring并没有提供其它的实现类。</li>
</ul>
<p>AopProxyFactory</p>
<p>由能够基于AdvisedSupport配置对象创建 AOP 代理的工厂实现的接口。<br>代理人应遵守以下合同：</p>
<ul>
<li>它们应该实现配置指示应该被代理的所有接口。</li>
<li>他们应该实现Advised接口。</li>
<li>他们应该实现 equals 方法来比较代理接口、通知和目标。</li>
<li>如果所有顾问程序和目标都是可序列化的，则它们应该是可序列化的。</li>
<li>如果顾问和目标是线程安全的，它们应该是线程安全的。<br>代理可能允许也可能不允许更改建议。 如果他们不允许建议更改（例如，因为配置被冻结），代理应该在尝试更改建议时抛出AopConfigException 。</li>
</ul>
<p>Spring中只有一个实现类DefaultAopProxyFactory。</p>
<p><strong>DefaultAopProxyFactory</strong></p>
<p>默认AopProxyFactory实现，创建 CGLIB 代理或 JDK 动态代理。<br>如果对于给定的AdvisedSupport实例满足以下任一条件，则创建 CGLIB 代理：</p>
<ul>
<li>optimize标志已设置</li>
<li>设置了proxyTargetClass标志</li>
<li>没有指定代理接口<br>通常，指定proxyTargetClass以强制执行 CGLIB 代理，或指定一个或多个接口以使用 JDK 动态代理。</li>
</ul>
<p>createAopProxy</p>
<p>AopProxy</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/image-20210826222938687.png" alt="image-20210826222938687"></p>
<p>Proxy</p>
<p>Proxy提供了创建动态代理类和实例的静态方法，它也是由这些方法创建的所有动态代理类的超类。</p>
<p>java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。</p>
<p>而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</p>
<p>1、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP<br>2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP </p>
<p>3、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换</p>
<p>JDK动态代理和CGLIB字节码生成的区别？<br> （1）JDK动态代理只能对实现了接口的类生成代理，而不能针对类<br> （2）CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法<br>  因为是继承，所以该类或方法最好不要声明成final </p>
<p>创建的代理类是怎么使用上的呢？</p>
<p>AbstractAutowireCapableBeanFactory</p>
<ul>
<li>initializeBean<ul>
<li>applyBeanPostProcessorsBeforeInitialization</li>
<li>invokeInitMethods</li>
<li>applyBeanPostProcessorsAfterInitialization</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">		Object result = existingBean;</span><br><span class="line">		<span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="comment">// 返回的对象替换了原对象，代理类是在这时候完成的替换。</span></span><br><span class="line">			Object current = processor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">			<span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> result;</span><br><span class="line">			&#125;</span><br><span class="line">			result = current;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">		Object result = existingBean;</span><br><span class="line">		<span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line">			Object current = processor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">			<span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> result;</span><br><span class="line">			&#125;</span><br><span class="line">			result = current;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>







<p>Filter 与 Interceptor 的区别。</p>
<p>HandlerInterceptor基本上类似于Servlet Filter，但与后者相比，它只允许自定义预处理(禁止处理程序本身的执行)和自定义后处理。过滤器更强大，例如，它们允许交换链下传递的请求和响应对象。注意，过滤器是在web.xml中配置的，这是应用程序上下文中的HandlerInterceptor。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jichi/p/12805719.html">filter和interceptor的区别</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zxd1435513775/article/details/80556034">拦截器（Interceptor）和过滤器（Filter）的执行顺序和区别</a></p>
<p>filter的执行在interceptor之前。</p>
<p>该图仅供参考，感觉并不是很准确。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/70.png" alt="这里写图片描述"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		HttpServletRequest processedRequest = request;</span><br><span class="line">		HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">		WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">			Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				processedRequest = checkMultipart(request);</span><br><span class="line">				multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Determine handler for the current request.</span></span><br><span class="line">        <span class="comment">// 获取当前request的handler</span></span><br><span class="line">				mappedHandler = getHandler(processedRequest);</span><br><span class="line">				<span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">					noHandlerFound(processedRequest, response);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">				HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">				String method = request.getMethod();</span><br><span class="line">				<span class="keyword">boolean</span> isGet = <span class="string">&quot;GET&quot;</span>.equals(method);</span><br><span class="line">				<span class="keyword">if</span> (isGet || <span class="string">&quot;HEAD&quot;</span>.equals(method)) &#123;</span><br><span class="line">					<span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">					<span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 应用所有注册拦截器的 preHandle 方法，若其中一个返回false则中断返回。</span></span><br><span class="line">				<span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Actually invoke the handler.</span></span><br><span class="line">				mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				applyDefaultViewName(processedRequest, mv);</span><br><span class="line">				mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">				dispatchException = ex;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">				<span class="comment">// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,</span></span><br><span class="line">				<span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">				dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">&quot;Handler dispatch failed&quot;</span>, err);</span><br><span class="line">			&#125;</span><br><span class="line">			processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">			triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">					<span class="keyword">new</span> NestedServletException(<span class="string">&quot;Handler processing failed&quot;</span>, err));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">				<span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">				<span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">					mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">				<span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">					cleanupMultipart(processedRequest);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>Filter什么时候调用的？</p>
<p>嵌入服务器，如tomcat的ApplicationDispatcher。</p>
<p>doDispatch</p>
<p>-&gt;invoke</p>
<p>-&gt; </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ApplicationFilterChain filterChain =</span><br><span class="line">                ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">if</span> ((servlet != <span class="keyword">null</span>) &amp;&amp; (filterChain != <span class="keyword">null</span>)) &#123;</span><br><span class="line">               filterChain.doFilter(request, response);</span><br><span class="line">             &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">internalDoFilter</span><br><span class="line">filter.doFilter(request, response, this);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">servlet.service(request, response);</span><br></pre></td></tr></table></figure>

<ul>
<li>Filter &amp; HandlerInterceptoer &amp; MethodInterceptor</li>
</ul>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/guyue35/article/details/104658234">https://blog.csdn.net/guyue35/article/details/104658234</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.coder.love/2021/08/22/Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="青马流光">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="青马流光的博客">
      <meta itemprop="description" content="学习笔记">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 青马流光的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/22/Redis/" class="post-title-link" itemprop="url">Redis</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-22 09:44:22" itemprop="dateCreated datePublished" datetime="2021-08-22T09:44:22+08:00">2021-08-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-21 15:25:28" itemprop="dateModified" datetime="2022-03-21T15:25:28+08:00">2022-03-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-Redis-数据类型"><a href="#1-Redis-数据类型" class="headerlink" title="1. Redis 数据类型"></a>1. Redis 数据类型</h1><p>Redis 不是一个<em>普通的</em>键值存储，它实际上是一个<em>数据结构服务器</em>，支持不同类型的值。这意味着，在传统的键值存储中，您将字符串键与字符串值相关联，而在 Redis 中，值不仅限于简单的字符串，还可以包含更复杂的数据结构。以下是Redis支持的所有数据结构的列表：</p>
<ul>
<li>Binary-safe strings。</li>
<li>Lists</li>
<li>Sets</li>
<li>Sorted sets</li>
<li>Hashes</li>
<li>Bit arrays (or simply bitmaps)</li>
<li>HyperLogLogs</li>
<li>Streams</li>
</ul>
<h2 id="1-0-Redis-键（非数据类型）"><a href="#1-0-Redis-键（非数据类型）" class="headerlink" title="1.0 Redis 键（非数据类型）"></a>1.0 Redis 键（非数据类型）</h2><p>Redis 键是<strong>二进制安全</strong>的，这意味着您可以使用任何二进制序列作为键，从像“foo”这样的字符串到 JPEG 文件的内容。空字符串也是一个有效的键。</p>
<p>关于key的其他一些规则：</p>
<ul>
<li>很长的键不是一个好主意。例如，1024 字节的键不仅在内存方面是个坏主意，而且因为在数据集中查找键可能需要多次昂贵的键比较。即使手头的任务是匹配一个大值的存在，对其进行散列（例如使用 SHA1）也是一个更好的主意，尤其是从内存和带宽的角度来看。</li>
<li>很短的键通常不是一个好主意。如果您可以改写成“user:1000:followers”，那么将“u1000flw”写为键就没有什么意义了。前者更具可读性，与键对象本身和值对象使用的空间相比，增加的空间较小。虽然短键显然会消耗更少的内存，但您的工作是找到正确的平衡点。</li>
<li>尝试坚持使用一种模式。例如“object-type:id”是个好主意，如“user:1000”。点或破折号通常用于多词字段，如“comment:234:reply.to”或“comment:234:reply-to”。</li>
<li>允许的最大key大小为 512 MB。</li>
</ul>
<blockquote>
<p><strong>SHA-1</strong>是一种安全散列算法，SHA-1可以生成一个被称为消息摘要的160位（20字节）散列值，散列值通常的呈现形式为40个十六进制数。</p>
</blockquote>
<p>有些命令没有在特定类型上定义，但对于与键空间交互很有用，因此可以与任何类型的键一起使用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> mykey hello</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如，EXISTS 命令返回 1 或 0 以表示数据库中是否存在给定的键</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> exists mykey</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 还有TYPE命令，它返回存储在指定键上的值的种类</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">type</span> mykey</span></span><br><span class="line">string</span><br><span class="line"><span class="meta">#</span><span class="bash"> 而DEL 命令删除键和关联的值，无论值是什么。</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> del mykey</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> exists mykey</span></span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">type</span> mykey</span></span><br><span class="line">none</span><br></pre></td></tr></table></figure>

<h3 id="Redis-过期：生存时间有限的键"><a href="#Redis-过期：生存时间有限的键" class="headerlink" title="Redis 过期：生存时间有限的键"></a>Redis 过期：生存时间有限的键</h3><p>基本上，您可以为key设置超时，这是有限的生存时间。当生存时间结束时，key会自动销毁，就像用户使用key调用DEL命令一样。</p>
<p>关于 Redis 过期的一些快速信息：</p>
<ul>
<li>它们可以使用秒或毫秒精度进行设置；</li>
<li>但是，过期时间<strong>分辨率</strong>始终为 <strong>1 毫秒</strong>；</li>
<li>有关过期的信息被复制并保存在磁盘上，当您的 Redis 服务器保持停止状态时，时间实际上已经过去了（这意味着 Redis 会保存key的过期日期）。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> key some-value</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置过期</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> expire key 5</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> get key (immediately)</span></span><br><span class="line">&quot;some-value&quot;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> get key (after some time)</span></span><br><span class="line">(nil)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以使用其他 Redis 命令创建带有过期时间的键。expire 单位是秒，对应pexpire是毫秒。</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> key 100 ex 10</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看剩余过期时间，单位是秒，对应pttl是毫秒</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ttl key</span></span><br><span class="line">(integer) 9</span><br></pre></td></tr></table></figure>

<h3 id="自动删除和创建key"><a href="#自动删除和创建key" class="headerlink" title="自动删除和创建key"></a>自动删除和创建key</h3><p>当列表为空时，Redis会负责删除该键；如果键不存在，而我们又试图添加元素到它，Redis会负责创建一个空列表。这并不是特定于列表，它适用于所有由多个元素组成的Redis数据类型——Streams, Sets, Sorted Sets and Hashes。</p>
<p>基本上，我们可以用三条规则来总结这种行为:</p>
<ul>
<li>在向聚合数据类型添加元素时，如果目标键不存在，则在添加元素之前创建一个空的聚合数据类型。</li>
<li>当从聚合数据类型中删除元素时，如果值仍然为空，则自动销毁键。Stream数据类型是此规则的唯一例外。</li>
<li>调用只读命令，如LLEN(它返回列表的长度)，或使用空键删除元素的write命令，总是产生与该键持有命令期望查找的空聚合类型相同的结果。</li>
</ul>
<p>常用的五种数据结构：</p>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/1289934-20190621163930814-1395015700.png" alt="img" style="zoom: 67%;" />

<h2 id="1-1-Redis-Strings"><a href="#1-1-Redis-Strings" class="headerlink" title="1.1 Redis Strings"></a>1.1 Redis Strings</h2><p>Redis 字符串类型是您可以与 Redis 键关联的最简单的值类型。String类型是二进制安全的，可以是各种字符串（包括二进制数据），例如您可以在值中存储 jpeg 图像。值不能大于 512 MB。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> mykey somevalue</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> get mykey</span></span><br><span class="line">&quot;somevalue&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> nx 选项，如果键已经存在，则<span class="built_in">set</span>失败。</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> mykey newval nx</span></span><br><span class="line">(nil)</span><br><span class="line"><span class="meta">#</span><span class="bash"> xx 选项，只有键已经村子，才会成功。</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> mykey newval xx</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> 即使字符串是 Redis 的基本值，您也可以使用它们执行一些	有趣的操作。例如，一个原子增量：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">set</span> counter 100</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> incr counter</span></span><br><span class="line">(integer) 101</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> incr counter</span></span><br><span class="line">(integer) 102</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> incrby counter 50</span></span><br><span class="line">(integer) 152</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在单个命令中设置或检索多个键的值的能力对于减少延迟也很有用。出于这个原因，有MSET和MGET命令：</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> mset a 10 b 20 c 30</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> mget a b c</span></span><br><span class="line">1) &quot;10&quot;</span><br><span class="line">2) &quot;20&quot;</span><br><span class="line">3) &quot;30&quot;</span><br></pre></td></tr></table></figure>

<h3 id="实战场景"><a href="#实战场景" class="headerlink" title="实战场景"></a>实战场景</h3><ol>
<li>缓存： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。</li>
<li>计数器：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。</li>
<li>session：常见方案spring session + redis实现session共享。</li>
</ol>
<h2 id="1-2-Redis-Lists"><a href="#1-2-Redis-Lists" class="headerlink" title="1.2 Redis Lists"></a>1.2 Redis Lists</h2><p>Redis 列表是通过链表实现的。这意味着即使列表中有数百万个元素，在列表的头部或尾部添加新元素的操作也是<em>在常数时间内</em>执行的。使用<a target="_blank" rel="noopener" href="https://redis.io/commands/lpush">LPUSH</a>命令在10个元素的列表头添加一个新元素的速度与在1000万个元素的列表头添加一个元素的速度是一样的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> rpush mylist A</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> RPUSH命令在右侧（在尾部）向列表中添加一个新元素</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> rpush mylist B</span></span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta">#</span><span class="bash"> LPUSH命令在左侧（头部）向列表中添加一个新元素</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> lpush mylist first</span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta">#</span><span class="bash"> 请注意，LRANGE需要两个索引，即要返回的范围的第一个和最后一个元素。两个索引都可以是负数，告诉 Redis 从末尾开始计数：所以 -1 是最后一个元素，-2 是列表的倒数第二个元素，依此类推。</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> lrange mylist 0 -1</span></span><br><span class="line">1) &quot;first&quot;</span><br><span class="line">2) &quot;A&quot;</span><br><span class="line">3) &quot;B&quot;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> rpush mylist 1 2 3 4 5 <span class="string">&quot;foo bar&quot;</span></span></span><br><span class="line">(integer) 9</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> rpush mylist a b c</span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta">#</span><span class="bash"> 从右侧弹出元素</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> rpop mylist</span></span><br><span class="line">&quot;foo bar&quot;</span><br></pre></td></tr></table></figure>

<h3 id="列表的常见用例"><a href="#列表的常见用例" class="headerlink" title="列表的常见用例"></a>列表的常见用例</h3><p>列表对许多任务有用，以下两个非常有代表性的用例：</p>
<ul>
<li>记住用户发布到社交网络的最新更新。</li>
<li>进程之间的通信，使用消费者-生产者模式，将项目推入列表，消费者（通常是<em>工人</em>）消费这些项目并执行操作。Redis有特殊的列表命令，使此用例更加可靠和高效。</li>
</ul>
<p>例如，流行的Ruby库resque和sidekiq都在幕后使用Redis列表来实现后台任务。</p>
<p>流行的Twitter社交网络将用户发布的最新推文放到Redis列表中。</p>
<p>为了一步一步地描述一个常用的用例，假设您的主页显示了在照片分享社交网络中发布的最新照片，并且您希望加快访问速度。</p>
<ul>
<li>每当用户发布一张新照片时，我们就使用LPUSH将其ID添加到列表中。</li>
<li>当用户访问主页时，我们使用<code>LRANGE 0 9</code>来获取最新的10个发布项目。</li>
</ul>
<h3 id="上限列表"><a href="#上限列表" class="headerlink" title="上限列表"></a>上限列表</h3><p>在许多用例中，我们只想使用列表来存储<em>最新项目</em>，无论它们是：社交网络更新、日志或其他任何东西。</p>
<p>Redis允许我们使用列表作为带上限的集合，只记住最新的N项，并使用<a target="_blank" rel="noopener" href="https://redis.io/commands/ltrim">LTRIM</a>命令丢弃所有最古老的项。</p>
<p>LTRIM命令类似于LRANGE，但是它不显示指定的元素范围，而是将该范围设置为新的列表值。所有超出给定范围的元素都将被删除。</p>
<p>一个例子将使它更加清晰：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> rpush mylist 1 2 3 4 5</span></span><br><span class="line">(integer) 5</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ltrim mylist 0 2</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> lrange mylist 0 -1</span></span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br></pre></td></tr></table></figure>

<p>上面的LTRIM命令告诉Redis只取索引0到2的列表元素，其他的元素将被丢弃。这允许了一个非常简单但有用的模式:同时执行List push操作和List trim操作，以添加新元素和丢弃超出限制的元素:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPUSH mylist &lt;some element&gt;</span><br><span class="line">LTRIM mylist 0 999</span><br></pre></td></tr></table></figure>

<p>上面的组合添加了一个新元素，并且只接受1000个最新元素到列表中。使用LRANGE，您可以访问最重要的项，而不需要记住非常旧的数据。</p>
<p>注意:虽然LRANGE在技术上是一个O(N)命令，但在列表的头部或尾部访问小范围是一个常数时间操作。</p>
<h3 id="列表上的阻塞操作"><a href="#列表上的阻塞操作" class="headerlink" title="列表上的阻塞操作"></a>列表上的阻塞操作</h3><p>列表有一个特殊功能，使其适合实现队列，通常作为进程间通信系统的基石：阻塞操作。</p>
<p>Redis实现了叫做BRPOP和BLPOP的命令，这是RPOP和LPOP的阻塞版本，如果列表是空的，它们会阻塞:它们只会在列表中添加新元素时返回给调用者，或者当用户指定的超时到达时。</p>
<p>这是一个我们可以在worker中使用的BRPOP调用示例:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> brpop tasks 5</span></span><br><span class="line">1) &quot;tasks&quot;</span><br><span class="line">2) &quot;do_something&quot;</span><br></pre></td></tr></table></figure>

<p>它的意思是:“等待列表任务中的元素，但如果5秒后没有元素可用则返回”。</p>
<p>注意，可以使用0作为超时来永远等待元素，还可以指定多个列表而不是一个，以便同时在多个列表上等待，并在第一个列表接收到元素时获得通知。</p>
<p>关于BRPOP有几点需要注意:</p>
<ul>
<li><strong>客户端以有序的方式被服务</strong>:第一个客户端阻塞等待列表，当某个元素被其他客户端推入时，第一个客户端被服务，以此类推。</li>
<li>返回值与RPOP不同:它是一个<strong>双元素数组，因为它还包括键名</strong>，因为BRPOP和BLPOP能够阻塞等待来自多个列表的元素。</li>
<li>如果超时，则返回NULL。</li>
</ul>
<p>关于列表和阻塞操作，还有更多你应该知道的事情。我们建议你多阅读以下内容:</p>
<ul>
<li>可以使用<a target="_blank" rel="noopener" href="https://redis.io/commands/lmove">LMOVE</a>构建更安全的队列或旋转队列；</li>
<li>该命令还有一个阻塞变体，称为<a target="_blank" rel="noopener" href="https://redis.io/commands/blmove">BLMOVE</a>。</li>
</ul>
<p><strong>LMOVE</strong></p>
<p><strong>原子地</strong>返回并删除存储在<strong>源列表</strong>的第一个/最后一个元素(head/tail取决于wherefrom参数)，并将元素推入存储在<strong>目标列表</strong>的第一个/最后一个元素(head/tail取决于whereto参数)。时间复杂度O(1)。</p>
<p>这个命令代替了现在已弃用的RPOPLPUSH。LMOVE RIGHT LEFT 是等价的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> RPUSH mylist <span class="string">&quot;one&quot;</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> RPUSH mylist <span class="string">&quot;two&quot;</span></span></span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> RPUSH mylist <span class="string">&quot;three&quot;</span></span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> LMOVE mylist myotherlist RIGHT LEFT</span></span><br><span class="line">&quot;three&quot;</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> LMOVE mylist myotherlist LEFT RIGHT</span></span><br><span class="line">&quot;one&quot;</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> LRANGE mylist 0 -1</span></span><br><span class="line">1) &quot;two&quot;</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> LRANGE myotherlist 0 -1</span></span><br><span class="line">1) &quot;three&quot;</span><br><span class="line">2) &quot;one&quot;</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> </span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>模式:可靠队列</strong></p>
<blockquote>
<p>Redis经常被用作消息服务器来实现后台任务或其他类型的消息任务的处理。一种简单的队列形式通常是在生产者端将值压入列表，然后在消费者端使用RPOP(使用轮询)或BRPOP(如果阻塞操作更好地服务客户端)等待该值。</p>
<p>然而，在这种上下文中，获得的队列并不可靠，因为消息可能会丢失，例如，在出现网络问题或消费者刚刚收到消息但仍在处理时崩溃的情况下。</p>
<p>LMOVE(或阻塞变量的BLMOVE)提供了一种避免这个问题的方法:使用者获取消息，同时将其推入<strong>处理列表</strong>。一旦消息被处理，它将使用LREM命令从处理列表中删除消息。</p>
<p>另一个客户端可能会<strong>监视处理列表中停留时间过长的项目</strong>，如果需要，将把那些超时的项目再次推入队列。</p>
<p>Y：通过加一个中间环节来保障未处理元素是可知的。</p>
</blockquote>
</li>
<li><p><strong>模式:循环列表</strong></p>
<blockquote>
<p><strong>使用具有相同源和目标键的LMOVE，客户端可以在O(N)中依次访问N个元素列表的所有元素，而无需使用单个LRANGE操作将整个列表从服务器传输到客户端。</strong></p>
<p>即使有以下两个条件，上面的模式也可以工作:</p>
<ul>
<li>有多个客户端在旋转列表:它们将获取不同的元素，直到列表中的所有元素都被访问并重新启动。<br>即使其他客户端在列表的末尾积极地推送新项目。</li>
<li>上述情况使得实现一个必须由N个工人以尽可能快的速度连续处理一组项的系统变得非常简单。一个例子是一个监控系统，它必须检查一组网站是否可达，以尽可能最小的延迟，使用多个并行工作器。</li>
</ul>
<p>请注意，workers的这种实现可扩展性和可靠性都很低，因为即使消息丢失，该项仍在队列中，并将在下一次迭代时进行处理。</p>
</blockquote>
</li>
</ul>
<p>BLMOVE</p>
<p>BLMOVE是LMOVE的阻塞变体。当source包含元素时，此命令的行为与LMOVE完全相同。当在MULTI/EXEC块中使用时，此命令的行为与LMOVE完全相同。<strong>当源是空的，Redis将阻塞连接</strong>，直到另一个客户端推到它或直到超时(一个双值指定阻塞的最大秒数)达到。timeout值为0可用于无限期阻塞。</p>
<h3 id="使用列表的技巧"><a href="#使用列表的技巧" class="headerlink" title="使用列表的技巧"></a>使用列表的技巧</h3><ul>
<li>lpush+lpop=Stack(栈)</li>
<li>lpush+rpop=Queue（队列）</li>
<li>lpush+ltrim=Capped Collection（有限集合）</li>
<li>lpush+brpop=Message Queue（消息队列）</li>
</ul>
<h3 id="实战场景-1"><a href="#实战场景-1" class="headerlink" title="实战场景"></a>实战场景</h3><p>1.timeline：例如微博的时间轴，有人发布微博，用lpush加入时间轴，展示新的列表信息。</p>
<h2 id="1-3-Redis-Hashes"><a href="#1-3-Redis-Hashes" class="headerlink" title="1.3 Redis Hashes"></a>1.3 Redis Hashes</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> hmset user:1000 username antirez birthyear 1977 verified 1</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> hget user:1000 username</span></span><br><span class="line">&quot;antirez&quot;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> hget user:1000 birthyear</span></span><br><span class="line">&quot;1977&quot;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> hgetall user:1000</span></span><br><span class="line">1) &quot;username&quot;</span><br><span class="line">2) &quot;antirez&quot;</span><br><span class="line">3) &quot;birthyear&quot;</span><br><span class="line">4) &quot;1977&quot;</span><br><span class="line">5) &quot;verified&quot;</span><br><span class="line">6) &quot;1&quot;</span><br></pre></td></tr></table></figure>

<p>虽然哈希用于表示对象很方便，但实际上您可以在哈希中放入的字段的数量没有实际限制(除了可用内存)，因此您可以在应用程序中以许多不同的方式使用哈希。</p>
<p>命令HMSET设置散列的多个字段，而HGET检索单个字段。HMGET与HGET类似，但返回一个值数组:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> hmget user:1000 username birthyear no-such-field</span></span><br><span class="line">1) &quot;antirez&quot;</span><br><span class="line">2) &quot;1977&quot;</span><br><span class="line">3) (nil)</span><br></pre></td></tr></table></figure>

<p>还有一些命令可以对单个字段执行操作，比如HINCRBY:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> hincrby user:1000 birthyear 10</span></span><br><span class="line">(integer) 1987</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> hincrby user:1000 birthyear 10</span></span><br><span class="line">(integer) 1997</span><br></pre></td></tr></table></figure>

<p>您可以在文档中找到<a target="_blank" rel="noopener" href="https://redis.io/commands#hash">散列命令的完整列表</a>。</p>
<p>值得注意的是，小哈希(即带有小值的几个元素)在内存中以特殊的方式编码，这使得它们非常高效。</p>
<h3 id="实战场景-2"><a href="#实战场景-2" class="headerlink" title="实战场景"></a>实战场景</h3><p>1.缓存： 能直观，相比string更节省空间，的维护缓存信息，如用户信息，视频信息等。</p>
<blockquote>
<p>Y: 为什么说比String更节省空间？可能是value分层，避免了key的重复。</p>
</blockquote>
<h2 id="1-4-Redis-Sets"><a href="#1-4-Redis-Sets" class="headerlink" title="1.4 Redis Sets"></a>1.4 Redis Sets</h2><p>Redis集合是无序的字符串集合。SADD命令向集合中添加新元素。还可以对集合执行许多其他操作，比如测试给定元素是否已经存在，执行多个集合之间的交集、并集或差集，等等。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> sadd myset 1 2 3</span></span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta">#</span><span class="bash"> Redis在每次调用时都可以自由地以任何顺序返回元素，因为与用户没有关于元素排序的约定。</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> smembers myset</span></span><br><span class="line">1. 3</span><br><span class="line">2. 1</span><br><span class="line">3. 2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查元素是否存在。</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> sismember myset 3</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> sismember myset 30</span></span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<p><strong>集合适合于表达对象之间的关系</strong>。例如，我们可以很容易地使用set来实现标记。</p>
<p>建模这个问题的一个简单方法是为我们想要标记的每个对象设置一个集合。集合包含与对象关联的标记的id。</p>
<p>其中一个例子是给新闻贴标签。如果文章ID 1000被标记为标签1、2、5和77，一个集合可以将这些标签ID与新闻项目关联起来:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> sadd news:1000:tags 1 2 5 77</span></span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure>

<p>我们也可能想要有相反的关系:所有带有给定标签的新闻列表:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> sadd tag:1:news 1000</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> sadd tag:2:news 1000</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> sadd tag:5:news 1000</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> sadd tag:77:news 1000</span></span><br><span class="line">(integer) 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>获取给定对象的所有标签是很简单的:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> smembers news:1000:tags</span></span><br><span class="line">1. 5</span><br><span class="line">2. 1</span><br><span class="line">3. 77</span><br><span class="line">4. 2</span><br></pre></td></tr></table></figure>

<p>注意:在这个例子中，我们假设你有另一个数据结构，例如一个Redis哈希，它将标签id映射到标签名称。</p>
<p>使用正确的Redis命令还可以轻松实现其他非琐碎的操作。例如，我们可能想要包含标记为1、2、10和27的所有对象的列表。我们可以使用SINTER命令来实现这一点，它执行不同集合之间的交集。我们可以使用:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> sinter tag:1:news tag:2:news tag:10:news tag:27:news</span></span><br><span class="line">... results here ...</span><br></pre></td></tr></table></figure>

<p>除了交集之外，您还可以执行联合、差分、提取随机元素等等。</p>
<p>提取元素的命令称为SPOP，它便于对某些问题建模。例如，为了实现一个基于web的扑克游戏，你可能想要用一组牌来表示你的牌组。假设我们使用一个单字符前缀(C)lubs， (D)iamond， (H)earts， (S)pades:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">  sadd deck C1 C2 C3 C4 C5 C6 C7 C8 C9 C10 CJ CQ CK</span></span><br><span class="line">   D1 D2 D3 D4 D5 D6 D7 D8 D9 D10 DJ DQ DK H1 H2 H3</span><br><span class="line">   H4 H5 H6 H7 H8 H9 H10 HJ HQ HK S1 S2 S3 S4 S5 S6</span><br><span class="line">   S7 S8 S9 S10 SJ SQ SK</span><br><span class="line">   (integer) 52</span><br></pre></td></tr></table></figure>

<p>现在我们想给每个玩家5张牌。<strong>SPOP命令删除一个随机元素，将其返回给客户端</strong>，因此它是本例中的完美操作。</p>
<p>然而，如果我们直接针对牌组调用它，那么在游戏的下一回合中，我们就需要再次填充牌组，这可能并不理想。首先，我们可以复制一套存储在牌组键中的牌组game:1:deck 键。</p>
<p>这是使用<strong>SUNIONSTORE</strong>完成的，它通常执行多个集之间的并集，并将结果存储到另一个集。然而，由于<strong>单个集合的并集是它本身</strong>，我可以用以下方法<strong>复制</strong>我的deck:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> sunionstore game:1:deck deck</span></span><br><span class="line">(integer) 52</span><br></pre></td></tr></table></figure>

<p>现在我准备给第一个玩家五张牌:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> spop game:1:deck</span></span><br><span class="line">&quot;C6&quot;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> spop game:1:deck</span></span><br><span class="line">&quot;CQ&quot;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> spop game:1:deck</span></span><br><span class="line">&quot;D1&quot;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> spop game:1:deck</span></span><br><span class="line">&quot;CJ&quot;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> spop game:1:deck</span></span><br><span class="line">&quot;SJ&quot;</span><br></pre></td></tr></table></figure>

<p>现在是引入set命令的好时机，该命令提供集合中元素的数量。在集合理论的背景下，这通常被称为集合的基数，因此Redis命令被称为SCARD。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> scard game:1:deck</span></span><br><span class="line">(integer) 47</span><br></pre></td></tr></table></figure>

<p>算式是:52 - 5 = 47。</p>
<p>当您需要只获取随机元素而不从集合中删除它们时，有适合该任务的SRANDMEMBER命令。它还具有返回重复和非重复元素的功能。</p>
<h3 id="实战场景-3"><a href="#实战场景-3" class="headerlink" title="实战场景"></a>实战场景</h3><p>1.标签（tag）,给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。</p>
<p>2.点赞，或点踩，收藏等，可以放到set中实现</p>
<h2 id="1-5-Redis-Sorted-sets"><a href="#1-5-Redis-Sorted-sets" class="headerlink" title="1.5 Redis Sorted sets"></a>1.5 Redis Sorted sets</h2><p>排序集是一种数据类型，类似于集合和哈希的混合。与集合一样，排序集合也是由唯一的、非重复的字符串元素组成的，所以在某种意义上，一个排序集合也是一个集合。</p>
<p>然而，尽管集合中的元素不是有序的，但已排序集合中的每个元素都与一个浮点值关联，称为score(这就是为什么该类型也类似于散列，因为每个元素都映射到一个值)。</p>
<p>此外，排序集中的元素是按顺序取的(所以它们不是按请求排序的，顺序是用于表示排序集的数据结构的特性)。它们是按照以下<strong>规则</strong>排列的:</p>
<ul>
<li>如果A和B是两个不同分数的元素，则A &gt; B 如果A.score&gt; B.score。</li>
<li>如果A和B有完全相同的分数，那么A &gt; B如果A字符串在字典顺序上大于B字符串。A和B字符串不能相等，因为排序集只有唯一的元素。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> zadd hackers 1940 <span class="string">&quot;Alan Kay&quot;</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> zadd hackers 1957 <span class="string">&quot;Sophie Wilson&quot;</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> zadd hackers 1953 <span class="string">&quot;Richard Stallman&quot;</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> zadd hackers 1949 <span class="string">&quot;Anita Borg&quot;</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> zadd hackers 1965 <span class="string">&quot;Yukihiro Matsumoto&quot;</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> zadd hackers 1914 <span class="string">&quot;Hedy Lamarr&quot;</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> zadd hackers 1916 <span class="string">&quot;Claude Shannon&quot;</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> zadd hackers 1969 <span class="string">&quot;Linus Torvalds&quot;</span></span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> zadd hackers 1912 <span class="string">&quot;Alan Turing&quot;</span></span></span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<p>正如您所看到的，ZADD类似于SADD，但是有一个附加参数(放在要添加的元素之前)，即分数。ZADD也是可变的，所以您可以自由地指定多个分数-值对，即使在上面的示例中没有使用。</p>
<p>使用排序集，返回一个按出生年份排序的黑客列表是很简单的，因为实际上他们已经排序了。</p>
<p><strong>实现说明</strong>:排序集是通过一个<strong>双端口数据结构</strong>实现的，它包含一个<strong>跳跃表</strong>和一个<strong>哈希表</strong>，所以每次我们<strong>添加</strong>一个元素时，Redis都会执行一个<strong>O(log(N))<strong>操作。这很好，但当我们要求排序元素时，Redis不需要做任何工作，它</strong>已经全部排序</strong>:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> zrange hackers 0 -1</span></span><br><span class="line">1) &quot;Alan Turing&quot;</span><br><span class="line">2) &quot;Hedy Lamarr&quot;</span><br><span class="line">3) &quot;Claude Shannon&quot;</span><br><span class="line">4) &quot;Alan Kay&quot;</span><br><span class="line">5) &quot;Anita Borg&quot;</span><br><span class="line">6) &quot;Richard Stallman&quot;</span><br><span class="line">7) &quot;Sophie Wilson&quot;</span><br><span class="line">8) &quot;Yukihiro Matsumoto&quot;</span><br><span class="line">9) &quot;Linus Torvalds&quot;</span><br></pre></td></tr></table></figure>

<p>注意:0和-1表示从元素索引0到最后一个元素(-1在这里就像在LRANGE命令中一样)。</p>
<p>如果我想按<strong>相反的顺序排列</strong>呢，从最小到最大?使用<strong>ZREVRANGE</strong>代替ZRANGE:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> zrevrange hackers 0 -1</span></span><br><span class="line">1) &quot;Linus Torvalds&quot;</span><br><span class="line">2) &quot;Yukihiro Matsumoto&quot;</span><br><span class="line">3) &quot;Sophie Wilson&quot;</span><br><span class="line">4) &quot;Richard Stallman&quot;</span><br><span class="line">5) &quot;Anita Borg&quot;</span><br><span class="line">6) &quot;Alan Kay&quot;</span><br><span class="line">7) &quot;Claude Shannon&quot;</span><br><span class="line">8) &quot;Hedy Lamarr&quot;</span><br><span class="line">9) &quot;Alan Turing&quot;</span><br></pre></td></tr></table></figure>

<p>也可以使用WITHSCORES参数返回scores:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> zrange hackers 0 -1 withscores</span></span><br><span class="line">1) &quot;Alan Turing&quot;</span><br><span class="line">2) &quot;1912&quot;</span><br><span class="line">3) &quot;Hedy Lamarr&quot;</span><br><span class="line">4) &quot;1914&quot;</span><br><span class="line">5) &quot;Claude Shannon&quot;</span><br><span class="line">6) &quot;1916&quot;</span><br><span class="line">7) &quot;Alan Kay&quot;</span><br><span class="line">8) &quot;1940&quot;</span><br><span class="line">9) &quot;Anita Borg&quot;</span><br><span class="line">10) &quot;1949&quot;</span><br><span class="line">11) &quot;Richard Stallman&quot;</span><br><span class="line">12) &quot;1953&quot;</span><br><span class="line">13) &quot;Sophie Wilson&quot;</span><br><span class="line">14) &quot;1957&quot;</span><br><span class="line">15) &quot;Yukihiro Matsumoto&quot;</span><br><span class="line">16) &quot;1965&quot;</span><br><span class="line">17) &quot;Linus Torvalds&quot;</span><br><span class="line">18) &quot;1969&quot;</span><br></pre></td></tr></table></figure>

<p><strong>操作范围</strong><br>排序集比这个更强大。它们可以在范围内操作。让我们把1950年之前出生的所有人包括在内。我们使用ZRANGEBYSCORE命令来完成:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> zrangebyscore hackers -inf 1950</span></span><br><span class="line">1) &quot;Alan Turing&quot;</span><br><span class="line">2) &quot;Hedy Lamarr&quot;</span><br><span class="line">3) &quot;Claude Shannon&quot;</span><br><span class="line">4) &quot;Alan Kay&quot;</span><br><span class="line">5) &quot;Anita Borg&quot;</span><br></pre></td></tr></table></figure>

<p>我们要求Redis返回所有得分在负无穷到1950之间的元素(包括两个极端)。</p>
<p>还可以删除元素的范围。让我们将所有出生于1940年至1960年之间的黑客从已排序的集合中删除:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> zremrangebyscore hackers 1940 1960</span></span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure>

<p><strong>zremangebyscore</strong>可能不是最好的命令名，但它可能非常有用，并返回删除元素的数量。</p>
<p>为已排序的集合元素定义的另一个非常有用的操作是get-rank操作。可以<strong>询问一个元素在有序元素集合中的排名</strong>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> zrank hackers <span class="string">&quot;Anita Borg&quot;</span></span></span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure>

<p>考虑到按<strong>降序排序</strong>的元素，也可以使用<strong>ZREVRANK</strong>命令来获取排名。</p>
<p><strong>字典序 scores</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> zadd hackers 0 <span class="string">&quot;Alan Kay&quot;</span> 0 <span class="string">&quot;Sophie Wilson&quot;</span> 0 <span class="string">&quot;Richard Stallman&quot;</span> 0</span></span><br><span class="line">  &quot;Anita Borg&quot; 0 &quot;Yukihiro Matsumoto&quot; 0 &quot;Hedy Lamarr&quot; 0 &quot;Claude Shannon&quot;</span><br><span class="line">  0 &quot;Linus Torvalds&quot; 0 &quot;Alan Turing&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> score相同，按字典序排序</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> zrange hackers 0 -1</span></span><br><span class="line">1) &quot;Alan Kay&quot;</span><br><span class="line">2) &quot;Alan Turing&quot;</span><br><span class="line">3) &quot;Anita Borg&quot;</span><br><span class="line">4) &quot;Claude Shannon&quot;</span><br><span class="line">5) &quot;Hedy Lamarr&quot;</span><br><span class="line">6) &quot;Linus Torvalds&quot;</span><br><span class="line">7) &quot;Richard Stallman&quot;</span><br><span class="line">8) &quot;Sophie Wilson&quot;</span><br><span class="line">9) &quot;Yukihiro Matsumoto&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用ZRANGEBYLEX，我们可以使用字典序范围查询:</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> zrangebylex hackers [B [P</span></span><br><span class="line">1) &quot;Claude Shannon&quot;</span><br><span class="line">2) &quot;Hedy Lamarr&quot;</span><br><span class="line">3) &quot;Linus Torvalds&quot;</span><br></pre></td></tr></table></figure>

<p><strong>更新分数:排行榜</strong></p>
<p>排序集的分数可以在任何时候更新。仅对已包含在已排序集合中的元素调用ZADD，就会以**O(log(N))**时间复杂度更新其分数(和位置)。因此，当有大量更新时，排序集是合适的。</p>
<p>由于这个特点，一个常见的用例是排行榜。典型的应用是Facebook游戏，你可以根据用户的高分来排序，再加上“获得排名”操作，以显示排名前n的用户，以及用户在排行榜上的排名(游戏邦注:例如，“你在这里排名第4932”)。</p>
<h3 id="实战场景-4"><a href="#实战场景-4" class="headerlink" title="实战场景"></a>实战场景</h3><p>1.排行榜：有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行。</p>
<h2 id="1-6-Bitmaps"><a href="#1-6-Bitmaps" class="headerlink" title="1.6 Bitmaps"></a>1.6 Bitmaps</h2><p><strong>位图不是一种实际的数据类型，而是一组定义在String类型上的面向位操作。</strong>因为字符串是二进制安全的blob，它们的最大长度是512 MB，所以它们<strong>适合设置为232个不同的位</strong>。</p>
<p>位操作分为两组:</p>
<ul>
<li>常数时间单位操作，如设置位为1或0，或获取其值。</li>
<li>对位组的操作，例如计算给定位范围内的集合位数(例如population counting)。</li>
</ul>
<p>位图的最大优势之一是，在存储信息时，它们通常可以极大地节省空间。例如，在一个用增量用户id表示不同用户的系统中，只使用512 MB内存就可以记住40亿用户的单个位信息(例如，知道用户是否想要接收时事通讯)。</p>
<p>使用SETBIT和GETBIT命令设置和检索位:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> setbit key 10 1</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> getbit key 10</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> getbit key 11</span></span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>

<p>SETBIT命令的第一个参数是位号，第二个参数是将位设置为1或0的值。如果指定的位超出了当前字符串的长度，该命令将自动扩大字符串。</p>
<p>GETBIT只是返回指定索引处的位的值。超出范围的位(寻址位超出了存储在目标键中的字符串的长度)总是被认为是零。</p>
<p>有三个命令对一组位进行操作:</p>
<ul>
<li>BITOP在不同的字符串之间执行按位操作。提供的操作有AND、OR、XOR和NOT。</li>
<li>BITCOUNT执行人口计数，报告设置为1的位数。</li>
<li>BITPOS查找第一个具有指定值0或1的位。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> setbit key 0 1</span></span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> setbit key 100 1</span></span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> bitcount key</span></span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure>

<p>位图的常见使用情况有:</p>
<ul>
<li>所有类型的实时分析。</li>
<li>存储与对象id相关联的高效且高性能的boolean信息。</li>
</ul>
<p>例如，假设你想知道网站用户每天最长的访问记录。你从零开始计算天数，也就是你公开你的网站的那一天，并且每次用户访问网站的时候都用SETBIT设置一个点。作为位索引，只需取当前unix时间，减去初始偏移量，然后除以一天中的秒数(通常为3600*24)。</p>
<p>这样，每个用户都有一个包含每天访问信息的小字符串。通过BITCOUNT，可以很容易地得到给定用户访问网站的天数，而通过一些BITPOS调用，或简单地获取和分析位图客户端，可以很容易地计算最长连胜。</p>
<p>将位图分割成多个键是很简单的，例如为了分片数据集，因为一般来说最好避免使用大键。要在不同的键之间分割位图，而不是将所有位设置为一个键，一个简单的策略是每个键存储M位，并获得位号为/M的键名和位号为MOD M的键内的第n位地址。</p>
<h2 id="1-7-HyperLogLogs"><a href="#1-7-HyperLogLogs" class="headerlink" title="1.7 HyperLogLogs"></a>1.7 HyperLogLogs</h2><p>HyperLogLog是一种<strong>用于计数唯一事物的概率数据结构</strong>(技术上这是指估计集合的基数)。通常，计算唯一的元素需要使用与你想要计算的元素数量成比例的内存，因为你需要记住你以前见过的元素，以避免多次计算它们。然而，有一套算法是用内存换取精度的:你最终得到的是一个带有标准误差的估计值，在Redis实现的情况下，这个误差小于1%。这个算法的神奇之处在于，您不再需要使用与所计数的项目数量成比例的内存，而是可以使用恒定数量的内存!最坏的情况是12k字节，或者更少，如果你的HyperLogLog(我们现在就叫他们HLL)看到的元素很少。</p>
<p><strong>HLL在Redis中，虽然技术上是一种不同的数据结构，但被编码为一个Redis字符串</strong>，所以你可以调用GET来序列化一个HLL，并调用SET来反序列化它回服务器。</p>
<p>从概念上讲，HLL API就像使用set来完成相同的任务。您可以将每个观察到的元素添加到一个集合中，并使用SCARD检查集合中元素的数量，这是惟一的，因为SADD不会重新添加现有的元素。</p>
<p>因为数据结构只包含一个不包含实际元素的状态，所以你并没有真正地在HLL中添加项，API是相同的:</p>
<ul>
<li>每次看到新元素时，就使用PFADD将其添加到计数中。</li>
<li>每次您想要检索到目前为止使用PFADD添加的惟一元素的当前近似值时，都要使用PFCOUNT。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> pfadd hll a b c d</span></span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> pfcount hll</span></span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure>

<p>这个数据结构的一个用例示例是计算用户每天在搜索表单中执行的唯一查询。</p>
<p>Redis也能够执行联合的hls，请查看完整的文档以获得更多信息。</p>
<h1 id="2-Redis-数据类型的底层实现"><a href="#2-Redis-数据类型的底层实现" class="headerlink" title="2. Redis 数据类型的底层实现"></a>2. Redis 数据类型的底层实现</h1><h2 id="2-1-简单动态字符串"><a href="#2-1-简单动态字符串" class="headerlink" title="2.1 简单动态字符串"></a>2.1 简单动态字符串</h2><p>Redis 没有直接使用 C 语言传统的字符串表示（以空字符结尾的字符数组，以下简称 C 字符串）， 而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型， 并将 SDS 用作 Redis 的默认字符串表示。</p>
<h3 id="SDS-的定义"><a href="#SDS-的定义" class="headerlink" title="SDS 的定义"></a>SDS 的定义</h3><p>sds.h/sdshdr 结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录 buf 数组中已使用字节的数量，等于 SDS 所保存字符串的长度。</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// 记录 buf 数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/qmlg/image-bed/raw/master/images/sds_def.png" alt="buf 保存了字符串信息   free为预留出的空间 len为长度" style="zoom:50%;" />

<h3 id="C-字符串和-SDS-之间的区别"><a href="#C-字符串和-SDS-之间的区别" class="headerlink" title="C 字符串和 SDS 之间的区别"></a>C 字符串和 SDS 之间的区别</h3><table>
<thead>
<tr>
<th>C 字符串</th>
<th>SDS</th>
</tr>
</thead>
<tbody><tr>
<td>获取字符串长度的复杂度为O(N)。</td>
<td>获取字符串长度的复杂度为O(1)。</td>
</tr>
<tr>
<td>API 是不安全的，可能会造成缓冲区溢出。</td>
<td>API 是安全的，不会造成缓冲区溢出。</td>
</tr>
<tr>
<td>修改字符串长度N次必然需要执行N次内存重分配。</td>
<td>修改字符串长度N次最多需要执行N次内存重分配。</td>
</tr>
<tr>
<td>只能保存文本数据。</td>
<td>可以保存文本或者二进制数据。</td>
</tr>
<tr>
<td>可以使用所有&lt;string.h&gt;库中的函数。</td>
<td>可以使用一部分&lt;string.h&gt;库中的函数。</td>
</tr>
</tbody></table>
<p><strong>SDS 减少修改字符串时带来的内存重分配次数</strong></p>
<ul>
<li>空间预分配：通过这种策略， SDS 将连续增长 N 次字符串所需的内存重分配次数从必定 N 次降低为最多 N 次。</li>
<li>惰性空间释放：通过这种策略， SDS 避免了缩短字符串时所需的内存重分配操作， 并为将来可能有的增长操作提供了优化。</li>
</ul>
<p><strong>二进制安全</strong></p>
<ul>
<li>所有 SDS API 都会以处理二进制的方式来处理 SDS 存放在 buf 数组里的数据， 程序不会对其中的数据做任何限制、过滤、或者假设 —— 数据在写入时是什么样的， 它被读取时就是什么样。这也是我们将 SDS 的 buf 属性称为字节数组的原因 —— Redis 不是用这个数组来保存字符， 而是用它来保存一系列二进制数据。</li>
<li>SDS 使用 len 属性的值而不是空字符来判断字符串是否结束。</li>
<li>通过使用二进制安全的 SDS ， 而不是 C 字符串， 使得 Redis 不仅可以保存文本数据， 还可以保存任意格式的二进制数据。</li>
</ul>
<h2 id="2-2-链表"><a href="#2-2-链表" class="headerlink" title="2.2 链表"></a>2.2 链表</h2><p>每个链表节点使用一个 adlist.h/listNode 结构来表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双向链表。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>

<p>虽然仅仅使用多个 listNode 结构就可以组成链表， 但使用 adlist.h/list 来持有链表的话， 操作起来会更方便：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">// 链表所包含的节点数量。</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="comment">// 节点值复制函数，函数用于复制链表节点所保存的值。</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值释放函数，用于释放链表节点所保存的值。</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值对比函数，用于对比链表节点所保存的值和另一个输入值是否相等。</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<p>一个由一个 list 结构和三个 listNode 结构组成的链表：</p>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/1238581-20210213200117107-1518159670.png" alt="img" style="zoom: 67%;" />

<h2 id="2-3-字典"><a href="#2-3-字典" class="headerlink" title="2.3 字典"></a>2.3 字典</h2><p>字典</p>
<ul>
<li>字典， 又称符号表（symbol table）、关联数组（associative array）或者映射（map）， 是一种用于保存键值对（key-value pair）的抽象数据结构。</li>
<li>在字典中， 一个键（key）可以和一个值（value）进行关联（或者说将键映射为值）， 这些关联的键和值就被称为键值对。</li>
<li>字典中的每个键都是独一无二的， 程序可以在字典中根据键查找与之关联的值， 或者通过键来更新值， 又或者根据键来删除整个键值对， 等等。</li>
</ul>
<p>Redis 所使用的 C 语言并没有内置这种数据结构， 因此 Redis 构建了自己的字典实现。</p>
<ul>
<li>字典被广泛用于实现 Redis 的各种功能， 其中包括数据库和哈希键。</li>
<li>Redis 中的字典<strong>使用哈希表作为底层实现</strong>， 每个字典带有<strong>两个哈希表， 一个用于平时使用， 另一个仅在进行 rehash 时使用</strong>。</li>
<li>当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。</li>
<li>哈希表使用<strong>链地址法</strong>来解决键冲突， 被分配到同一个索引上的多个键值对会连接成一个<strong>单向链表</strong>。</li>
<li>在对哈希表进行扩展或者收缩操作时， 程序需要将现有哈希表包含的所有键值对 rehash 到新哈希表里面， 并且这个 rehash 过程并不是一次性地完成的， 而是<strong>渐进式</strong>地完成的。</li>
</ul>
<p>Redis 中的字典由 dict.h/dict 结构表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<ul>
<li>type 属性和 privdata 属性是针对不同类型的键值对， 为创建多态字典而设置的：<ul>
<li>type 属性是一个指向 dictType 结构的指针， 每个 dictType 结构保存了一簇用于操作特定类型键值对的函数， Redis 会为用途不同的字典设置不同的类型特定函数。</li>
<li>而 privdata 属性则保存了需要传给那些类型特定函数的可选参数。</li>
</ul>
</li>
<li>ht 属性是一个包含两个项的数组， 数组中的每个项都是一个 dictht 哈希表， 一般情况下， 字典只使用 ht[0] 哈希表， ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用。<ul>
<li>除了 ht[1] 之外， 另一个和 rehash 有关的属性就是 rehashidx ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 -1 。</li>
</ul>
</li>
</ul>
<p>Redis 字典所使用的哈希表由 dict.h/dictht 结构定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br><span class="line"><span class="comment">//table 属性是一个数组， 数组中的每个元素都是一个指向 dict.h/dictEntry 结构的指针， 每个 dictEntry 结构保存着一个键值对。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>table 属性是一个数组， 数组中的每个元素都是一个指向 dict.h/dictEntry 结构的指针， 每个 dictEntry 结构保存着一个键值对。</li>
<li>size 属性记录了哈希表的大小， 也即是 table 数组的大小， 而 used 属性则记录了哈希表目前已有节点（键值对）的数量。</li>
<li>sizemask 属性的值总是等于 size - 1 ， 这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面。</li>
</ul>
<p><strong>哈希表节点</strong></p>
<ul>
<li>哈希表节点使用 dictEntry 结构表示， 每个 dictEntry 结构都保存着一个键值对。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表，用于冲突链表。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<ul>
<li>key 属性保存着键值对中的键。</li>
<li>v 属性则保存着键值对中的值， 其中键值对的值可以是一个指针， 或者是一个 uint64_t 整数， 又或者是一个 int64_t 整数。</li>
<li>next 属性是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， 以此来解决键冲突（collision）的问题。</li>
</ul>
<p>一个普通状态下（没有进行 rehash）的字典：</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/1238581-20210213200929586-318083919.png" alt="img"></p>
<p><strong>渐进式 rehash</strong></p>
<p>哈希表渐进式 rehash 的详细步骤：</p>
<ol>
<li>为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。</li>
<li>在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。</li>
<li>在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。</li>
<li>随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。</li>
</ol>
<h2 id="2-4-跳跃表"><a href="#2-4-跳跃表" class="headerlink" title="2.4 跳跃表"></a>2.4 跳跃表</h2><h3 id="2-4-1-跳跃表原理"><a href="#2-4-1-跳跃表原理" class="headerlink" title="2.4.1 跳跃表原理"></a>2.4.1 跳跃表原理</h3><p>学过数据结构的都知道，在单链表中查询一个元素的时间复杂度为O(n)，即使该单链表是有序的，我们也不能通过2分的方式缩减时间复杂度。 </p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/20161205210928206.png" alt="这里写图片描述"></p>
<p>   如上图，我们要查询元素为55的结点，必须从头结点，循环遍历到最后一个节点，不算-INF(负无穷)一共查询8次。那么用什么办法能够用更少的次数访问55呢？最直观的，当然是新开辟一条捷径去访问55。 </p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/20161205211105653.png" alt="这里写图片描述"></p>
<p>   如上图，我们要查询元素为55的结点，只需要在L2层查找4次即可。在这个结构中，查询结点为46的元素将耗费最多的查询次数5次。即先在L2查询46，查询4次后找到元素55，因为链表是有序的，46一定在55的左边，所以L2层没有元素46。然后我们退回到元素37，到它的下一层即L1层继续搜索46。非常幸运，我们只需要再查询1次就能找到46。这样一共耗费5次查询。</p>
<p>那么，如何才能更快的搜寻55呢？有了上面的经验，我们就很容易想到，再开辟一条捷径。 </p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/20161205211246498.png" alt="这里写图片描述"></p>
<p>如上图，我们搜索55只需要2次查找即可。这个结构中，查询元素46仍然是最耗时的，需要查询5次。即首先在L3层查找2次，然后在L2层查找2次，最后在L1层查找1次，共5次。很显然，这种思想和2分非常相似，那么我们最后的结构图就应该如下图。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/20161205211539787.png" alt="这里写图片描述"></p>
<p>我们可以看到，最耗时的访问46需要6次查询。即L4访问55，L3访问21、55，L2访问37、55，L1访问46。我们直觉上认为，这样的结构会让查询有序链表的某个元素更快。那么究竟算法复杂度是多少呢？</p>
<p>如果有n个元素，因为是2分，所以层数就应该是log n层 (本文所有log都是以2为底)，再加上自身的1层。以上图为例，如果是4个元素，那么分层为L3和L4，再加上本身的L2，一共3层；如果是8个元素，那么就是3+1层。最耗时间的查询自然是访问所有层数，耗时logn+logn，即2logn。为什么是2倍的logn呢？我们以上图中的46为例，查询到46要访问所有的分层，每个分层都要访问2个元素，中间元素和最后一个元素。所以时间复杂度为O(logn)。</p>
<p>至此为止，我们引入了<strong>最理想的跳跃表</strong>，但是如果想要在上图中插入或者删除一个元素呢？比如我们要插入一个元素22、23、24……，自然在L1层，我们将这些元素插入在元素21后，那么L2层，L3层呢？我们是不是要考虑插入后怎样调整连接，才能维持这个理想的跳跃表结构。我们知道，平衡二叉树的调整是一件令人头痛的事情，左旋右旋左右旋……一般人还真记不住，而调整一个理想的跳跃表将是一个比调整平衡二叉树还复杂的操作。幸运的是，我们并不需要通过复杂的操作调整连接来维护这样完美的跳跃表。<strong>有一种基于概率统计的插入算法，也能得到时间复杂度为O(logn)的查询效率，这种跳跃表才是我们真正要实现的</strong>。</p>
<h4 id="插入过程分析"><a href="#插入过程分析" class="headerlink" title="插入过程分析"></a>插入过程分析</h4><p> 先讨论插入，我们先看理想的跳跃表结构，L2层的元素个数是L1层元素个数的1/2，L3层的元素个数是L2层的元素个数的1/2，以此类推。从这里，我们可以想到，只要<strong>在插入时尽量保证上一层的元素个数是下一层元素的1/2</strong>，我们的跳跃表就能成为理想的跳跃表。那么怎么样才能在插入时保证上一层元素个数是下一层元素个数的1/2呢？很简单，抛硬币就能解决了！假设元素X要插入跳跃表，很显然，L1层肯定要插入X。那么L2层要不要插入X呢？我们希望上层元素个数是下层元素个数的1/2，所以我们有1/2的概率希望X插入L2层，那么抛一下硬币吧，正面就插入，反面就不插入。那么L3到底要不要插入X呢？相对于L2层，我们还是希望1/2的概率插入，那么继续抛硬币吧！以此类推，元素X插入第n层的概率是(1/2)的n次。这样，我们能在跳跃表中插入一个元素了。</p>
<p>在此还是以上图为例：跳跃表的初试状态如下图，表中没有一个元素： </p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/20161205212059243.png" alt="这里写图片描述"></p>
<p>如果我们要插入元素2，首先是在底部插入元素2，如下图： </p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/20161205212409123.png" alt="这里写图片描述"></p>
<p>继续抛硬币，结果是反面，那么元素2的插入操作就停止了，插入后的表结构就是上图所示。接下来，我们插入元素33，跟元素2的插入一样，现在L1层插入33，如下图： </p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/20161205212458264.png" alt="这里写图片描述"></p>
<p>然后抛硬币，结果是反面，那么元素33的插入操作就结束了，插入后的表结构就是上图所示。接下来，我们插入元素55，首先在L1插入55，插入后如下图： </p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/20161205212553339.png" alt="这里写图片描述"></p>
<p>然后抛硬币，结果是正面，那么L2层需要插入55，如下图： </p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/20161205212659309.png" alt="这里写图片描述"></p>
<p>继续抛硬币，结果又是正面，那么L3层需要插入55，如下图： </p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/20161205212712590.png" alt="这里写图片描述"></p>
<p> 以此类推，插入剩余的元素。当然因为规模小，结果很可能不是一个理想的跳跃表。但是如果元素个数n的规模很大，基于概率，最终的表结构可能非常接近于理想跳跃表。</p>
<p>再讨论删除，直接删除元素，然后调整一下删除元素后的指针即可，跟普通的链表删除操作完全一样。插入和删除的时间复杂度就是查询元素插入位置的时间复杂度，所以是O(logn)。关于时间复杂度的证明，感兴趣的话可以去看关于跳跃表的paper。</p>
<h3 id="2-4-2-Redis-中的跳跃表"><a href="#2-4-2-Redis-中的跳跃表" class="headerlink" title="2.4.2 Redis 中的跳跃表"></a>2.4.2 Redis 中的跳跃表</h3><h4 id="Redis跳跃表的实现"><a href="#Redis跳跃表的实现" class="headerlink" title="Redis跳跃表的实现"></a>Redis跳跃表的实现</h4><p>Redis 的跳跃表</p>
<ul>
<li>redis.h/zskiplistNode：zskiplistNode 结构用于表示跳跃表节点。</li>
<li>redis.h/zskiplist：zskiplist 结构则用于保存跳跃表节点的相关信息， 比如节点的数量， 以及指向表头节点和表尾节点的指针， 等等。</li>
</ul>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/1238581-20210213201733089-1490815062.png" alt="img"></p>
<p>zskiplist （图片最左边）属性：</p>
<ul>
<li>header ：指向跳跃表的表头节点。</li>
<li>tail ：指向跳跃表的表尾节点。</li>
<li>level ：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</li>
<li>length ：记录跳跃表的长度，即跳跃表目前包含节点的数量（表头节点不计算在内）。</li>
</ul>
<p>zskiplistNode （zskiplist 结构右方的是四个zskiplistNode  ）属性：</p>
<ul>
<li>层（level）：节点中用 L1 、 L2 、 L3 等字样标记节点的各个层， L1 代表第一层， L2 代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。</li>
<li>后退（backward）指针：节点中用 BW 字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li>
<li>分值（score）：各个节点中的 1.0 、 2.0 和 3.0 是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</li>
<li>成员对象（obj）：各个节点中的 o1 、 o2 和 o3 是节点所保存的成员对象。</li>
</ul>
<p>注意表头节点和其他节点的构造是一样的： 表头节点也有后退指针、分值和成员对象， 不过表头节点的这些属性都不会被用到， 所以图中省略了这些部分， 只显示了表头节点的各个层。</p>
<p><strong>zskiplist 结构的定义如下：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// header 和 tail 指针分别指向跳跃表的表头和表尾节点， 通过这两个指针， 程序定位表头节点和表尾节点的复杂度为 O(1) 。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">// 用来记录表中节点的数量， 程序可以在 O(1) 复杂度内返回跳跃表的长度。</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数，用于在 O(1) 复杂度内获取跳跃表中层高最大的那个节点的层数，注意表头节点的层高并不计算在内。</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<p><strong>zskiplistNode 结构定义：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 后退指针，一个节点只有一个</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 前进指针，对于该节点每层一个</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<p><strong>层</strong></p>
<ul>
<li><p>跳跃表节点的 level 数组可以包含多个元素， 每个元素都包含一个指向其他节点的前进指针， 程序可以通过这些层来加快访问其他节点的速度， 一般来说， 层的数量越多， 访问其他节点的速度就越快。</p>
</li>
<li><p>每次创建一个新跳跃表节点的时候， 程序都根据<strong>幂次定律</strong> （<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Power_law">power law</a>，越大的数出现的概率越小） 随机生成一个介于 1 和 32 之间的值作为 level 数组的大小， 这个大小就是层的“高度”。</p>
<blockquote>
<p>Y：第n（n&gt;1）层有节点x，则第n-1层也一定有x节点。</p>
</blockquote>
</li>
</ul>
<p>图 5-2 分别展示了三个高度为 1 层、 3 层和 5 层的节点， 因为 C 语言的数组索引总是从 0 开始的， 所以节点的第一层是 level[0] ， 而第二层是 level[1] ， 以此类推。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/1238581-20210213201838639-805210660.png" alt="img"></p>
<p><strong>前进指针</strong></p>
<p>用于从表头向表尾方向访问该层节点，即层的遍历。</p>
<p><strong>跨度</strong></p>
<ul>
<li>用于记录两个节点之间的距离：<ul>
<li>  两个节点之间的跨度越大， 它们相距得就越远。</li>
<li>  指向 NULL 的所有前进指针的跨度都为 0 ， 因为它们没有连向任何节点。</li>
</ul>
</li>
<li> <strong>跨度实际上是用来计算排位（rank）的</strong>： 在查找某个节点的过程中， 将沿途访问过的所有层的跨度累计起来， 得到的结果就是目标节点在跳跃表中的排位。</li>
</ul>
<p>举个例子， 图 5-4 用虚线标记了在跳跃表中查找分值为 3.0 、 成员对象为 o3 的节点时， 沿途经历的层： 查找的过程只经过了一个层L3， 并且层的跨度为 3 ， 所以目标节点在跳跃表中的排位为 3 。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/1238581-20210213202024590-570344443.png" alt="img"></p>
<p>再举个例子， 图 5-5 用虚线标记了在跳跃表中查找分值为 2.0 、 成员对象为 o2 的节点时， 沿途经历的层： 在查找节点的过程中， 程序经过了两个跨度为 1 的节点， 因此可以计算出， 目标节点在跳跃表中的排位为 2 。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/1238581-20210213202038671-1204788410.png" alt="img"></p>
<p><strong>后退指针</strong></p>
<ul>
<li>节点的后退指针（backward 属性）用于从表尾向表头方向访问节点： 跟可以一次跳过多个节点的前进指针不同， 因为每个节点只有一个后退指针， 所以每次只能后退至前一个节点。</li>
</ul>
<p>图 5-6 用虚线展示了如何<strong>从表尾向表头遍历跳跃表中的所有节点</strong>： 程序首先通过跳跃表的 tail 指针访问表尾节点， 然后通过后退指针访问倒数第二个节点， 之后再沿着后退指针访问倒数第三个节点， 再之后遇到指向 NULL 的后退指针， 于是访问结束。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/1238581-20210213202122053-915674055.png" alt="img"></p>
<p><strong>分值和成员</strong></p>
<ul>
<li>节点的分值（score 属性）是一个 <strong>double</strong> 类型的浮点数， 跳跃表中的所有节点都按<strong>分值</strong>从小到大来排序。</li>
<li>节点的成员对象（obj 属性）是一个指针， 它指向一个字符串对象， 而字符串对象则保存着一个 SDS 值。</li>
<li>在同一个跳跃表中， 各个节点保存的成员对象必须是唯一的， 但是多个节点保存的分值却可以是相同的： 分值相同的节点将按照成员对象在字典序中的大小来进行排序， 成员对象较小的节点会排在前面（靠近表头的方向）， 而成员对象较大的节点则会排在后面（靠近表尾的方向）。</li>
</ul>
<p>举个例子， 在图 5-7 所示的跳跃表中， 三个跳跃表节点都保存了相同的分值 10086.0 ， 但保存成员对象 o1 的节点却排在保存成员对象 o2 和 o3 的节点之前， 而保存成员对象 o2 的节点又排在保存成员对象 o3 的节点之前， 由此可见， o1 、 o2 、 o3 三个成员对象在字典中的排序为 o1 &lt;= o2 &lt;= o3 。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/1238581-20210213202144716-2013979073.png" alt="img"></p>
<p><strong>总结</strong></p>
<ul>
<li>跳跃表基于单链表加索引的方式实现</li>
<li>跳跃表以空间换时间的方式提升了查找速度</li>
<li>Redis有序集合在节点元素较大或者元素数量较多时使用跳跃表实现，它在 Redis 中没有其他应用。</li>
<li>Redis的跳跃表实现由 zskiplist和 zskiplistnode两个结构组成,其中 zskiplist用于保存跳跃表信息(比如表头节点、表尾节点、长度),而zskiplistnode则用于表示跳跃表节点</li>
<li>Redis每个跳跃表节点的层高都是1至32之间的随机数</li>
<li>在同一个跳跃表中,多个节点可以包含相同的分值,但每个节点的成员对象必须是唯一的跳跃表中的节点按照分值大小进行排序,当分值相同时,节点按照成员对象的大小进行排序。</li>
</ul>
<h3 id="2-4-3-Redis跳跃表常用操作的时间复杂度"><a href="#2-4-3-Redis跳跃表常用操作的时间复杂度" class="headerlink" title="2.4.3 Redis跳跃表常用操作的时间复杂度"></a>2.4.3 Redis跳跃表常用操作的时间复杂度</h3><table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">创建一个跳跃表</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left">释放给定跳跃表以及其中包含的节点</td>
<td align="left">O(N)</td>
</tr>
<tr>
<td align="left">添加给定成员和分值的新节点</td>
<td align="left">平均O(logN),最坏O(logN)(N为跳跃表的长度)</td>
</tr>
<tr>
<td align="left">删除除跳跃表中包含给定成员和分值的节点</td>
<td align="left">平均O(logN),最坏O(logN)(N为跳跃表的长度)</td>
</tr>
<tr>
<td align="left">返回给定成员和分值的节点再表中的排位</td>
<td align="left">平均O(logN),最坏O(logN)(N为跳跃表的长度)</td>
</tr>
<tr>
<td align="left">返回在给定排位上的节点</td>
<td align="left">平均O(logN),最坏O(logN)(N为跳跃表的长度)</td>
</tr>
<tr>
<td align="left">给定一个分值范围,返回跳跃表中第一个符合这个范围的节点</td>
<td align="left">O(1)</td>
</tr>
<tr>
<td align="left">给定一个分值范围,返回跳跃表中最后一个符合这个范围的节点</td>
<td align="left">平均O(logN),最坏O(logN)(N为跳跃表的长度)</td>
</tr>
<tr>
<td align="left">给定一个分值范围,除跳跃表中所有在这个范围之内的节点</td>
<td align="left">平均O(logN),最坏O(logN)(N为跳跃表的长度)</td>
</tr>
<tr>
<td align="left">给定一个排位范围,鼎除跳跃表中所有在这个范围之内的节点</td>
<td align="left">O(N),N为被除节点数量</td>
</tr>
<tr>
<td align="left">给定一个分值范固(range),比如0到15,20到28,诸如此类,如果跳氏表中有至少一个节点的分值在这个范間之内,那么返回1,否则返回0</td>
<td align="left">O(N),N为被除节点数量</td>
</tr>
</tbody></table>
<h2 id="2-5-整数集合"><a href="#2-5-整数集合" class="headerlink" title="2.5 整数集合"></a>2.5 整数集合</h2><p>当一个集合中只包含整数，并且元素的个数不是很多的话，redis 会用整数集合作为底层存储，它的一个优点就是可以节省很多内存，虽然字典结构的效率很高，但是它的实现结构相对复杂并且会分配较多的内存空间。</p>
<p>而我们的整数集合（intset）可以做到使用较少的内存空间却达到和字典一样效率的实现，但也是前提的，集合中只能包含整型数据并且数量不能太多。整数集合最多能存多少个元素在 redis 中也是有体现的。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">OBJ_SET_MAX_INTSET_ENTRIES</span> <span class="string">512</span></span><br></pre></td></tr></table></figure>

<p>也就是超过 512 个元素，或者向集合中添加了字符串或其他数据结构，redis 会将整数集合向字典结构进行转换。</p>
<p>intset 的结构定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">// 记录整数集合中目前存储了多少个元素。</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="comment">// 记录我们实际的数据集合。虽然我们看到结构体中给数组元素的类型定死成 int8_t，但实际上这个 int8_t 定义的毫无意义，因为这里的处理方式非常规的数组操作，content 字段虽然被定义成指向一个 int8_t 类型数据的指针，但实际上 redis 无论是读取数组元素还是新增元素进去都依赖 encoding 和 length 两个字段直接操作的内存。</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents [];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p>encoding 记录当前 intset 使用编码，有三个取值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span></span><br></pre></td></tr></table></figure>

<h2 id="2-6-压缩列表"><a href="#2-6-压缩列表" class="headerlink" title="2.6 压缩列表"></a>2.6 压缩列表</h2><p>​    压缩列表（ziplist）是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项， 并且每个列表项要么就是小整数值， 要么就是长度比较短的字符串， 那么 Redis 就会使用压缩列表来做列表键的底层实现。</p>
<h2 id="2-7-对象"><a href="#2-7-对象" class="headerlink" title="2.7 对象"></a>2.7 对象</h2><ul>
<li>Redis 并没有直接使用简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合等数据结构来实现键值对数据库， 而是<strong>基于这些数据结构创建了一个对象系统</strong>， 这个系统包含<strong>字符串对象</strong>、<strong>列表对象</strong>、<strong>哈希对象</strong>、<strong>集合对象</strong>和<strong>有序集合对象</strong>这五种类型的对象， 每种对象都用到了至少一种我们前面所介绍的数据结构。</li>
<li>通过这五种不同类型的对象<ol>
<li>Redis 可以在执行命令之前， 根据对象的类型来判断一个对象是否可以执行给定的命令。</li>
<li>可以针对不同的使用场景， 为对象设置多种不同的数据结构实现， 从而优化对象在不同场景下的使用效率。</li>
</ol>
</li>
<li>Redis 的对象系统还实现了基于<strong>引用计数技术</strong>的内存回收机制： 当程序不再使用某个对象的时候， 这个对象所占用的内存就会被自动释放； 另外， Redis 还通过引用计数技术实现了对象共享机制， 这一机制可以在适当的条件下， 通过让多个数据库键共享同一个对象来节约内存。</li>
<li>最后， Redis 的对象带有访问时间记录信息， 该信息可以用于计算数据库键的空转时长， 在服务器启用了 maxmemory 功能的情况下， 空转时长较大的那些键可能会优先被服务器删除。</li>
</ul>
<h3 id="2-7-1-对象的类型与编码"><a href="#2-7-1-对象的类型与编码" class="headerlink" title="2.7.1 对象的类型与编码"></a>2.7.1 对象的类型与编码</h3><ul>
<li><p>Redis 使用对象来表示数据库中的键和值， 每次当我们在 Redis 的数据库中新创建一个键值对时， 我们至少会创建两个对象， 一个对象用作键值对的键（键对象）， 另一个对象用作键值对的值（值对象）。</p>
</li>
<li><p>Redis 中的每个对象都由一个 redisObject 结构表示， 该结构中和保存数据有关的三个属性分别是 type 属性、 encoding 属性和 ptr 属性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">// 对象类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 引用计数，用于内存回收与对象共享</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line">  	<span class="comment">// 该属性记录了对象最后一次被命令程序访问的时间，用于计算空转时长</span></span><br><span class="line">  	<span class="keyword">unsigned</span> lru:<span class="number">22</span>;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p><strong>对象类型</strong></p>
<table>
<thead>
<tr>
<th>类型常量</th>
<th>对象的名称</th>
<th>TYPE 命令的输出</th>
</tr>
</thead>
<tbody><tr>
<td>REDIS_STRING</td>
<td>字符串对象</td>
<td>“string”</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>列表对象</td>
<td>“list”</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>哈希对象</td>
<td>“hash”</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>集合对象</td>
<td>“set”</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>有序集合对象</td>
<td>“zset”</td>
</tr>
</tbody></table>
<ul>
<li><p>对于 Redis 数据库保存的键值对来说， 键总是一个字符串对象， 而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种， 因此：</p>
<ul>
<li>当我们称呼一个数据库键为“字符串键”时， 我们指的是“这个数据库键所对应的值为字符串对象”；</li>
<li>当我们称呼一个键为“列表键”时， 我们指的是“这个数据库键所对应的值为列表对象”，诸如此类。</li>
</ul>
</li>
<li><p>TYPE 命令的实现方式也与此类似， 当我们对一个数据库键执行 TYPE 命令时， 命令返回的结果为数据库键对应的值对象的类型， 而不是键对象的类型：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 键为字符串对象，值为列表对象</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> RPUSH numbers 1 3 5</span></span><br><span class="line">(integer) 6</span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> TYPE numbers</span></span><br><span class="line">list</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>编码和底层实现</strong></p>
<p>对象的 ptr 指针指向对象的底层实现数据结构， encoding 属性记录了对象所使用的编码， 也即是说这个对象使用了什么数据结构作为对象的底层实现。</p>
<table>
<thead>
<tr>
<th>编码常量</th>
<th>编码所对应的底层数据结构</th>
<th>OBJECT ENCODING 命令输出</th>
</tr>
</thead>
<tbody><tr>
<td>REDIS_ENCODING_INT</td>
<td>long 类型的整数</td>
<td>“int”</td>
</tr>
<tr>
<td>REDIS_ENCODING_EMBSTR</td>
<td>embstr 编码的简单动态字符串</td>
<td>“embstr”</td>
</tr>
<tr>
<td>REDIS_ENCODING_RAW</td>
<td>简单动态字符串</td>
<td>“raw”</td>
</tr>
<tr>
<td>REDIS_ENCODING_HT</td>
<td>字典</td>
<td>“hashtable”</td>
</tr>
<tr>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>双端链表</td>
<td>“linkedlist”</td>
</tr>
<tr>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>压缩列表</td>
<td>“ziplist”</td>
</tr>
<tr>
<td>REDIS_ENCODING_INTSET</td>
<td>整数集合</td>
<td>“intset”</td>
</tr>
<tr>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>跳跃表和字典</td>
<td>“skiplist”</td>
</tr>
</tbody></table>
<p>其中，每种type类型的对象都至少使用了两种不同的编码，使用 OBJECT ENCODING 命令可以查看一个数据库键的值对象的编码。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/image-20210822195733449.png" alt="image-20210822195733449"></p>
<h3 id="2-7-2-对象编码转换条件"><a href="#2-7-2-对象编码转换条件" class="headerlink" title="2.7.2 对象编码转换条件"></a>2.7.2 对象编码转换条件</h3><h4 id="2-7-2-1-字符串对象"><a href="#2-7-2-1-字符串对象" class="headerlink" title="2.7.2.1 字符串对象"></a>2.7.2.1 字符串对象</h4><ul>
<li>字符串对象的编码可以是 int 、embstr 或者raw。<ul>
<li>如果一个字符串对象保存的是整数值， 并且这个整数值可以用 long 类型来表示， 那么字符串对象会将整数值保存在字符串对象结构的 ptr 属性里面（将 void* 转换成 long ）， 并将字符串对象的编码设置为 int 。</li>
<li>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度小于等于 39 字节， 那么字符串对象将使用 embstr 编码的方式来保存这个字符串值。</li>
<li>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度大于 39 字节， 那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值， 并将对象的编码设置为 raw 。</li>
</ul>
</li>
<li>最后要说的是， 可以用 long double 类型表示的浮点数在 Redis 中也是作为字符串值来保存的： 如果我们要保存一个浮点数到字符串对象里面， 那么程序会先将这个浮点数转换成字符串值， 然后再保存起转换所得的字符串值。在有需要的时候， 程序会将保存在字符串对象里面的字符串值转换回浮点数值， 执行某些操作， 然后再将执行操作所得的浮点数值转换回字符串值， 并继续保存在字符串对象里面。</li>
</ul>
<p>字符串对象保存各类型值的编码方式：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>编码</th>
</tr>
</thead>
<tbody><tr>
<td>可以用 long 类型保存的整数。</td>
<td>int</td>
</tr>
<tr>
<td>可以用 long double 类型保存的浮点数。</td>
<td>embstr 或者 raw</td>
</tr>
<tr>
<td>字符串值， 或者因为长度太大而没办法用 long 类型表示的整数， 又或者因为长度太大而没办法用 long double 类型表示的浮点数。</td>
<td>embstr 或者 raw</td>
</tr>
</tbody></table>
<p><strong>编码的转换</strong></p>
<ul>
<li>int 编码的字符串对象和 embstr 编码的字符串对象在条件满足的情况下， 会被转换为 raw 编码的字符串对象。</li>
<li>对于 int 编码的字符串对象来说， 如果我们向对象执行了一些命令， 使得这个对象保存的不再是整数值， 而是一个字符串值， 那么字符串对象的编码将从 int 变为 raw 。比如APPEND 命令</li>
<li>另外， 因为 Redis 没有为 embstr 编码的字符串对象编写任何相应的修改程序 （只有 int 编码的字符串对象和 raw 编码的字符串对象有这些程序）， 所以 embstr 编码的字符串对象实际上是只读的： 当我们对 embstr 编码的字符串对象执行任何修改命令时， 程序会先将对象的编码从 embstr 转换成 raw ， 然后再执行修改命令； 因为这个原因， embstr 编码的字符串对象在执行修改命令之后， 总会变成一个 raw 编码的字符串对象。</li>
</ul>
<h4 id="2-7-2-2-列表对象"><a href="#2-7-2-2-列表对象" class="headerlink" title="2.7.2.2 列表对象"></a>2.7.2.2 列表对象</h4><ul>
<li>列表对象的编码可以是 ziplist 或者 linkedlist 。</li>
<li>ziplist 编码的列表对象使用<strong>压缩列表</strong>作为底层实现， 每个压缩列表节点（entry）保存了一个列表元素。</li>
<li>另一方面， linkedlist 编码的列表对象使用<strong>双端链表</strong>作为底层实现， 每个双端链表节点（node）都保存了一个字符串对象， 而每个字符串对象都保存了一个列表元素。</li>
</ul>
<p><strong>编码转换</strong></p>
<p>当列表对象可以同时满足以下两个条件时， 列表对象使用 ziplist 编码：</p>
<ol>
<li>列表对象保存的所有字符串元素的长度都小于 64 字节；</li>
<li>列表对象保存的元素数量小于 512 个；</li>
</ol>
<p>不能满足这两个条件的列表对象需要使用 linkedlist 编码。</p>
<ul>
<li>对于使用 ziplist 编码的列表对象来说， 当使用 ziplist 编码所需的两个条件的任意一个不能被满足时， 对象的编码转换操作就会被执行： 原本保存在压缩列表里的所有列表元素都会被转移并保存到双端链表里面， 对象的编码也会从 ziplist 变为 linkedlist 。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：以上两个条件的上限值是可以修改的， 具体请看配置文件中关于 list-max-ziplist-value 选项和 list-max-ziplist-entries 选项的说明。</p>
</blockquote>
<h4 id="2-7-2-3-哈希对象"><a href="#2-7-2-3-哈希对象" class="headerlink" title="2.7.2.3 哈希对象"></a>2.7.2.3 哈希对象</h4><ul>
<li>哈希对象的编码可以是 <strong>ziplist</strong> 或者 <strong>hashtable</strong> 。</li>
<li>ziplist 编码的哈希对象使用<strong>压缩列表</strong>作为底层实现， 每当有新的键值对要加入到哈希对象时， 程序会先将保存了键的压缩列表节点推入到压缩列表表尾， 然后再将保存了值的压缩列表节点推入到压缩列表表尾， 因此：<ul>
<li>保存了同一键值对的两个节点总是紧挨在一起， 保存键的节点在前， 保存值的节点在后；</li>
<li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向， 而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。</li>
</ul>
</li>
<li>另一方面， hashtable 编码的哈希对象使用<strong>字典</strong>作为底层实现， 哈希对象中的每个键值对都使用一个字典键值对来保存：<ul>
<li>字典的每个键都是一个字符串对象， 对象中保存了键值对的键；</li>
<li>字典的每个值都是一个字符串对象， 对象中保存了键值对的值。</li>
</ul>
</li>
</ul>
<p><strong>编码转换</strong></p>
<p>当哈希对象可以同时满足以下两个条件时， 哈希对象使用 ziplist 编码：</p>
<ol>
<li><p>哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节；</p>
</li>
<li><p>哈希对象保存的键值对数量小于 512 个。 </p>
<blockquote>
<p>Y：应该是键值对数量小于256？</p>
</blockquote>
</li>
</ol>
<p>不能满足这两个条件的哈希对象需要使用 hashtable 编码。</p>
<ul>
<li>对于使用 ziplist 编码的列表对象来说， 当使用 ziplist 编码所需的两个条件的任意一个不能被满足时， 对象的编码转换操作就会被执行： 原本保存在压缩列表里的所有键值对都会被转移并保存到字典里面， 对象的编码也会从 ziplist 变为 hashtable 。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：这两个条件的上限值是可以修改的， 具体请看配置文件中关于 hash-max-ziplist-value 选项和 hash-max-ziplist-entries 选项的说明。</p>
</blockquote>
<h4 id="2-7-2-4-集合对象"><a href="#2-7-2-4-集合对象" class="headerlink" title="2.7.2.4 集合对象"></a>2.7.2.4 集合对象</h4><ul>
<li>集合对象的编码可以是 <strong>intset</strong> 或者 <strong>hashtable</strong> 。</li>
<li>intset 编码的集合对象使用<strong>整数集合</strong>作为底层实现， 集合对象包含的所有元素都被保存在整数集合里面。</li>
<li>另一方面， hashtable 编码的集合对象使用<strong>字典</strong>作为底层实现， 字典的每个键都是一个字符串对象， 每个字符串对象包含了一个集合元素， 而字典的值则全部被设置为 NULL 。</li>
</ul>
<p><strong>编码的转换</strong></p>
<p>当集合对象可以同时满足以下两个条件时， 对象使用 intset 编码：</p>
<ol>
<li>集合对象保存的所有元素都是整数值；</li>
<li>集合对象保存的元素数量不超过 512 个；</li>
</ol>
<p>不能满足这两个条件的集合对象需要使用 hashtable 编码。</p>
<ul>
<li>对于使用 intset 编码的集合对象来说， 当使用 intset 编码所需的两个条件的任意一个不能被满足时， 对象的编码转换操作就会被执行： 原本保存在整数集合中的所有元素都会被转移并保存到字典里面， 并且对象的编码也会从 intset 变为 hashtable 。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：第二个条件的上限值是可以修改的， 具体请看配置文件中关于 set-max-intset-entries 选项的说明。</p>
</blockquote>
<h4 id="2-7-2-5-有序集合对象"><a href="#2-7-2-5-有序集合对象" class="headerlink" title="2.7.2.5 有序集合对象"></a>2.7.2.5 有序集合对象</h4><ul>
<li><p>有序集合的编码可以是 <strong>ziplist</strong> 或者 <strong>skiplist</strong> 。</p>
</li>
<li><p>ziplist 编码的有序集合对象使用<strong>压缩列表</strong>作为底层实现， 每个集合元素使用两个紧挨在一起的压缩列表节点来保存， 第一个节点保存元素的成员（member）， 而第二个元素则保存元素的分值（score）。</p>
</li>
<li><p>压缩列表内的集合元素按分值从小到大进行排序， 分值较小的元素被放置在靠近表头的方向， 而分值较大的元素则被放置在靠近表尾的方向。</p>
</li>
<li><p>skiplist 编码的有序集合对象使用 <strong>zset 结构</strong>作为底层实现，<strong>一个 zset 结构同时包含一个字典和一个跳跃表</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">    dict *dict;     </span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>zset 结构中的 zsl 跳跃表按分值从小到大保存了所有集合元素</strong>， 每个跳跃表节点都保存了一个集合元素： 跳跃表节点的 object 属性保存了元素的成员， 而跳跃表节点的 score 属性则保存了元素的分值。 通过这个跳跃表， 程序可以对有序集合进行范围型操作， 比如 ZRANK 、 ZRANGE 等命令就是基于跳跃表 API 来实现的。</li>
<li><strong>zset 结构中的 dict 字典为有序集合创建了一个从成员到分值的映射</strong>， 字典中的每个键值对都保存了一个集合元素： 字典的键保存了元素的成员， 而字典的值则保存了元素的分值。 通过这个字典， 程序可以用 O(1) 复杂度查找给定成员的分值， ZSCORE 命令就是根据这一特性实现的， 而很多其他有序集合命令都在实现的内部用到了这一特性。</li>
<li>值得一提的是， 虽然 zset 结构同时使用跳跃表和字典来保存有序集合元素， 但<strong>这两种数据结构都会通过指针来共享相同元素的成员和分值</strong>， 所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值， 也不会因此而浪费额外的内存。</li>
</ul>
</li>
<li><p>有序集合每个元素的成员都是一个字符串对象， 而每个元素的分值都是一个 double 类型的浮点数。</p>
</li>
</ul>
<p><strong>为什么有序集合需要同时使用跳跃表和字典来实现？</strong></p>
<ul>
<li>在理论上来说， 有序集合可以单独使用字典或者跳跃表的其中一种数据结构来实现， 但无论单独使用字典还是跳跃表， 在性能上对比起同时使用字典和跳跃表都会有所降低。</li>
<li>举个例子， 如果我们只使用字典来实现有序集合， 那么虽然以 O(1) 复杂度查找成员的分值这一特性会被保留， 但是， 因为字典以无序的方式来保存集合元素， 所以每次在执行范围型操作 —— 比如 ZRANK 、 ZRANGE 等命令时， 程序都需要对字典保存的所有元素进行排序， 完成这种排序需要至少 O(N \log N) 时间复杂度， 以及额外的 O(N) 内存空间 （因为要创建一个数组来保存排序后的元素）。</li>
<li>另一方面， 如果我们只使用跳跃表来实现有序集合， 那么跳跃表执行范围型操作的所有优点都会被保留， 但因为没有了字典， 所以根据成员查找分值这一操作的复杂度将从 O(1) 上升为 O(\log N) 。</li>
<li>因为以上原因， 为了让有序集合的查找和范围型操作都尽可能快地执行， Redis 选择了同时使用字典和跳跃表两种数据结构来实现有序集合。</li>
</ul>
<p><strong>编码的转换</strong></p>
<p>当有序集合对象可以同时满足以下两个条件时， 对象使用 ziplist 编码：</p>
<ol>
<li>有序集合保存的元素数量小于 128 个；</li>
<li>有序集合保存的所有元素成员的长度都小于 64 字节；</li>
</ol>
<p>不能满足以上两个条件的有序集合对象将使用 skiplist 编码。</p>
<ul>
<li>对于使用 ziplist 编码的有序集合对象来说， 当使用 ziplist 编码所需的两个条件中的任意一个不能被满足时， 程序就会执行编码转换操作， 将原本储存在压缩列表里面的所有集合元素转移到 zset 结构里面， 并将对象的编码从 ziplist 改为 skiplist 。</li>
</ul>
<blockquote>
<p><strong>注意</strong>：以上两个条件的上限值是可以修改的， 具体请看配置文件中关于 zset-max-ziplist-entries 选项和 zset-max-ziplist-value 选项的说明。</p>
</blockquote>
<h2 id="2-8-类型检查与命令多态"><a href="#2-8-类型检查与命令多态" class="headerlink" title="2.8 类型检查与命令多态"></a>2.8 类型检查与命令多态</h2><p>略</p>
<h2 id="2-9-内存回收"><a href="#2-9-内存回收" class="headerlink" title="2.9 内存回收"></a>2.9 内存回收</h2><p>略</p>
<h2 id="2-10-对象共享"><a href="#2-10-对象共享" class="headerlink" title="2.10 对象共享"></a>2.10 对象共享</h2><ul>
<li><p>在 Redis 中， 让多个键共享同一个值对象需要执行以下两个步骤：</p>
<ol>
<li>将数据库键的值指针指向一个现有的值对象；</li>
<li>将被共享的值对象的引用计数增一。</li>
</ol>
</li>
<li><p>目前来说， Redis 会在初始化服务器时， 创建一万个字符串对象， 这些对象包含了从 0 到 9999 的所有整数值， 当服务器需要用到值为 0 到 9999 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象。</p>
</li>
</ul>
<blockquote>
<p><strong>注意</strong>：创建共享字符串对象的数量可以通过修改 redis.h/REDIS_SHARED_INTEGERS 常量来修改。</p>
</blockquote>
<ul>
<li>另外， 这些共享对象不单单只有字符串键可以使用， 那些在数据结构中嵌套了字符串对象的对象（linkedlist 编码的列表对象、 hashtable 编码的哈希对象、 hashtable 编码的集合对象、以及 zset 编码的有序集合对象）都可以使用这些共享对象。</li>
</ul>
<p><strong>为什么 Redis 不共享包含字符串的对象？</strong></p>
<p>当服务器考虑将一个共享对象设置为键的值对象时， 程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同， 只有在共享对象和目标对象完全相同的情况下， 程序才会将共享对象用作键的值对象， 而一个共享对象保存的值越复杂， 验证共享对象和目标对象是否相同所需的复杂度就会越高， 消耗的 CPU 时间也会越多：</p>
<ul>
<li>如果共享对象是保存整数值的字符串对象， 那么验证操作的复杂度为 O(1) ；</li>
<li>如果共享对象是保存字符串值的字符串对象， 那么验证操作的复杂度为 O(N) ；</li>
<li>如果共享对象是包含了多个值（或者对象的）对象， 比如列表对象或者哈希对象， 那么验证操作的复杂度将会是 O(N^2) 。</li>
</ul>
<p>因此， 尽管共享更复杂的对象可以节约更多的内存， 但受到 CPU 时间的限制， Redis 只对包含整数值的字符串对象进行共享。</p>
<h2 id="2-11-对象的空转时长"><a href="#2-11-对象的空转时长" class="headerlink" title="2.11 对象的空转时长"></a>2.11 对象的空转时长</h2><ul>
<li><strong>OBJECT IDLETIME</strong> 命令可以打印出给定键的空转时长， 这一空转时长就是通过将<strong>当前时间</strong>减去<strong>键的值对象的 lru 时间</strong>计算得出的.</li>
</ul>
<h1 id="3-Redis-内存管理"><a href="#3-Redis-内存管理" class="headerlink" title="3. Redis 内存管理"></a>3. Redis 内存管理</h1><h2 id="3-1-Redis的内存过期策略"><a href="#3-1-Redis的内存过期策略" class="headerlink" title="3.1 Redis的内存过期策略"></a>3.1 Redis的内存过期策略</h2><p>内存过期策略主要的作用就是，在缓存过期之后，能够及时的将失效的缓存从内存中删除，以减少内存的无效暂用，达到释放内存的目的。</p>
<p>Redis内存过期策略分为三类，定时策略、惰性策略和定期策略。</p>
<h2 id="3-1-1-定时策略"><a href="#3-1-1-定时策略" class="headerlink" title="3.1.1 定时策略"></a>3.1.1 定时策略</h2><p>含义：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时对key进行删除。</p>
<p>优点：保证内存被尽快释放，减少无效的缓存暂用内存。</p>
<p>缺点：若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key。定时器的创建耗时，若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重。<strong>一般来说，是不会选择该策略模式</strong>。</p>
<h2 id="3-1-2-惰性策略"><a href="#3-1-2-惰性策略" class="headerlink" title="3.1.2 惰性策略"></a>3.1.2 惰性策略</h2><p>含义：key过期的时候不删除，每次从数据库获取key的时候去检查是否过期，若过期，则删除，返回null。</p>
<p>优点：删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）。</p>
<p>缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，此时的无效缓存是永久暂用在内存中的，那么可能发生内存泄露（无用的垃圾占用了大量的内存）。</p>
<h2 id="3-1-3-定期策略"><a href="#3-1-3-定期策略" class="headerlink" title="3.1.3 定期策略"></a>3.1.3 定期策略</h2><p>含义：每隔一段时间对设置了缓存时间的key进行检测，如果可以已经失效，则从内存中删除，如果未失效，则不作任何处理。</p>
<p>优点：通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用（处理”定时删除”的缺点）， 定期删除过期key（处理”惰性删除”的缺点）。</p>
<p>缺点:在内存友好方面，不如”定时删除”，因为是随机遍历一些key，因此存在部分key过期，但遍历key时，没有被遍历到，过期的key仍在内存中。在CPU时间友好方面，不如”惰性删除”，定期删除也会暂用CPU性能消耗。</p>
<p>难点:合理设置删除操作的执行时长（每次删除执行多长时间）和执行频率（每隔多长时间做一次删除）（这个要根据服务器运行情况来定了）</p>
<h2 id="3-1-4-策略注意事项"><a href="#3-1-4-策略注意事项" class="headerlink" title="3.1.4 策略注意事项"></a>3.1.4 策略注意事项</h2><h3 id="过期策略对持久化存储的影响"><a href="#过期策略对持久化存储的影响" class="headerlink" title="过期策略对持久化存储的影响"></a><strong>过期策略对持久化存储的影响</strong></h3><p>持久化存储，指的是将内存的缓存永久存在磁盘中。也就是说我们的AOF和RDB持久化存储方式。因为该两种方式，将内存中的数据写入磁盘，这时候就需要考虑到我们过期的缓存是否会被写入到磁盘中？如果写入磁盘又是怎么处理的？</p>
<h3 id="RDB持久化存储方式"><a href="#RDB持久化存储方式" class="headerlink" title="RDB持久化存储方式"></a><strong>RDB持久化存储方式</strong></h3><p>持久化key之前，会检查是否过期，过期的key不进入RDB文件。</p>
<p>数据载入数据库之前，会对key先进行过期检查，如果过期，不导入数据库（主库情况）。</p>
<h3 id="AOF持久化存储方式"><a href="#AOF持久化存储方式" class="headerlink" title="AOF持久化存储方式"></a><strong>AOF持久化存储方式</strong></h3><p>当key过期后，还没有被删除，此时进行执行持久化操作（该key是不会进入aof文件的，因为没有发生修改命令）。</p>
<p>当key过期后，在发生删除操作时，程序会向aof文件追加一条del命令（在将来的以aof文件恢复数据的时候该过期的键就会被删掉）。</p>
<blockquote>
<p>因为AOF方式，向存储文件追加的是Redis的操作命令，而不是具体的数据，然而RDB确是存储的安全的二进制内容。</p>
</blockquote>
<p>重写时，会先判断key是否过期，已过期的key不会重写到aof文件。</p>
<blockquote>
<p>即使在重写时，不验证是否过期，然而追加了del命令，测试无效的key同样会被删除。判断的情况是为了防止没有加入del命令的key。</p>
</blockquote>
<h2 id="3-2-Redis内存淘汰机制"><a href="#3-2-Redis内存淘汰机制" class="headerlink" title="3.2 Redis内存淘汰机制"></a>3.2 Redis内存淘汰机制</h2><p>内存淘汰机制针对是<strong>内存不足</strong>的情况下的一种Redis处理机制。例如，当前的Redis存储已经超过内存限制了，然而我们的业务还在继续往Redis里面追加缓存内容，这时候Redis的淘汰机制就起到作用了。</p>
<h3 id="3-2-1-常见的缓存算法"><a href="#3-2-1-常见的缓存算法" class="headerlink" title="3.2.1 常见的缓存算法"></a>3.2.1 常见的缓存算法</h3><ul>
<li>LRU (Least recently used) 最近最少使用，如果数据最近被访问过，那么将来被访问的几率也更高。</li>
<li>LFU (Least frequently used) 最不经常使用，如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小。</li>
<li>FIFO (Fist in first out) 先进先出，如果一个数据最先进入缓存中，则应该最早淘汰掉。</li>
</ul>
<h3 id="3-2-2-淘汰机制分类"><a href="#3-2-2-淘汰机制分类" class="headerlink" title="3.2.2 淘汰机制分类"></a>3.2.2 淘汰机制分类</h3><p>根据redis.conf的配置文件中，我们可以得出，主要分为如下几种淘汰机制。</p>
<blockquote>
<p>Y：键空间 + 淘汰策略</p>
</blockquote>
<ul>
<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，使用LRU算法删除key。</li>
</ul>
<ul>
<li><p><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在键空间中，使用LRU算法删除key（这个是最常用的）。</p>
</li>
<li><p>volatile-lfu：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，使用LFU算法删除key。</p>
</li>
</ul>
<ul>
<li>allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，使用LFU算法删除key。</li>
</ul>
<ul>
<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机删除key。</li>
</ul>
<ul>
<li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机删除key。</li>
</ul>
<ul>
<li>volatile-ttl：当内存不足以容纳新写入数据时，优先删除离过期时间最近的key（minor TTL）。</li>
</ul>
<ul>
<li>noeviction：当内存不足以容纳新写入数据时，不删除任何数据，新写入操作会报错。</li>
</ul>
<h1 id="4-Redis-集群模式"><a href="#4-Redis-集群模式" class="headerlink" title="4. Redis 集群模式"></a>4. Redis 集群模式</h1><h2 id="4-1-主从同步-复制"><a href="#4-1-主从同步-复制" class="headerlink" title="4.1 主从同步/复制"></a>4.1 主从同步/复制</h2><p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/1350922-20191006113347736-1579349638.png" alt="img"></p>
<p>　为了避免单点故障，通常的做法是将数据库复制多个副本以部署在不同的服务器上，这样即使有一台服务器出现故障，其他服务器依然可以继续提供服务。为此， <strong>Redis 提供了复制（replication）功能，可以实现当一台数据库中的数据更新后，自动将更新的数据同步到其他数据库上</strong>。　　</p>
<p>​    在复制的概念中，数据库分为两类，一类是主数据库（master），另一类是从数据库(slave）。<strong>主数据库可以进行读写操作</strong>，当写操作导致数据变化时会自动将数据同步给从数据库。而<strong>从数据库一般是只读的，并接受主数据库同步过来的数据</strong>。一个主数据库可以拥有多个从数据库，而一个从数据库只能拥有一个主数据库。</p>
<p><strong>主从数据库的配置：</strong></p>
<p>　　<strong>主数据库不用配置</strong>，从数据库的配置文件（redis.conf）中可以配置主数据库的信息，也可以在启动时，使用 redis-server –port 6380 –slaveof 127.0.0.1 6379 命令指明主数据库的 IP 和端口。从数据库一般是只读，可以改为可写，但写入的数据很容易被主同步没，所以还是只读就可以。也可以在运行时使用 slaveof ip port 命令，停止原来的主，切换成刚刚设置的主 slaveof no one会把自己变成主。</p>
<p><strong>主从复制原理：</strong></p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/1350922-20191006113541904-1736285180.png" alt="img"></p>
<ul>
<li>从数据库连接主数据库，发送SYNC命令； </li>
<li>主数据库接收到SYNC命令后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令； </li>
<li>主数据库BGSAVE执行完后，向所有从数据库发送快照文件，并在发送期间继续记录被执行的写命令； </li>
<li>从数据库收到快照文件后<strong>丢弃所有旧数据</strong>，载入收到的快照； </li>
<li>主数据库快照发送完毕后开始向从数据库发送缓冲区中的写命令； </li>
<li>从数据库完成对快照的载入，开始接收命令请求，并执行来自主数据库缓冲区的写命令；（<strong>从数据库初始化完成</strong>）</li>
<li>主数据库每执行一个写命令就会向从数据库发送相同的写命令，从数据库接收并执行收到的写命令（<strong>从数据库初始化完成后的操作</strong>）</li>
<li>出现断开重连后，2.8之后的版本会将断线期间的命令传给从数据库，增量复制。</li>
<li>主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。Redis 的策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离；</li>
<li>为了分载Master的读操作压力，Slave服务器可以为客户端提供只读操作的服务，写服务仍然必须由Master来完成；</li>
<li>Slave同样可以接受其它Slaves的连接和同步请求，这样可以有效的分载Master的同步压力；</li>
<li>Master Server是以非阻塞的方式为Slaves提供服务。所以在Master-Slave同步期间，客户端仍然可以提交查询或修改请求；</li>
<li>Slave Server同样是以非阻塞的方式完成数据同步。在同步期间，如果有客户端提交查询请求，Redis则返回同步之前的数据；</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复；</li>
<li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性；</li>
<li>如果多个Slave断线了，需要重启的时候，尽量不要在同一时间段进行重启。因为只要Slave启动，就会发送sync请求和主机全量同步，当多个 Slave 重启的时候，可能会导致 Master IO剧增从而宕机。</li>
<li>Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂；</li>
</ul>
<h2 id="4-2-哨兵模式-sentinel"><a href="#4-2-哨兵模式-sentinel" class="headerlink" title="4.2 哨兵模式 sentinel"></a>4.2 哨兵模式 sentinel</h2><p>​    第一种主从同步/复制的模式，当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。</p>
<p>　哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，<strong>哨兵是一个独立的进程，作为进程，它会独立运行。</strong>其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</p>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/1350922-20191006121120390-676037470.png" alt="img" style="zoom:67%;" />

<p><strong>哨兵模式的作用：</strong></p>
<ul>
<li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器；</li>
<li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过<strong>发布订阅模式</strong>通知其他的从服务器，修改配置文件，让它们切换主机。</li>
</ul>
<p>然而一个哨兵进程对Redis服务器进行监控，也可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了<strong>多哨兵模式</strong>。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/1350922-20191006122611921-809764078.png" alt="img"></p>
<p><strong>故障切换的过程：</strong></p>
<p>　　假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行 failover 过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行 failover 操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。这样对于客户端而言，一切都是透明的。</p>
<p><strong>哨兵模式的配置：</strong></p>
<p>配置一主二从和三个哨兵的 Redis 服务器来演示这个过程</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/1350922-20191006122741113-1584577962.png" alt="img"></p>
<p><strong>主从服务器配置</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使得Redis服务器可以跨网络访问</span></span><br><span class="line"><span class="attr">bind</span> <span class="string">0.0.0.0</span></span><br><span class="line"><span class="comment"># 设置密码</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line"><span class="comment"># 以下有关slaveof的配置只是配置从服务器，主服务器不需要配置</span></span><br><span class="line"><span class="comment"># 指定主服务器</span></span><br><span class="line"><span class="attr">slaveof</span> <span class="string">192.168.11.128 6379</span></span><br><span class="line"><span class="comment"># 主服务器密码</span></span><br><span class="line"><span class="attr">masterauth</span> <span class="string">123456</span></span><br></pre></td></tr></table></figure>

<p><strong>哨兵配置</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 禁止保护模式</span></span><br><span class="line"><span class="meta">protected-mode</span> <span class="string">no</span></span><br><span class="line"><span class="comment"># 配置监听的主服务器，这里sentinel monitor代表监控，mymaster代表服务器的名称，可以自定义，192.168.11.128代表监控的主服务器，6379代表端口，2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。</span></span><br><span class="line"><span class="attr">sentinel</span> <span class="string">monitor mymaster 192.168.11.128 6379 2</span></span><br><span class="line"><span class="comment"># sentinel author-pass定义服务的密码，mymaster是服务名称，123456是Redis服务器密码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line"><span class="attr">sentinel</span> <span class="string">auth-pass mymaster 123456</span></span><br></pre></td></tr></table></figure>

<p>配置3个哨兵，每个哨兵的配置都是一样的。在Redis安装目录下有一个sentinel.conf文件，copy一份进行修改。</p>
<p><strong>启动</strong></p>
<p>注意启动的顺序。首先是主机（192.168.11.128）的 Redis 服务进程，然后启动从机的 Redis 服务进程，最后启动3个哨兵的服务进程。</p>
<p><strong>哨兵模式的工作方式：</strong></p>
<ul>
<li>每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的Master主服务器，Slave从服务器以及其他Sentinel（哨兵）进程发送一个 PING 命令。</li>
<li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN）</li>
<li>如果一个Master主服务器被标记为主观下线（SDOWN），则正在监视这个Master主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认Master主服务器的确进入了主观下线状态</li>
<li>当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认Master主服务器进入了主观下线状态（SDOWN）， 则Master主服务器会被标记为客观下线（ODOWN）</li>
<li>在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。</li>
<li>当Master主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</li>
<li>若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线状态就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都具有。</li>
<li>主从可以自动切换，系统更健壮，可用性更高。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。</li>
</ul>
<h2 id="4-3-Cluster集群"><a href="#4-3-Cluster集群" class="headerlink" title="4.3 Cluster集群"></a>4.3 Cluster集群</h2><p>Redis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存，所以在redis3.0上加入了 Cluster 集群模式，实现了 <strong>Redis 的分布式存储</strong>，也就是说每台 Redis 节点上存储不同的内容。</p>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/1350922-20191006124637992-2055348918.png" alt="img" style="zoom:50%;" />

<p><strong>集群的配置</strong></p>
<p>根据官方推荐，集群部署至少要 3 台以上的master节点。</p>
<p><strong>集群的特点</strong></p>
<ul>
<li><strong>所有的redis节点彼此互联</strong>(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。</li>
<li>节点的fail是通过集群中<strong>超过半数</strong>的节点检测失效时才生效。</li>
<li>客户端与 Redis 节点直连,不需要中间代理层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。</li>
</ul>
<h3 id="4-3-1-Redis-Cluster-数据分片"><a href="#4-3-1-Redis-Cluster-数据分片" class="headerlink" title="4.3.1 Redis Cluster 数据分片"></a>4.3.1 Redis Cluster 数据分片</h3><p>Redis Cluster不使用一致的哈希，而是一种不同形式的分片，其中每个键都是我们称为哈希槽（hash slot）的概念的一部分。</p>
<p>在Redis Cluster中有16384个哈希槽，为了计算给定key的哈希槽，我们只需将key的CRC16取16384模。</p>
<p>Redis集群中的每个节点都负责一个哈希槽的子集，例如，你可能有一个有3个节点的集群，其中:</p>
<ul>
<li>Node A contains hash slots from 0 to 5500.</li>
<li>Node B contains hash slots from 5501 to 11000.</li>
<li>Node C contains hash slots from 11001 to 16383.</li>
</ul>
<p>这允许在集群中轻松添加和删除节点。例如，如果我想添加一个新节点 D，我需要将一些哈希槽从节点 A、B、C 移动到 D。同样，如果我想从集群中删除节点 A，我可以移动 A 提供的哈希槽到 B 和 C。当节点 A 为空时，我可以将其从集群中完全删除。</p>
<p>由于将哈希槽从一个节点移动到另一个节点不需要停止操作，因此添加和删除节点或更改节点持有的哈希槽百分比不需要任何停机时间。</p>
<p>只要一个命令执行(或者整个事务，或者Lua脚本执行)中涉及的所有键都属于同一个散列槽，Redis集群就支持多个键操作。用户可以使用一个称为散列标签（hash tag）的概念来强制多个键成为同一个散列槽的一部分。</p>
<p>Redis Cluster 规范中记录了散列标签，但要点是如果键中的 {} 括号之间有一个子字符串，则只有字符串内的内容会被哈希，因此例如<code>this&#123;foo&#125;key</code>和<code>another&#123;foo&#125;key</code> 保证在同一个哈希槽中, 并且可以在具有多个键作为参数的命令中一起使用。</p>
<h3 id="4-3-2-Redis-Cluster-主从模式"><a href="#4-3-2-Redis-Cluster-主从模式" class="headerlink" title="4.3.2 Redis Cluster 主从模式"></a>4.3.2 Redis Cluster 主从模式</h3><p>为了在主节点子集出现故障或无法与大多数节点通信时保持可用，Redis 集群使用主从模型，其中每个哈希槽具有从 1（主节点本身）到 N 个副本（N -1 个额外的从节点）。</p>
<p>在我们包含节点 A、B、C 的示例集群中，如果节点 B 发生故障，集群将无法继续，因为我们不再有办法为 5501-11000 范围内的哈希槽提供服务。</p>
<p>然而，当集群创建时（或稍后），我们为每个主节点添加一个从节点，这样最终的集群由主节点 A、B、C 和从节点 A1、B1、C1 组成. 这样，如果节点 B 出现故障，系统就能够继续运行。</p>
<p>节点 B1 复制 B，并且 B 失败，集群会将节点 B1 提升为新的 master 并继续正常运行。</p>
<p>但是需要注意的是，如果节点 B 和 B1 同时发生故障，Redis Cluster 将无法继续运行。</p>
<h3 id="4-3-3-Redis-集群一致性保证"><a href="#4-3-3-Redis-集群一致性保证" class="headerlink" title="4.3.3 Redis 集群一致性保证"></a>4.3.3 Redis 集群一致性保证</h3><p>Redis Cluster <strong>无法保证强一致性</strong>。实际上，这意味着在某些情况下，Redis Cluster 可能会丢失系统已向客户端确认的写入。</p>
<p>Redis Cluster 会丢失写入的第一个原因是因为它使用<strong>异步复制</strong>。这意味着在写入期间会发生以下情况：</p>
<ul>
<li>您的客户端写入主 B。</li>
<li>主 B 向您的客户端回复 OK。</li>
<li>主设备 B 将写入传播到其从设备 B1、B2 和 B3。</li>
</ul>
<p>如您所见，B 在回复客户端之前不会等待来自 B1、B2、B3 的确认，因为这对 Redis 来说是一个令人望而却步的延迟惩罚，因此如果您的客户端写入某些内容，B 会确认写入，但若在将写入发送到其从站之前崩溃，其中一个从站（未收到写入）提升为主站，将永远失去该写入。</p>
<p>这与大多数配置为每秒将数据刷新到磁盘的数据库<strong>发生的情况非常相似</strong>，因此您已经能够推理出这种情况，因为过去使用不涉及分布式系统的传统数据库系统的经验。同样，您可以通过强制数据库在回复客户端之前将数据刷新到磁盘来提高一致性，但这通常会导致性能低得令人望而却步。在 Redis Cluster 的情况下，这相当于同步复制。</p>
<p>基本上，需要在性能和一致性之间进行权衡。</p>
<p>Redis 集群<strong>在绝对需要时支持同步写入</strong>，通过<a target="_blank" rel="noopener" href="https://redis.io/commands/wait">WAIT</a>命令实现。这使得丢失写入的可能性大大降低。但是，请注意，<strong>即使使用同步复制，Redis Cluster 也没有实现强一致性：在更复杂的故障场景下，始终有可能将无法接收写入的从站选为主站。</strong></p>
<p>还有一个值得注意的场景是 Redis 集群将丢失写入，这种情况发生在网络分区期间，客户端与少数实例（至少包括一个主实例）隔离。</p>
<p>以我们的6个节点集群为例，由A、B、C、A1、B1、C1组成，有3个master和3个slave。还有一个客户端，我们将其称为 Z1。</p>
<p>分区发生后，可能在分区的一侧有 A、C、A1、B1、C1，而在另一侧有 B 和 Z1。</p>
<p>Z1 仍然能够写入 B，B 将接受其写入。如果分区在很短的时间内恢复，集群将继续正常运行。但是，如果分区持续足够的时间让 B1 在分区的多数侧提升为主节点，则 Z1 同时发送给 B 的写入将丢失。</p>
<p>请注意，Z1 能够发送到 B 的写入量有一个<strong>最大窗口</strong>：如果分区的多数侧已经有足够的时间来选举一个从属作为主，那么少数侧的每个主节点都将停止接受写入。</p>
<p>这个时间量是 Redis Cluster 的一个非常重要的配置指令，称为<strong>节点超时</strong>。</p>
<p>节点超时后，主节点被视为发生故障，并且可以由其副本之一替换。类似地，在节点超时后，主节点无法感知大多数其他主节点，它会进入错误状态并停止接受写入。</p>
<h1 id="5-分区"><a href="#5-分区" class="headerlink" title="5. 分区"></a>5. 分区</h1><p>Redis 中的分区有两个主要<strong>目标</strong>：</p>
<ul>
<li>它允许使用多台计算机内存的总和来创建更大的数据库。如果不进行分区，您将受到单个计算机可以支持的内存量的限制。</li>
<li>它允许将计算能力扩展到多核和多台计算机，并将网络带宽扩展到多台计算机和网络适配器。</li>
</ul>
<h2 id="5-1-分区基础"><a href="#5-1-分区基础" class="headerlink" title="5.1 分区基础"></a>5.1 分区基础</h2><p>有不同的划分标准。想象一下，我们有四个 Redis 实例<strong>R0</strong>、<strong>R1</strong>、<strong>R2</strong>、<strong>R3</strong>和许多代表用户的键，如<code>user:1</code>、<code>user:2</code>、 … 等等，我们可以找到不同的方法来选择在哪个实例中存储给定的键。换句话说，有<em>不同的系统可以</em>将给定的键<em>映射</em>到给定的 Redis 服务器。</p>
<ul>
<li><strong>range partitioning</strong>：它是通过将对象范围映射到特定 Redis 实例来实现的。<ul>
<li>该系统有效并在实际中使用，但是，它的缺点是需要一个将范围映射到实例的表。这个表需要管理，每种对象都需要一个表，因此Redis中的范围分区通常是不可取的，因为它比其他替代分区方法效率低得多。</li>
</ul>
</li>
<li><strong>hash partitioning</strong>：该方案适用于任何键，不需要所有键都以这样的格式<code>object_name:&lt;id&gt;</code>，并且非常简单。<ul>
<li>获取键名并使用散列函数（例如，<code>crc32</code>散列函数）将其转换为数字。例如，如果键是<code>foobar</code>，<code>crc32(foobar)</code>将输出类似<code>93024922</code>.</li>
<li>对这个数字使用模运算，将它转换成一个 0 到 3 之间的数字，这样这个数字就可以映射到我的四个 Redis 实例之一。<code>93024922 modulo 4</code>equals <code>2</code>，所以我知道我的key<code>foobar</code>应该存储到<strong>R2</strong>实例中。<em>注意：模运算返回除法运算的余数，在许多编程语言中使用<code>%</code>运算符实现。</em></li>
</ul>
</li>
</ul>
<p>还有许多其他方法可以执行分区，但通过这两个示例，您应该了解了要点。哈希分区的一种高级形式被称为一致哈希，有少量Redis客户端和代理实现。</p>
<h2 id="5-2-分区的不同实现"><a href="#5-2-分区的不同实现" class="headerlink" title="5.2 分区的不同实现"></a>5.2 分区的不同实现</h2><p>分区可以由软件栈的不同部分（环节）负责。</p>
<ul>
<li><strong>客户端分区</strong>意味着客户端直接选择正确的节点来写入或读取给定的键。许多 Redis 客户端实现了客户端分区。</li>
<li><strong>代理辅助分区</strong>意味着我们的客户端将请求发送到能够使用 Redis 协议的代理，而不是直接将请求发送到正确的 Redis 实例。代理将确保根据配置的分区模式将我们的请求<strong>转发</strong>到正确的 Redis 实例，并将回复发送回客户端。Redis 和 Memcached 代理<a target="_blank" rel="noopener" href="https://github.com/twitter/twemproxy">Twemproxy</a>实现了代理辅助分区。</li>
<li><strong>查询路由</strong>意味着您可以将查询发送到随机实例，该实例将确保将您的查询转发到正确的节点。Redis Cluster 在客户端的帮助下实现了一种混合形式的查询路由（请求不是直接从 Redis 实例转发到另一个实例，而是客户端被<em><strong>重定向</strong></em>到正确的节点）。</li>
</ul>
<h2 id="5-3-分区的缺点"><a href="#5-3-分区的缺点" class="headerlink" title="5.3 分区的缺点"></a>5.3 分区的缺点</h2><p>Redis 的一些特性在分区时不能很好地发挥作用：</p>
<ul>
<li>通常不支持涉及多个键的操作。例如，如果两个集合存储在映射到不同 Redis 实例的键中，则不能执行它们之间的交集（实际上有方法可以做到这一点，但不是直接的）。</li>
<li>不能使用涉及多个键的Redis事务。</li>
<li>分区粒度是关键，因此不可能像非常大的排序集那样使用单个巨大的键对数据集进行分片。</li>
<li>使用分区时，数据处理更加复杂，例如您必须处理多个 RDB / AOF 文件，并且要备份您的数据，您需要聚合来自多个实例和主机的持久性文件。</li>
<li>添加和删除容量可能很复杂。例如，Redis Cluster 支持大部分透明的数据重新平衡，能够在运行时添加和删除节点，但其他系统（如客户端分区和代理）不支持此功能。然而，一种称为<em>预分片</em>的技术在这方面<em>有所</em>帮助。</li>
</ul>
<h2 id="5-4-数据存储还是缓存？"><a href="#5-4-数据存储还是缓存？" class="headerlink" title="5.4 数据存储还是缓存？"></a>5.4 数据存储还是缓存？</h2><p>尽管 Redis 中的分区在概念上是相同的，无论是将 Redis 用作数据存储还是缓存，但将其用作数据存储时存在重大限制。当 Redis 用作数据存储时，给定的键必须始终映射到同一个 Redis 实例。当Redis用作缓存时，如果给定节点不可用，使用不同的节点也不是大问题，改变key-instance映射，因为我们希望提高系统的<em>可用性</em>（即系统回复我们的查询）。</p>
<p>如果给定键的首选节点不可用，则一致的散列实现通常能够切换到其他节点。同样，如果添加新节点，部分新key将开始存储在新节点上。</p>
<p>这里的主要概念如下：</p>
<ul>
<li>如果将 Redis 用作缓存<strong>，则</strong>使用一致散列<strong>扩展和缩减</strong>是很容易的。</li>
<li>如果Redis用作存储，则使用<strong>固定的key-to-nodes映射，因此节点数必须固定且不能变化</strong>。否则，需要一个能够在添加或删除节点时在节点之间重新平衡键的系统，目前只有 Redis Cluster 能够做到这一点 - Redis Cluster<a target="_blank" rel="noopener" href="https://groups.google.com/d/msg/redis-db/dO0bFyD_THQ/Uoo2GjIx6qgJ">已于 2015 年 4 月 1 日全面</a>可用且可用于生产。</li>
</ul>
<blockquote>
<p>Y：目前Redis的主要用途依旧是缓存而不是存储。</p>
</blockquote>
<h2 id="5-5-预分片"><a href="#5-5-预分片" class="headerlink" title="5.5 预分片"></a>5.5 预分片</h2><p>由于 Redis 占用空间极小且轻量级（一个备用实例使用 1 MB 内存），因此解决此问题的一个简单方法是从一开始就从大量实例开始。即使您只从一台服务器开始，您也可以决定从一开始就生活在分布式世界中，并使用分区在您的单个服务器上运行多个 Redis 实例。</p>
<h1 id="6-Redis-持久化策略"><a href="#6-Redis-持久化策略" class="headerlink" title="6. Redis 持久化策略"></a>6. Redis 持久化策略</h1><p><strong>持久化概念</strong></p>
<p>Redis支持 将内存中的数据持久化到磁盘中,在下次启动redis时可以将磁盘中的数据加载到内存中。</p>
<p><strong>持久化通用的两种方式</strong></p>
<ul>
<li>快照(某一时刻对数据的备份)<br>例如：mmysql dump、redis RDB</li>
<li>记录日志()<br>例如：Mysql binlog、Hbase Hlog、redis AOF</li>
</ul>
<h2 id="6-1-Redis持久化之-RDB-Redis-database"><a href="#6-1-Redis持久化之-RDB-Redis-database" class="headerlink" title="6.1 Redis持久化之 RDB(Redis database)"></a>6.1 Redis持久化之 RDB(Redis database)</h2><p><strong>RDB概念：</strong></p>
<p>Redis data  =&gt; data dump to disk =&gt; dump file （rdb文件）</p>
<p><strong>触发机制-主要三种方式：</strong></p>
<ul>
<li>save：同步，阻塞</li>
<li>bgsave：异步，非阻塞（阻塞仅仅会发生在fork出子进程）</li>
<li>自动(符合配置文件中 save满足条件)</li>
</ul>
<h2 id="6-2-Redis持久化之AOF-Append-only-file"><a href="#6-2-Redis持久化之AOF-Append-only-file" class="headerlink" title="6.2 Redis持久化之AOF(Append-only file)"></a>6.2 Redis持久化之AOF(Append-only file)</h2><p>client每次请求redis，都会将写请求的命令保存到文件中。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/webp-20210822233424914" alt="img"></p>
<p><strong>AOF三种策略</strong></p>
<ul>
<li>always：只要缓冲区有数据 立马写入文件中<ul>
<li>不丢失数据，磁盘开销较大,一般sata磁盘一秒只有几百TPS。</li>
</ul>
</li>
<li><strong>everysec</strong>：每隔一秒将数据从缓冲区写入文件中<ul>
<li>每秒一次fsync只丢失1秒数据。</li>
</ul>
</li>
<li>no：写文件的操作交由操作系统控制<ul>
<li>交由操作系统fsync,不用管，也不可控。</li>
</ul>
</li>
</ul>
<h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><p><strong>引入原因：</strong></p>
<p>随着数据的不断写入,会造成AOF文件不断增大,重复的命令会额外占用磁盘空间,而且增加redis重启速度。</p>
<p><strong>AOF重写定义：</strong></p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/webp-20210822234038823" alt="img"></p>
<p>AOF文件重写不是对原有AOF文件进行读取分析,而是读取最新的数据进行分析实现的。</p>
<p><strong>AOF重写作用：</strong></p>
<ol>
<li>减少磁盘占用量</li>
<li>加速启动速度</li>
</ol>
<p><strong>AOF重写触发机制</strong></p>
<ol>
<li>bgrewriteaof命令</li>
<li>AOF重写配置（同时满足配置文件中auto-aof-rewrite-percentage、auto-aof-rewrite-min-size两个配置）</li>
</ol>
<p><strong>AOF重写流程：</strong></p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/webp-20210822234537782" alt="img"></p>
<blockquote>
<p>问题：<br>    aof_rewrite是在子进程执行，子进程带有主进程数据副本,不会阻塞客户端请求，子进程在AOF重写期间,主进程依然需要会记录数据变化日志，就会出现当前数据与AOF重写之后的数据不一致。<br>解决方案：<br>    redis增加了一个aof_rewrite_buf(aof重写缓冲区),当主进程fork出子进程后开始启用,此时主进程需要将日志同时记录到aof_buf(aof缓冲区)与aof_ewrite_aof(aof重写缓冲区),当子进程重写完数据后给主进程发送信号,此时 主进程通过信号处理函数将aof_rewrite_buf数据追加到新aof文件后，替换旧aof文件。</p>
</blockquote>
<h2 id="6-3-混合持久化"><a href="#6-3-混合持久化" class="headerlink" title="6.3 混合持久化"></a>6.3 混合持久化</h2><p>重启 Redis 时，我们很少使用 rdb 来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 rdb 来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。 Redis 4.0 为了解决这个问题，带来了一个新的持久化选项——混合持久化。AOF在重写(aof文件里可能有太多没用指令，所以aof会定期根据内存的最新数据生成aof文件)时将重写这一刻之前的内存rdb快照文件的内容和增量的 AOF修改内存数据的命令日志文件存在一起，都写入新的aof文件，新的文件一开始不叫appendonly.aof，等到重写完新的AOF文件才会进行改名，原子的覆盖原有的AOF文件，完成新旧两个AOF文件的替换；<br> AOF根据配置规则在后台自动重写，也可以人为执行命令bgrewriteaof重写AOF。 于是在 Redis 重启的时候，可以先加载 rdb 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。</p>
<h1 id="7-Redis-的应用"><a href="#7-Redis-的应用" class="headerlink" title="7. Redis 的应用"></a>7. Redis 的应用</h1><h2 id="7-1-缓存的雪崩、击穿、穿透"><a href="#7-1-缓存的雪崩、击穿、穿透" class="headerlink" title="7.1 缓存的雪崩、击穿、穿透"></a>7.1 缓存的雪崩、击穿、穿透</h2><ul>
<li><p>缓存雪崩：当某一个时刻出现大规模的缓存失效的情况，那么就会导致大量的请求直接打在数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。这时候如果运维马上又重启数据库，马上又会有新的流量把数据库打死。这就是缓存雪崩。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/640_asljoijoabc" alt="图片"></p>
<ul>
<li><p>解决方法</p>
<ol>
<li><p>不同的key,可以设置不同的过期时间，让缓存失效的时间点不一致，尽量达到平均分布。</p>
<blockquote>
<p>Y：随机值可在【最小失效时间，原缓存时长定值】之间生成，如此将其缓存时间分散开。</p>
</blockquote>
</li>
<li><p>使用熔断机制。当流量到达一定的阈值时，就直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上。至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。</p>
</li>
<li><p>使用互斥锁</p>
<p>在缓存失效后，通过加锁或者队列来控制读和写数据库的线程数量。比如：对某个key只允许一个线程查询数据和写缓存，其他线程等待。单机的话，可以使用synchronized或者lock来解决，如果是分布式环境，可以是用redis的setnx命令来解决。</p>
</li>
<li><p>提高数据库的容灾能力，可以使用分库分表，读写分离的策略。</p>
</li>
<li><p>为了防止Redis宕机导致缓存雪崩的问题，可以搭建Redis集群，提高Redis的容灾性。</p>
</li>
<li><p>永远不过期。</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>缓存击穿：存在热点key，当热点key失效瞬间，大量原本对应该热点的请求因缓存失效而去查数据库，给数据库带来巨大压力。</p>
<ul>
<li>解决方法：<ol>
<li>使用互斥锁。同雪崩情况。</li>
<li>如果业务允许的话，对于热点的key可以设置永不过期的key。</li>
</ol>
</li>
</ul>
</li>
<li><p>缓存穿透：大量未命中key的请求。</p>
<ul>
<li>原因：1.业务自身代码或数据出现问题；2.一些恶意攻击、爬虫造成大量空的命中，此时会对数据库造成很大压力。</li>
<li>解决方法<ol>
<li>基于布隆过滤器过滤请求。见7.2</li>
<li>如果一个查询返回的数据为空，不管是数据不存在还是系统故障，我们仍然把这个结果进行缓存，但是它的过期时间会很短<br>最长不超过5分钟。假如传进来的这个不存在的Key值每次都是随机的，那存进Redis也没有意义。</li>
</ol>
</li>
</ul>
</li>
<li><p>上述两种方法都存在</p>
</li>
</ul>
<h2 id="7-2-布隆过滤器"><a href="#7-2-布隆过滤器" class="headerlink" title="7.2 布隆过滤器"></a>7.2 布隆过滤器</h2><p>布隆过滤器(BloomFilter)是由一个叫“布隆”的前辈在1970年提出的，它是一个很长的二进制向量，主要<strong>用于判断一个元素是否在一个集合中</strong>。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在介绍原理之前，要先讲一下<strong>Hash函数</strong>的概念。</p>
<p>我们在Java中的HashMap，HashSet其实也接触过hashcode()这个函数，哈希函数是可以将任意大小的输入数据转换成特定大小的输出数据的函数，转换后的数据称为<strong>哈希值</strong>。</p>
<p>哈希函数有以下特点：</p>
<ul>
<li>如果根据同一个哈希函数得到的哈希值不同，那么这两个哈希值的原始输入值肯定不同。</li>
<li>如果根据同一个哈希函数得到的两个哈希值相等，两个哈希值的原始输入值有可能相等，有可能不相等。</li>
</ul>
<p>布隆过滤器是由一个很长的二进制向量和一系列的哈希函数组成。那么布隆过滤器是怎么判断一个元素是否在一个集合中的呢？</p>
<p>假设布隆过滤器的底层存储结构是一个长度为16的位数组，初始状态时，它的所有位置都设置为0。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/v2-44745af66b87d954e59ee956bc6fcde8_720w.jpg" alt="img"></p>
<p>当有变量添加到布隆过滤器中，通过K个映射函数将变量映射到位数组的K个点，并把这K个点的值设置为1(假设有三个映射函数)。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/v2-d39c084b459972a1bfd7864bc6ff9921_720w.jpg" alt="img"></p>
<p>查询某个变量是否存在的时候，我们只需要通过同样的K个映射函数，找到对应的K个点，判断K个点上的值是否全都是1，<strong>如果全都是1则表示很可能存在</strong>，如果<strong>K个点上有任何一个是0则表示一定不存在</strong>。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>第一个问题，为什么说全都是1的情况是很可能存在，而不是一定存在呢？</p>
<p>还记得前面说的哈希函数的特点，根据同一个哈希函数得到相同的哈希值，输入值不一定相等。类似于Java中两个对象的hashcode相等，但是不一定相等的道理。说白了，映射函数得到位数组上映射点全都是1，不一定是要查询的这个变量之前存进来时设置的，也有可能是其他变量映射的点。</p>
<p>所以这里引出了布隆过滤器的其中一个特点，<strong>存在一定的误判</strong>。</p>
<p>第二个问题，布隆过滤器能不能删除元素呢？</p>
<p>答案是不能的。因为在位数组上的同一个点有可能有多个输入值映射，如果删除了会影响布隆过滤器里其他元素的判断结果。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/v2-38456fee3c0bd46d38d9fd8ce984faa8_720w.jpg" alt="img"></p>
<p>如上图，如果删除obj1，把4,7,15置为0，那么判断obj2是否存在时就会导致因为映射点7是0，结果判断obj2是不存在的，结果出错。</p>
<p>这是第二个特点，<strong>不能删除布隆过滤器里的元素。</strong></p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p>
<ul>
<li>在空间和时间方面，都有着巨大的优势。因为不是存完整的数据，是一个二进制向量，能节省大量的内存空间，时间复杂度方面，是根据映射函数查询，假设有K个映射函数，那么时间复杂度就是O(K)。</li>
<li>因为存的不是元素本身，而是二进制向量，所以在一些对<strong>保密性</strong>要求严格的场景有一定优势。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>存在一定的误判。</strong>存进布隆过滤器里的元素越多，误判率越高。</li>
<li><strong>不能删除布隆过滤器里的元素。</strong>随着使用的时间越来越长，因为不能删除，存进里面的元素越来越多，占用内存越来越多，误判率越来越高，最后不得不重置。</li>
</ul>
<h3 id="应用于缓存穿透"><a href="#应用于缓存穿透" class="headerlink" title="应用于缓存穿透"></a>应用于缓存穿透</h3><p><strong>用于缓解缓存穿透。</strong></p>
<p>​    缓存穿透的问题主要是因为传进来的key在Redis中是不存在的，那么就会直接打在DB上，造成DB压力增大。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/v2-ba08c0076931750ec07a0a3411ec3cb9_720w.jpg" alt="img"></p>
<p>针对这种情况，可以在Redis前加上布隆过滤器，预先把数据库中的数据加入到布隆过滤器中，因为布隆过滤器的底层数据结构是一个二进制向量，所以占用的空间并不是很大。<strong>在查询Redis之前先通过布隆过滤器判断是否存在，如果不存在就直接返回，如果存在的话，按照原来的流程还是查询Redis，Redis不存在则查询DB</strong>。</p>
<blockquote>
<p>Y：预存到布隆过滤器的数据可以基于数据库中数据如id，也可以基于Redis的key，视具体需求而定。一定要注意布隆过滤器不可删除元素。</p>
</blockquote>
<p>这里主要利用的是<strong>布隆过滤器判断结果是不存在的话就一定不存在</strong>这一个特点，但是由于布隆过滤器有一定的误判，所以并不能说完全解决缓存穿透，但是能很大程度缓解缓存穿透的问题。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/v2-ce8779e9d5a90b55719de6b3a25e2d35_720w.jpg" alt="img"></p>
<h3 id="布隆过滤器插件"><a href="#布隆过滤器插件" class="headerlink" title="布隆过滤器插件"></a>布隆过滤器插件</h3><p>在Redis4.0后，官方提供了布隆过滤器的插件功能，布隆过滤器可以作为一个插件加载到Redis服务器直接使用。</p>
<p>代码示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.15.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Config config = <span class="keyword">new</span> Config();</span><br><span class="line">    config.useSingleServer().setAddress(<span class="string">&quot;redis://192.168.0.109:6379&quot;</span>);</span><br><span class="line">    RedissonClient client = Redisson.create(config);</span><br><span class="line"></span><br><span class="line">    RBloomFilter&lt;String&gt; bloomFilter = client.getBloomFilter(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="comment">//尝试初始化，预计元素55000000，期望误判率0.03</span></span><br><span class="line">    bloomFilter.tryInit(<span class="number">55000000L</span>, <span class="number">0.03</span>);</span><br><span class="line">    <span class="comment">//添加元素到布隆过滤器中</span></span><br><span class="line">    bloomFilter.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    bloomFilter.add(<span class="string">&quot;mike&quot;</span>);</span><br><span class="line">    bloomFilter.add(<span class="string">&quot;rose&quot;</span>);</span><br><span class="line">    bloomFilter.add(<span class="string">&quot;blue&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;布隆过滤器元素总数为：&quot;</span> + bloomFilter.count());<span class="comment">//布隆过滤器元素总数为：4</span></span><br><span class="line">    System.out.println(<span class="string">&quot;是否包含tom：&quot;</span> + bloomFilter.contains(<span class="string">&quot;tom&quot;</span>));<span class="comment">//是否包含tom：true</span></span><br><span class="line">    System.out.println(<span class="string">&quot;是否包含lei：&quot;</span> + bloomFilter.contains(<span class="string">&quot;lei&quot;</span>));<span class="comment">//是否包含lei：false</span></span><br><span class="line">    client.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-3-Redis-分布式锁"><a href="#7-3-Redis-分布式锁" class="headerlink" title="7.3 Redis 分布式锁"></a>7.3 Redis 分布式锁</h2><p><a target="_blank" rel="noopener" href="https://redis.io/topics/distlock">官网描述</a></p>
<h3 id="7-3-1-安全（Safety）和活力（Liveness）保证"><a href="#7-3-1-安全（Safety）和活力（Liveness）保证" class="headerlink" title="7.3.1 安全（Safety）和活力（Liveness）保证"></a>7.3.1 安全（Safety）和活力（Liveness）保证</h3><p>我们将用三个属性对我们的设计进行建模，在我们看来，这三个属性是有效使用分布式锁所需的最小保证。</p>
<ol>
<li>Safety 属性:互斥。在任何给定时刻，只有一个客户端可以持有锁。</li>
<li>Liveness 属性A:无死锁。最终总是可以获得锁，即使锁定资源的客户端崩溃或被分区。</li>
<li>Liveness 特性B:容错性。只要大多数Redis节点都在运行，客户端就可以获取和释放锁。</li>
</ol>
<h3 id="7-3-2-初步实现思路"><a href="#7-3-2-初步实现思路" class="headerlink" title="7.3.2 初步实现思路"></a>7.3.2 初步实现思路</h3><p>Redis实现分布式锁主要利用Redis的<code>setnx</code>命令。<code>setnx</code>是<code>SET if not exists</code>(如果不存在，则 SET)的简写。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setnx lock value1 #在键lock不存在的情况下，将键key的值设置为value1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; setnx lock value2 #试图覆盖lock的值，返回0表示失败</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get lock #获取lock的值，验证没有被覆盖</span><br><span class="line">&quot;value1&quot;</span><br><span class="line">127.0.0.1:6379&gt; del lock #删除lock的值，删除成功</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; setnx lock value2 #再使用setnx命令设置，返回0表示成功</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get lock #获取lock的值，验证设置成功</span><br><span class="line">&quot;value2&quot;</span><br></pre></td></tr></table></figure>

<p>上面这几个命令就是最基本的用来完成分布式锁的命令。</p>
<p>加锁：使用<code>setnx key value</code>命令，如果key不存在，设置value(加锁成功)。如果已经存在lock(也就是有客户端持有锁了)，则设置失败(加锁失败)。</p>
<p>解锁：使用<code>del</code>命令，通过删除键值释放锁。释放锁之后，其他客户端可以通过<code>setnx</code>命令进行加锁。</p>
<p>key的值可以根据业务设置，比如是用户中心使用的，可以命令为<code>USER_REDIS_LOCK</code>，value可以使用uuid保证唯一，用于标识加锁的客户端。保证加锁和解锁都是同一个客户端。</p>
<p>那么接下来就可以写一段很简单的加锁代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long SUCCESS = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 加锁</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(String key, String requestId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用setnx命令。</span></span><br><span class="line">    <span class="comment">//不存在则保存返回1，加锁成功。如果已经存在则返回0，加锁失败。</span></span><br><span class="line">    <span class="keyword">return</span> SUCCESS.equals(jedis.setnx(key, requestId));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除key的lua脚本，先比较requestId是否相等，相等则删除</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEL_SCRIPT = <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 解锁</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unLock</span><span class="params">(String key, String requestId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//删除成功表示解锁成功</span></span><br><span class="line">    Long result = (Long) jedis.eval(DEL_SCRIPT, Collections.singletonList(key), Collections.singletonList(requestId));</span><br><span class="line">    <span class="keyword">return</span> SUCCESS.equals(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/640-20210825225135893" alt="图片"></p>
<p>这仅仅满足上述的第一个条件和第三个条件，保证上锁和解锁都是同一个客户端，也保证只有一个客户端持有锁。</p>
<p>但是第二点没法保证，因为如果一个客户端持有锁的期间突然崩溃了，就会导致无法解锁，最后导致出现死锁的现象。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/640-20210825225709149" alt="图片"></p>
<p>所以要有个超时的机制，在设置key的值时，需要加上有效时间，如果有效时间过期了，就会自动失效，就不会出现死锁。然后加锁的代码就会变成这样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(String key, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用jedis的api，保证原子性</span></span><br><span class="line">    <span class="comment">//NX 不存在则操作 EX 设置有效期，单位是秒</span></span><br><span class="line">    String result = jedis.set(key, requestId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, expireTime);</span><br><span class="line">    <span class="comment">//返回OK则表示加锁成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>.equals(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/640-20210825225825756" alt="图片"></p>
<h3 id="7-3-3-问题1：有效时间设置多长"><a href="#7-3-3-问题1：有效时间设置多长" class="headerlink" title="7.3.3 问题1：有效时间设置多长"></a>7.3.3 问题1：有效时间设置多长</h3><ol>
<li><p><strong>根据经验预测</strong></p>
</li>
<li><p><strong>锁续期</strong></p>
<p>在Redisson框架实现分布式锁的思路，就使用watchDog机制实现锁的续期。当加锁成功后，同时开启守护线程，默认有效期是30秒，每隔10秒就会给锁续期到30秒，只要持有锁的客户端没有宕机，就能保证一直持有锁，直到业务代码执行完毕由客户端自己解锁，如果宕机了自然就在有效期失效后自动解锁。</p>
</li>
</ol>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/640-20210825230049945" alt="图片"></p>
<h3 id="7-3-4-问题2：可重入锁的实现思路"><a href="#7-3-4-问题2：可重入锁的实现思路" class="headerlink" title="7.3.4 问题2：可重入锁的实现思路"></a>7.3.4 问题2：可重入锁的实现思路</h3><p>在Redisson实现可重入锁的思路，<strong>使用Redis的hash存储可重入次数</strong>，当加锁成功后，使用<code>hset</code>命令，value(重入次数)则是1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line"><span class="string">&quot;redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line"><span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line"><span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line"><span class="string">&quot;end; &quot;</span></span><br></pre></td></tr></table></figure>

<p>如果同一个客户端再次加锁成功，则使用<code>hincrby</code>自增加一。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line"><span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line"><span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line"><span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line"><span class="string">&quot;end; &quot;</span> +</span><br><span class="line"><span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/640-20210825230413827" alt="图片"></p>
<p>解锁时，先判断可重复次数是否大于0，大于0则减一，否则删除键值，释放锁资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title">unlockInnerAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line"><span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[3]) == 0) then &quot;</span> +</span><br><span class="line"><span class="string">&quot;return nil;&quot;</span> +</span><br><span class="line"><span class="string">&quot;end; &quot;</span> +</span><br><span class="line"><span class="string">&quot;local counter = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[3], -1); &quot;</span> +</span><br><span class="line"><span class="string">&quot;if (counter &gt; 0) then &quot;</span> +</span><br><span class="line"><span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]); &quot;</span> +</span><br><span class="line"><span class="string">&quot;return 0; &quot;</span> +</span><br><span class="line"><span class="string">&quot;else &quot;</span> +</span><br><span class="line"><span class="string">&quot;redis.call(&#x27;del&#x27;, KEYS[1]); &quot;</span> +</span><br><span class="line"><span class="string">&quot;redis.call(&#x27;publish&#x27;, KEYS[2], ARGV[1]); &quot;</span> +</span><br><span class="line"><span class="string">&quot;return 1; &quot;</span>+</span><br><span class="line"><span class="string">&quot;end; &quot;</span> +</span><br><span class="line"><span class="string">&quot;return nil;&quot;</span>,</span><br><span class="line">Arrays.&lt;Object&gt;asList(getName(), getChannelName()), LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/640-20210825230450124" alt="图片"></p>
<p>为了保证操作原子性，加锁和解锁操作都是使用lua脚本执行。</p>
<h3 id="7-3-5-问题3：加锁失败情况处理"><a href="#7-3-5-问题3：加锁失败情况处理" class="headerlink" title="7.3.5 问题3：加锁失败情况处理"></a>7.3.5 问题3：加锁失败情况处理</h3><p>上面的加锁方法是加锁后立即返回加锁结果，如果加锁失败的情况下，总不可能一直轮询尝试加锁，直到加锁成功为止，这样太过耗费性能。所以需要<strong>利用发布订阅的机制进行优化</strong>。</p>
<p><strong>步骤如下：</strong></p>
<ol>
<li>当加锁失败后，订阅锁释放的消息，自身进入阻塞状态；</li>
<li>当持有锁的客户端释放锁的时候，发布锁释放的消息；</li>
<li>当进入阻塞等待的其他客户端收到锁释放的消息后，解除阻塞等待状态，再次尝试加锁。</li>
</ol>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/640-20210825231200881" alt="图片"></p>
<h3 id="7-3-7-Redis分布式锁Java实现-Redisson"><a href="#7-3-7-Redis分布式锁Java实现-Redisson" class="headerlink" title="7.3.7 Redis分布式锁Java实现-Redisson"></a>7.3.7 Redis分布式锁Java实现-Redisson</h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/redisson/redisson/">Redisson</a>是架设在Redis基础上的一个Java驻内存数据网格（In-Memory Data Grid）。充分的利用了Redis键值数据库提供的一系列优势，基于Java实用工具包中常用接口，为使用者提供了一系列具有分布式特性的常用工具类。使得原本作为协调单机多线程并发程序的工具包获得了协调分布式多机多线程并发系统的能力，大大降低了设计和研发大规模分布式系统的难度。同时结合各富特色的分布式服务，更进一步简化了分布式环境中程序相互之间的协作。</p>
</blockquote>
<p>它里面也实现了分布式锁，而且包含多种类型的锁，更多请参阅<a target="_blank" rel="noopener" href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8">分布式锁和同步器</a>。</p>
<p><strong>使用Redisson中的可重入锁示例：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">或</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.15.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RLock;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.Config;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Config config = <span class="keyword">new</span> Config();</span><br><span class="line">    config.useSingleServer().setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>);</span><br><span class="line">    config.useSingleServer().setPassword(<span class="string">&quot;redis1234&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> RedissonClient client = Redisson.create(config);  </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      返回一个RedissonLock实例。</span></span><br><span class="line"><span class="comment">      RedissonLock 是 java.util.concurrent.locks.Lock 的分布式实现，实现可重入锁。 如果客户端断开连接，锁定将自动解除。</span></span><br><span class="line"><span class="comment">      实现非公平锁定，因此不保证获取顺序。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    RLock lock = client.getLock(<span class="string">&quot;lock1&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      	<span class="comment">// 获得锁。如果锁不可用，则当前线程将被禁用以用于线程调度目的并处于休眠状态，直到获得锁。</span></span><br><span class="line">        lock.lock();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">      	<span class="comment">// 释放锁。</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<blockquote>
<p>内容来源：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://redis.io/topics/data-types-intro">An introduction to Redis data types and abstractions</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/haoprogrammer/p/11065461.html">Redis(一)、Redis五种数据结构</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xuxh120/archive/2021/02/14/14400980.html">Redis五大类型及底层实现原理</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013709270/article/details/53470428">跳跃表的原理及实现</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/hunternet/p/11248192.html">Redis数据结构——跳跃表</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yangming1996/p/11709051.html">Redis 的底层数据结构（整数集合）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/60c9b231f62a">Redis中压缩列表的实现</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/152284892">Redis的过期策略和内存淘汰策略最全总结与分析</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/a3192048/article/details/82291222">LRU和LFU的区别</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/L-Test/p/11626124.html">Redis ==&gt; 集群的三种模式</a></li>
<li><a target="_blank" rel="noopener" href="https://redis.io/topics/cluster-tutorial">Redis cluster tutorial</a></li>
<li><a target="_blank" rel="noopener" href="https://redis.io/topics/partitioning"> Partitioning: how to split data among multiple Redis instances.</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ae47d69f92eb">3.redis持久化策略</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/348332384">什么是布隆过滤器？</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/vjof5CdJaRuoPMf6J5sMdA">Redis-缓存雪崩、缓存击穿、缓存穿透</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lzj3462144/article/details/78323589">【redis】redis的雪崩和穿透</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/FPt5rJIpHAe0psFo6inxUg">Redis如何实现分布式锁？</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/47fd7f86c848">分布式锁之Redis实现</a></li>
<li><a target="_blank" rel="noopener" href="https://redis.io/topics/distlock">Distributed locks with Redis</a></li>
</ol>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.coder.love/2021/08/19/IO-Model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="青马流光">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="青马流光的博客">
      <meta itemprop="description" content="学习笔记">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 青马流光的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/19/IO-Model/" class="post-title-link" itemprop="url">IO 模型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-19 14:23:44" itemprop="dateCreated datePublished" datetime="2021-08-19T14:23:44+08:00">2021-08-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-21 15:57:59" itemprop="dateModified" datetime="2022-03-21T15:57:59+08:00">2022-03-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>结构来源：I/O多路复用  -&gt;  应用：</p>
<p>​                                       -&gt;  Java中的多路复用  -&gt;  Netty中的多路复用  -&gt;  Redis中的多路复用  -&gt;  Nginx中的多路复用。</p>
<h1 id="1-Unix的五种I-O模型"><a href="#1-Unix的五种I-O模型" class="headerlink" title="1. Unix的五种I/O模型"></a>1. Unix的五种I/O模型</h1><p><strong>套接字</strong></p>
<p>套接字（socket）是一个抽象层，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。套接字允许应用程序将I/O插入到网络中，并与网络中的其他应用程序进行通信。</p>
<p>传输层实现端到端的通信，因此，每一个传输层连接有两个端点。传输层连接的端点叫做套接字（socket）。套接字就是主机的IP地址与一个16位的主机端口号的组合，即形如（主机IP地址：端口号）。例如，如果IP地址是210.37.145.1，而端口号是23，那么得到套接字就是（210.37.145.1:23）。</p>
<p><strong>套接字类型：</strong></p>
<ul>
<li>流式套接字（SOCK-STREAM）<ul>
<li>在TCP/IP协议簇中，基于TCP协议来实现字节流的传输。</li>
<li>它提供了一种可靠的、面向连接的双向数据传输服务，实现了数据无差错、无重复的发送。流式套接字内设流量控制，被传输的数据看作是无记录边界的字节流。</li>
<li>当用户想要发送大批量的数据或者对数据传输有较高的要求时，可以使用流式套接字。</li>
</ul>
</li>
<li>数据报套接字（SOCK-DGRAM）<ul>
<li>在TCP/IP协议簇中，基于UDP协议来实现数据报套接字。</li>
<li>它提供了一种无连接、不可靠的双向数据传输服务。数据报以独立的形式被发送，并且保留了记录边界，不提供可靠性保证。数据在传输过程中可能会丢失或重复，并且不能保证在接收端按发送顺序接收数据。</li>
<li>在出现差错的可能性较小或允许部分传输出错的应用场合，可以使用数据报套接字进行数据传输，这样通信的效率较高。</li>
</ul>
</li>
<li>原始套接字（SOCK-RAW）<ul>
<li>该套接字允许对较低层协议（如IP或ICMP）进行直接访问，常用于网络协议分析，检验新的网络协议实现，也可用于测试新配置或安装的网络设备。</li>
</ul>
</li>
</ul>
<p><strong>Linux上在socket 读写相关系统调用：</strong></p>
<ul>
<li>read &amp; write</li>
<li>recv &amp; send<ul>
<li>面向<strong>已连接</strong>的<strong>TCP</strong>/IP类型socket接收或发送数据。</li>
</ul>
</li>
<li>recvfrom &amp; sendto<ul>
<li>面向<strong>无连接</strong>的<strong>UDP</strong>数据报。</li>
</ul>
</li>
</ul>
<blockquote>
<p>注：下文中因内容来自不同文章，不用在意具体使用的系统调用名称。</p>
</blockquote>
<p><strong>基本 Unix I/O 模型的简单矩阵：</strong></p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/285763-20180124095638428-586748501.png" alt="img"></p>
<blockquote>
<p>Y：此处的同步、异步、阻塞、非阻塞是怎么区分的？</p>
<p>主要的疑问在于I/O多路复用为什么图中分为了异步阻塞。找到的一个我比较能接受的<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/59975081">解释</a>是：比如select()调用，用户层面程序会阻塞在这里，但是内核层会将其优化为异步事件通知，可能是因此而称之为异步。</p>
</blockquote>
<p>每个 I/O 模型都有自己的使用模式，它们对于特定的应用程序都有自己的优点。</p>
<p><strong>Unix的五种I/O模型：</strong>阻塞I/O、非阻塞I/O、I/O复用（select、poll、epoll）、信号驱动I/O（SIGIO）、异步I/O（Posix.1的aio_系列函数）。</p>
<p><strong>Unix的一个输入操作一般有两个不同的阶段：</strong></p>
<ol>
<li><p>等待数据准备好;</p>
</li>
<li><p>从内核到用户进程拷贝数据。</p>
<p>对于一个套接口上的输入操作，第一步一般是等待数据到达网络（Y：通过之前或者刚刚建立的网络连接），当分组到达时，它被拷贝到内核中的某个缓冲区；第二步是将数据从内核缓冲区拷贝到应用缓冲区。</p>
</li>
</ol>
<h2 id="1-1-阻塞I-O（blocking-IO）"><a href="#1-1-阻塞I-O（blocking-IO）" class="headerlink" title="1.1 阻塞I/O（blocking IO）"></a>1.1 阻塞I/O（blocking IO）</h2><p>应用程序调用一个IO函数，导致应用程序阻塞，如果数据已经准备好，从内核拷贝到用户空间，否则一直等待下去。</p>
<p>服务端为了处理客户端的连接和请求的数据，写了如下代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">listenfd = socket();   <span class="comment">// 打开一个网络通信端口</span></span><br><span class="line">bind(listenfd);        <span class="comment">// 绑定</span></span><br><span class="line">listen(listenfd);      <span class="comment">// 监听</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  connfd = accept(listenfd);  <span class="comment">// 阻塞建立连接</span></span><br><span class="line">  <span class="keyword">int</span> n = read(connfd, buf);  <span class="comment">// 阻塞读数据</span></span><br><span class="line">  doSomeThing(buf);  <span class="comment">// 利用读到的数据做些什么</span></span><br><span class="line">  close(connfd);     <span class="comment">// 关闭连接，循环等待下一个连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码会执行得磕磕绊绊，就像这样。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/640-asdbx_c.gif" alt="图片"></p>
<p>可以看到，服务端的线程阻塞在了两个地方，一个是 accept 函数，一个是 read 函数。</p>
<p>如果再把 read 函数的细节展开，我们会发现其阻塞在了两个阶段。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/640-20210819220724509_cut.gif" alt="图片"></p>
<p>这就是传统的阻塞 IO。</p>
<p>整体流程如下图：</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/640-asdfewe.png" alt="图片"></p>
<p>也可参考另一张读UDP数据报的图：</p>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/285763-20171206135021113-297824217.png" alt="img" style="zoom: 50%;" />

<blockquote>
<p>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</p>
</blockquote>
<h2 id="1-2-非阻塞I-O模型-（nonblocking-IO）"><a href="#1-2-非阻塞I-O模型-（nonblocking-IO）" class="headerlink" title="1.2 非阻塞I/O模型 （nonblocking IO）"></a>1.2 非阻塞I/O模型 （nonblocking IO）</h2><p>为了解决上面的问题，其关键在于改造这个 read 函数。</p>
<p><font color="8e8e8e">有一种聪明的办法是，每次都创建一个新的进程或线程，去调用 read 函数，并做业务处理。</font>&gt;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  connfd = accept(listenfd);  <span class="comment">// 阻塞建立连接</span></span><br><span class="line">  pthread_create（doWork);  <span class="comment">// 创建一个新的线程</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = read(connfd, buf);  <span class="comment">// 阻塞读数据</span></span><br><span class="line">  doSomeThing(buf);  <span class="comment">// 利用读到的数据做些什么</span></span><br><span class="line">  close(connfd);     <span class="comment">// 关闭连接，循环等待下一个连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="8e8e8e">这样，当给一个客户端建立好连接后，就可以立刻等待新的客户端连接，而不用阻塞在原客户端的 read 请求上。</font></p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/640-20210819221418782_c.gif" alt="图片"></p>
<p><font color="8e8e8e">不过，这不叫非阻塞 IO，只不过用了多线程的手段使得主线程没有卡在 read 函数上不往下走罢了。操作系统为我们提供的 read 函数仍然是阻塞的。</font></p>
<p>所以真正的非阻塞 IO，不能是通过我们用户层的小把戏，<strong>而是要恳请操作系统为我们提供一个非阻塞的 read 函数</strong>。</p>
<p>这个 read 函数的效果是，如果没有数据到达时（到达网卡并拷贝到了内核缓冲区），立刻返回一个错误值（-1），而不是阻塞地等待。</p>
<p>操作系统提供了这样的功能，只需要在调用 read 前，将文件描述符设置为非阻塞即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fcntl(connfd, F_SETFL, O_NONBLOCK);</span><br><span class="line"><span class="keyword">int</span> n = read(connfd, buffer) != SUCCESS);</span><br></pre></td></tr></table></figure>

<p>这样，就需要用户线程循环调用 read，直到返回值不为 -1，再开始处理业务。【轮询】</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/640-20210819222001434_c.gif" alt="图片"></p>
<p>这里我们注意到一个细节。</p>
<p>非阻塞的 read，指的是在数据到达前，即数据还未到达网卡，或者到达网卡但还没有拷贝到内核缓冲区之前，这个阶段是非阻塞的。</p>
<p>当数据已到达内核缓冲区，此时调用 read 函数仍然是阻塞的，需要等待数据从内核缓冲区拷贝到用户缓冲区，才能返回。</p>
<p>整体流程如下图</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/640-20210819222050286.png" alt="图片"></p>
<p>也可参考另一张读UDP数据报的图：</p>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/285763-20171206143532081-1051608968.png" alt="img" style="zoom:50%;" />

<blockquote>
<p>所以，nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有，第一阶段没有阻塞。</p>
</blockquote>
<h2 id="1-3-I-O多路复用模型（-IO-multiplexing）"><a href="#1-3-I-O多路复用模型（-IO-multiplexing）" class="headerlink" title="1.3 I/O多路复用模型（ IO multiplexing）"></a>1.3 I/O多路复用模型（ IO multiplexing）</h2><p>为每个客户端创建一个线程，服务器端的线程资源很容易被耗光。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/640-20210819222537196.png" alt="图片"></p>
<p><font color="8e8e8e">当然还有个聪明的办法，我们可以每 accept 一个客户端连接后，将这个文件描述符（connfd）放到一个数组里。</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdlist.add(connfd);</span><br></pre></td></tr></table></figure>

<p><font color="8e8e8e">然后弄一个新的线程去不断遍历这个数组，调用每一个元素的非阻塞 read 方法。</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span>(fd &lt;-- fdlist) &#123;</span><br><span class="line">    <span class="keyword">if</span>(read(fd) != <span class="number">-1</span>) &#123;</span><br><span class="line">      doSomeThing();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="8e8e8e">这样，我们就成功用一个线程处理了多个客户端连接。</font></p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/640-20210819222706208.gif" alt="图片"></p>
<p><font color="8e8e8e">你是不是觉得这有些多路复用的意思？</font></p>
<p><font color="8e8e8e">但这和我们用多线程去将阻塞 IO 改造成看起来是非阻塞 IO 一样，这种遍历方式也只是我们用户自己想出的小把戏，每次遍历遇到 read 返回 -1 时仍然是一次浪费资源的系统调用。</font></p>
<p><font color="8e8e8e">在 while 循环里做系统调用，就好比你做分布式项目时在 while 里做 rpc 请求一样，是不划算的。</font></p>
<p>所以，还是得恳请操作系统老大，提供给我们一个有这样效果的函数，我们将一批文件描述符通过一次系统调用传给内核，由内核层去遍历，才能真正解决这个问题。</p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>select 是操作系统提供的系统调用函数，通过它，我们可以把一个文件描述符的数组发给操作系统， 让操作系统去遍历，确定哪个文件描述符可以读写， 然后告诉我们去处理：</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/640-20210819223120652_c.gif" alt="图片"></p>
<p>select系统调用的函数定义如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">int</span> nfds,</span></span></span><br><span class="line"><span class="params"><span class="function">    fd_set *readfds,</span></span></span><br><span class="line"><span class="params"><span class="function">    fd_set *writefds,</span></span></span><br><span class="line"><span class="params"><span class="function">    fd_set *exceptfds,</span></span></span><br><span class="line"><span class="params"><span class="function">    struct timeval *timeout)</span></span>;</span><br><span class="line"><span class="comment">// nfds:监控的文件描述符集里最大文件描述符加1</span></span><br><span class="line"><span class="comment">// readfds：监控有读数据到达文件描述符集合，传入传出参数</span></span><br><span class="line"><span class="comment">// writefds：监控写数据到达文件描述符集合，传入传出参数</span></span><br><span class="line"><span class="comment">// exceptfds：监控异常发生达文件描述符集合, 传入传出参数</span></span><br><span class="line"><span class="comment">// timeout：定时阻塞监控时间，3种情况</span></span><br><span class="line"><span class="comment">//  1.NULL，永远等下去</span></span><br><span class="line"><span class="comment">//  2.设置timeval，等待固定时间</span></span><br><span class="line"><span class="comment">//  3.设置timeval里时间均为0，检查描述字后立即返回，轮询</span></span><br></pre></td></tr></table></figure>

<p>服务端代码，这样来写。</p>
<p>首先一个线程不断接受客户端连接，并把 socket 文件描述符放到一个 list 里。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  connfd = accept(listenfd);</span><br><span class="line">  fcntl(connfd, F_SETFL, O_NONBLOCK);</span><br><span class="line">  fdlist.add(connfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，另一个线程不再自己遍历，而是调用 select，将这批文件描述符 list 交给操作系统去遍历。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// 把一堆文件描述符 list 传给 select 函数</span></span><br><span class="line">  <span class="comment">// 有已就绪的文件描述符就返回，nready 表示有多少个就绪的</span></span><br><span class="line">  nready = select(<span class="built_in">list</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，当 select 函数返回后，用户依然需要遍历刚刚提交给操作系统的 list。</p>
<p>只不过，操作系统会将准备就绪的文件描述符做上标识，用户层将不会再有无意义的系统调用开销。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  nready = select(<span class="built_in">list</span>);</span><br><span class="line">  <span class="comment">// 用户层依然要遍历，只不过少了很多无效的系统调用</span></span><br><span class="line">  <span class="keyword">for</span>(fd &lt;-- fdlist) &#123;</span><br><span class="line">    <span class="keyword">if</span>(fd != <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="comment">// 只读已就绪的文件描述符</span></span><br><span class="line">      read(fd, buf);</span><br><span class="line">      <span class="comment">// 总共只有 nready 个已就绪描述符，不用过多遍历</span></span><br><span class="line">      <span class="keyword">if</span>(--nready == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如刚刚的动图中所描述的，其直观效果如下：</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/640-20210819223514651_c.gif" alt="图片"></p>
<p>可以看出几个细节：</p>
<ol>
<li><p>select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）</p>
</li>
<li><p>select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（<font color="ff0000">内核层可优化为异步事件通知。</font><font color="8e8e8e">Y：大概由此将多路复用归为了异步阻塞类型。</font>）</p>
</li>
<li><p>select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）。</p>
</li>
<li><p>Y：fd_set是一个bitmap，Linux上其默认大小为1024，限制了select能够处理的最大文件描述符数量即能处理的最大连接数。</p>
</li>
</ol>
<p>整个 select 的流程图如下：</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/640_1234123.png" alt="图片"></p>
<p>可以看到，这种方式，既做到了一个线程处理多个客户端连接（文件描述符），又减少了系统调用的开销（多个文件描述符只有一次 select 的系统调用 + n 次就绪状态的文件描述符的 read 系统调用）。</p>
<p>也可参考另一张读UDP数据报的图：</p>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/285763-20171206153548753-104901162.png" alt="img" style="zoom: 50%;" />

<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll 也是操作系统提供的系统调用函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, nfds_tnfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">  intfd; <span class="comment">/*文件描述符*/</span></span><br><span class="line">  shortevents; <span class="comment">/*监控的事件*/</span></span><br><span class="line">  shortrevents; <span class="comment">/*监控事件中满足条件返回的事件*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>它和 select 的主要区别就是，去掉了 select 只能监听 1024 个文件描述符的限制。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll 是最终的大 boss，它解决了 select 和 poll 的一些问题。</p>
<p>还记得上面说的 select 的三个细节么？</p>
<ol>
<li><p>select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）</p>
</li>
<li><p>select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）</p>
</li>
<li><p>select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）</p>
</li>
</ol>
<p>所以 epoll 主要就是针对这三点进行了改进。</p>
<ol>
<li><p>内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可。</p>
</li>
<li><p>内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。</p>
</li>
<li><p>内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。</p>
</li>
</ol>
<p>具体，操作系统提供了这三个函数。</p>
<p>第一步，创建一个 epoll 句柄</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

<p>第二步，向内核添加、修改或删除要监控的文件描述符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br></pre></td></tr></table></figure>

<p>第三步，类似发起了 select() 调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> max events, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>使用起来，其内部原理如下：</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/640-20210819225241422_c.gif" alt="图片"></p>
<p>epoll 的底层原理，详见《<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&mid=2247484905&idx=1&sn=a74ed5d7551c4fb80a8abe057405ea5e&chksm=a6e304d291948dc4fd7fe32498daaae715adb5f84ec761c31faf7a6310f4b595f95186647f12&scene=21#wechat_redirect">图解 | 深入揭秘 epoll 是如何实现 IO 多路复用的！</a>》</p>
<p>总结：</p>
<ul>
<li>IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。</li>
<li>多路复用产生的效果，完全可以由用户态去遍历文件描述符并调用其非阻塞的 read 函数实现。而多路复用快的原因在于，操作系统提供了这样的系统调用，使得原来的 while 循环里多次系统调用，变成了一次系统调用 + 内核层遍历这些文件描述符。<font color="ff0000">即减少大量的系统调用</font>。</li>
<li>如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是<strong>在于能在更快的时间里处理更多的连接</strong>。</li>
<li>Y：IO多路复用，好像是在用户程序与文件描述符之间加了一个代理，统一管理所有的连接，而且该代理是在内核态工作的，其与文件描述符之间的操作避免了系统调用。</li>
</ul>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/fba756b4985b7d3f879cd4b4108d315e.png-wh_600x-s_2279313183.png" alt="img"></p>
<h2 id="1-4-信号驱动I-O模型"><a href="#1-4-信号驱动I-O模型" class="headerlink" title="1.4 信号驱动I/O模型"></a>1.4 信号驱动I/O模型</h2><p>我们也可以用信号，让内核在描述符就绪时发送SIGIO信号通知我们。通过sigaction系统调用安装一个信号处理函数。该系统调用将立即返回，我们的进程继续工作，也就是说它没有被阻塞。当数据报准备好读取时，内核就为该进程产生一个SIGIO信号。我们随后既可以在信号处理函数中调用recvfrom读取数据报，并通知主循环数据已经准备好待处理。</p>
<p>优势：等待数据报到达期间进程不被阻塞。主循环可以继续执行，只要等待来自信号处理函数的通知：既可以是数据已准备好被处理，也可以是数据报已准备好被读取。</p>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/285763-20171206154310988-1910394971.png" alt="img" style="zoom:50%;" />

<h2 id="1-5-异步I-O模型（asynchronous-IO）"><a href="#1-5-异步I-O模型（asynchronous-IO）" class="headerlink" title="1.5 异步I/O模型（asynchronous IO）"></a>1.5 异步I/O模型（asynchronous IO）</h2><p>告知内核启动某个操作，并让内核在整个操作(包括将内核复制到我们自己的缓冲区)完成后通知我们。</p>
<p><strong>与信号驱动模型的主要区别在于：</strong>信号驱动式I/O是由内核通知我们何时可以启动一个I/O操作，而异步模型是由内核通知我们I/O操作何时完成。</p>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/285763-20171206154720019-1532624356.png" alt="img" style="zoom:50%;" />

<p>调用aio_read（Posix异步I/O函数以aio_或lio_开头）函数，给内核传递描述字、缓冲区指针、缓冲区大小（与read相同的3个参数）、文件偏移以及通知的方式，然后系统立即返回。我们的进程不阻塞于等待I/0操作的完成。当内核将数据拷贝到缓冲区后，再通知应用程序。 </p>
<p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>
<h2 id="1-6-各个IO-模型的比较"><a href="#1-6-各个IO-模型的比较" class="headerlink" title="1.6 各个IO 模型的比较"></a>1.6 各个IO 模型的比较</h2><img src="https://gitee.com/qmlg/image-bed/raw/master/images/285763-20171206155108581-1389952373.png" alt="img" style="zoom: 50%;" />

<h1 id="2-Java中的IO"><a href="#2-Java中的IO" class="headerlink" title="2. Java中的IO"></a>2. Java中的IO</h1><h2 id="2-1-基于字节的IO操作"><a href="#2-1-基于字节的IO操作" class="headerlink" title="2.1 基于字节的IO操作"></a>2.1 基于字节的IO操作</h2><h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h3><p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/InputStream_uml.jpeg" alt="img"></p>
<p>InputStream的作用表示那些从不同数据源产生输入的类，即其派生类多是不同数据源对应的流对象。如下：</p>
<ul>
<li><p>ByteArrayInputStream：从内存缓冲区读取字节数组</p>
</li>
<li><p>FileInputStream：从文件中读取字节，其构造参数可以是文件名、File对象或FileDescriptor</p>
</li>
<li><p>ObjectInputStream：主要用于反序列化，读取基本数据类型或对象</p>
</li>
<li><p>PipedInputStream：产生用于写入相关PipedOutputStream的数据，实现“管道化”概念，多用于多线程中。</p>
</li>
<li><p>FilterInputStream：作为<strong>装饰器类</strong>，其子类与上述不同流对象叠合使用，通过添加属性或有用的接口，以控制特定输入流。常见的有如下几个：</p>
<ul>
<li>DataInputStream：与DataOutputStream搭配使用，读取基本类型数据及String对象。</li>
<li>BufferdInputStream：使用缓冲区的概念，避免每次都进行实际读操作，提升I/O性能。<ul>
<li>不是减少磁盘IO操作次数（这个OS已经帮我们做了），而是通过减少系统调用次数来提高性能的。</li>
</ul>
</li>
<li>InflaterInputStream：其子类GZIPInputStream和ZipInputStream可以读取GZIP和ZIP格式的数据。</li>
</ul>
</li>
</ul>
<h3 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h3><p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/OutputStream_uml.jpeg" alt="img"></p>
<p>与InputStream相对应，OutputStream的作用表示将数据写入不同的数据源，常用的输出流对象如下：</p>
<ul>
<li><p>ByteArrayOutputStream：在内存中创建缓冲区，写入字节数组</p>
</li>
<li><p>FileOutputStream：将字节数据写入文件中，其构造参数可以是文件名、File对象或FileDescriptor</p>
</li>
<li><p>ObjectOutputStream：主要用于序列化，作用于基本数据类型或对象</p>
</li>
<li><p>PipedOutputStream：任何写入其中的数据，都会自动作为相关PipedInputStream的输出，实现“管道化”概念，多用于多线程中。</p>
</li>
<li><p>FilterOutputStream：作为装饰器类，其子类与上述不同流对象叠合使用，通过添加属性或有用的接口，以控制特定输出流。常见的几个如下：</p>
<ul>
<li>DataOutputStream：与DataInputStream搭配使用，写入基本类型数据及String对象。</li>
<li>PrintStream：用于格式化输出显示。</li>
<li>BufferdOutputStream：使用缓冲区的概念，避免每次都进行实际写操作，提升I/O性能。</li>
<li>DeflaterOutputStream：其子类GZIPOutputStream和ZipOutputStream可以写GZIP和ZIP格式的数据。</li>
</ul>
</li>
</ul>
<h2 id="2-2-基于字符的IO操作"><a href="#2-2-基于字符的IO操作" class="headerlink" title="2.2 基于字符的IO操作"></a>2.2 基于字符的IO操作</h2><p>不管是磁盘还是网络传输，数据处理的最小单元都是字节，而不是字符。故所有I/O操作的都是字节而不是字符。为了方便引入了字符操作，其中涉及字节到字符的转换适配，InputStreamReader可以把InputStream转为Reader，OutputStreamWriter可以把OutputStream转为Writer。对上述按字节操作的流对象，可以采用FilterInputStream和FilterOutputStream的装饰器子类控制流。Reader和Writer沿用相似的思想，但不完全相同。</p>
<h3 id="1-Reader类型"><a href="#1-Reader类型" class="headerlink" title="1. Reader类型"></a>1. Reader类型</h3><img src="https://gitee.com/qmlg/image-bed/raw/master/images/image-20210819164547736.png" alt="image-20210819164547736" style="zoom: 50%;" />

<p>继承自Reader类的，字符型数据来源常用类，如下：</p>
<ul>
<li><p>InputStreamReader：字节与字符适配器，子类包含FileReader（以字符形式读取文件）　</p>
</li>
<li><p>CharArrayReader：读取字符数组</p>
</li>
<li><p>StringReader：数据源是字符串</p>
</li>
<li><p>BufferedReader：读取字符输入流，并进行缓存， 表示采用缓存的方式从文件读取数据。</p>
<ul>
<li>常用法：<code>sql BufferedReader in = new BufferedReader(new FileReader(&quot;foo.in&quot;));</code></li>
</ul>
</li>
<li><p>PipedReader：管道形式读取字符　　</p>
</li>
<li><p>FilterReader：对Reader装饰，直接使用的不多，如PushbackReader</p>
</li>
</ul>
<h3 id="2-Writer类型"><a href="#2-Writer类型" class="headerlink" title="2. Writer类型"></a>2. Writer类型</h3><img src="https://gitee.com/qmlg/image-bed/raw/master/images/image-20210819165334081.png" alt="image-20210819165334081" style="zoom:50%;" />

<p>继承自Writer类的，字符型数据来源常用类，如下：</p>
<p>　　OutputStreamReader：字节与字符适配器，子类包含FileWriter（以字符形式写文件）　</p>
<p>　　CharArrayWriter：写字符数组</p>
<p>　　StringWriter：内部有StringBuffer，用于缓存构造字符串</p>
<p>　　BufferedWriter：字符输出流，常用法：PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(“foo.out”))); 表示将数据格式化并用缓存的方式写入文件</p>
<p>　　PipedWriter：管道形式输出字符　　</p>
<p>　　FilterWriter：对Writer装饰，如XMLWriter</p>
<h2 id="2-3-RandomAccessFile"><a href="#2-3-RandomAccessFile" class="headerlink" title="2.3 RandomAccessFile"></a>2.3 RandomAccessFile</h2><img src="https://gitee.com/qmlg/image-bed/raw/master/images/image-20210819165649577.png" alt="image-20210819165649577" style="zoom: 50%;" />

<p>此类的实例支持<strong>读取和写入随机访问文件</strong>。 随机访问文件的行为类似于存储在文件系统中的一个很大的字节数组。 有一种游标，或隐含数组的索引，称为<strong>文件指针</strong>； 输入操作从文件指针开始读取字节，并将文件指针前进到读取的字节之后。 如果随机存取文件是以 read/write 模式创建的，那么也可以进行输出操作； 输出操作从文件指针开始写入字节，并将文件指针前进到写入的字节之后。 写入超过隐含数组当前末尾的输出操作会导致数组被扩展。 文件指针可以通过<em>getFilePointer</em>方法读取并通过<em>seek</em>方法设置。<br>此类中的所有读取例程通常都是如此，如果在读取所需的字节数之前到达文件尾，则会抛出EOFException （这是IOException的一种）。 如果由于文件结束以外的任何原因无法读取任何字节，则抛出EOFException以外的IOException 。 特别是，如果流已关闭，则可能会抛出IOException 。</p>
<h2 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h2><ol>
<li><p>I/O操作本质是基于字节流的操作，InputStream和OutputStream对输入和输出源进行了抽象，其子类代表不同的数据源。</p>
</li>
<li><p>FilterInputStream和FilterOutputStream采用装饰器模式，对输入和输出流进行控制，如采用缓冲器、读基本数据类型等。</p>
</li>
<li><p>Reader和Writer代表基于字符的操作，底层是基于字节操作，经过InputStreamReader和OutputStreamWriter，采用StreamEncoder和StreamDecoder，将输入输出流，按Charset进行转换。</p>
</li>
<li><p>所有基于字节或字符的操作，基本都采用叠合的方式。如输入流采用缓存的方式从文件中读取，输出流采用缓存的方式按格式输出到文件。</p>
</li>
</ol>
<h1 id="3-Java中的NIO"><a href="#3-Java中的NIO" class="headerlink" title="3. Java中的NIO"></a>3. Java中的NIO</h1><p>新I/O（NIO）是JDK1.4引入的新Java I/O类库，目的在于提速，现在旧I/O也是基于NIO实现的。I/O包括文件I/O和网络I/O。速度的提升源自于所使用的结构更接近操作系统执行I/O的方式：<strong>通道和缓冲器</strong>。应用与缓冲器交互，缓冲器与通道交互。其中，最基础的与通道交互的是ByteBuffer，即用于存储字节的缓冲器。</p>
<p><strong>NIO的核心包括</strong>：通道（Channel）、缓冲器（ByteBuffer）和选择器（Selector）。其中通道与缓冲器交互方式如下图，缓冲器可以从通道读数据和写数据，通道与具体数据来源对应。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/1012728-20190126172139372-176112967.png" alt="img"></p>
<h2 id="3-1-通道"><a href="#3-1-通道" class="headerlink" title="3.1 通道"></a>3.1 通道</h2><p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/Channel.jpg" alt="Channel"></p>
<p>通道表示与实体的开放连接，可以通过通道进行读写。常用的通道有：</p>
<ul>
<li>FileChannel：用于读取、写入、映射和操作文件的通道。</li>
<li>SocketChannel：面向流的（stream-oriented）连接套接字的selectable通道。<ul>
<li>通过TCP读写网络中的数据。</li>
</ul>
</li>
<li>ServerSocketChannel：面向流的（stream-oriented）侦听套接字的selectable通道。<ul>
<li>可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。</li>
</ul>
</li>
<li>DatagramChanne：面向数据报的（datagram-oriented）套接字的selectable通道。<ul>
<li>通过UDP读写网络中的数据。</li>
</ul>
</li>
</ul>
<p>FileChannel用于本地磁盘文件的操作，后三者用于网络传输。</p>
<h3 id="3-1-1-FileChannel"><a href="#3-1-1-FileChannel" class="headerlink" title="3.1.1 FileChannel"></a>3.1.1 FileChannel</h3><p><strong>文件通道总是阻塞式的</strong>，因此不能被置于非阻塞模式。现代操作系统都有复杂的缓存和预取机制，使得本地磁盘I/O操作延迟很少。网络文件系统一般而言延迟会多些，不过却也因该优化而受益。面向流的I/O的非阻塞范例对于面向文件的操作并无多大意义，这是由文件I/O本质上的不同性质造成的。<strong>对于文件I/O，最强大之处在于异步I/O（asynchronous I/O）</strong>，它允许一个进程可以从操作系统请求一个或多个I/O操作而不必等待这些操作的完成。发起请求的进程之后会收到它请求的I/O操作已完成的通知。</p>
<p>　　FileChannel对象是线程安全（thread-safe）的。多个进程可以在同一个实例上并发调用方法而不会引起任何问题，不过并非所有的操作都是多线程的（multithreaded）。影响通道位置或者影响文件大小的操作都是单线程的（single-threaded）。如果有一个线程已经在执行会影响通道位置或文件大小的操作，那么其他尝试进行此类操作之一的线程必须等待。并发行为也会受到底层的操作系统或文件系统影响。</p>
<p>　　每个FileChannel对象都同一个文件描述符（file descriptor）有一对一的关系，所以上面列出的API方法与在您最喜欢的POSIX（可移植操作系统接口）兼容的操作系统上的常用文件I/O系统调用紧密对应也就不足为怪了。本质上讲，RandomAccessFile类提供的是同样的抽象内容。在通道出现之前，底层的文件操作都是通过RandomAccessFile类的方法来实现的。FileChannel模拟同样的I/O服务，因此它的API自然也是很相似的。</p>
<p>三者之间的方法对比：</p>
<table>
<thead>
<tr>
<th>FILECHANNEL</th>
<th>RANDOMACCESSFILE</th>
<th>POSIX SYSTEM CALL</th>
</tr>
</thead>
<tbody><tr>
<td>read( )</td>
<td>read( )</td>
<td>read( )</td>
</tr>
<tr>
<td>write( )</td>
<td>write( )</td>
<td>write( )</td>
</tr>
<tr>
<td>size( )</td>
<td>length( )</td>
<td>fstat( )</td>
</tr>
<tr>
<td>position( )</td>
<td>getFilePointer( )</td>
<td>lseek( )</td>
</tr>
<tr>
<td>position (long newPosition)</td>
<td>seek( )</td>
<td>lseek( )</td>
</tr>
<tr>
<td>truncate( )</td>
<td>setLength( )</td>
<td>ftruncate( )</td>
</tr>
<tr>
<td>force( )</td>
<td>getFD().sync( )</td>
<td>fsync( )</td>
</tr>
</tbody></table>
<p>下面是一个使用FileChannel读取数据到Buffer中的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.coder.love.demo.trys;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileChannelTry</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (</span><br><span class="line">      <span class="comment">// 方式1: 使用FileInputStream、FileOutputStream分别打开输入、输出 FileChannel。</span></span><br><span class="line">      FileInputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;./pom.xml&quot;</span>);</span><br><span class="line">      FileChannel iC = is.getChannel();</span><br><span class="line">      FileOutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;./tmp_out_pom.xml&quot;</span>);</span><br><span class="line">      FileChannel oC = os.getChannel()) &#123;</span><br><span class="line">      <span class="comment">//通道之间的数据传输：transferTo和transferFrom方法</span></span><br><span class="line">      iC.transferTo(<span class="number">0</span>, iC.size(), oC);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> (</span><br><span class="line">      <span class="comment">// 方式2: 使用RandomAccessFile打开FileChannel。</span></span><br><span class="line">        RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;./tmp_out_pom.xml&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">      <span class="comment">//1. 获取通道</span></span><br><span class="line">        FileChannel inChannel = aFile.getChannel()) &#123;</span><br><span class="line">      <span class="comment">//2. 创建缓冲区</span></span><br><span class="line">      ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">      <span class="comment">//3. 读取数据到缓冲区</span></span><br><span class="line">      <span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br><span class="line">      <span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Read: &quot;</span> + bytesRead);</span><br><span class="line">        buf.flip();</span><br><span class="line">        <span class="keyword">while</span> (buf.hasRemaining()) &#123;</span><br><span class="line">          System.out.print((<span class="keyword">char</span>) buf.get());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        buf.clear();</span><br><span class="line">        bytesRead = inChannel.read(buf);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;End.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Files.delete(Paths.get(<span class="string">&quot;./tmp_out_pom.xml&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>FileChannel不能直接获取，需要通过FileInputStream、FileOutputStream、RandomAccessFile来获取。</li>
<li>FileChannel 需要配合ByteBuffer（唯一直接与通道交互的缓冲器）来完成读写。</li>
</ul>
<h3 id="3-1-2-Socket-Channel"><a href="#3-1-2-Socket-Channel" class="headerlink" title="3.1.2 Socket Channel"></a>3.1.2 Socket Channel</h3><ul>
<li><p>新的socket通道类可以运行非阻塞模式并且是可选择的。</p>
</li>
<li><p>全部socket通道类（DatagramChannel、SocketChannel和ServerSocketChannel）在被实例化时都会创建一个<strong>对等socket对象</strong>。这些是我们所熟悉的来自java.net的类（Socket、ServerSocket和DatagramSocket），它们已经被更新以识别通道。对等socket可以通过调用socket( )方法从一个通道上获取。此外，这三个java.net类现在都有getChannel( )方法。</p>
</li>
<li><p>Socket通道将与通信协议相关的操作委托给相应的socket对象。socket的方法看起来好像在通道类中重复了一遍，但<strong>实际上通道类上的方法会有一些新的或者不同的行为</strong>。</p>
</li>
</ul>
<p>AbstractSelectableChannel</p>
<ul>
<li>此类定义了处理通道注册、取消注册和关闭机制的方法。 它保持该通道的当前阻塞模式及其当前的selection keys。 它完成实现SelectableChannel规范所需的所有同步。 此类中定义的抽象受保护方法的实现不需要与可能参与相同操作的其他线程同步。</li>
</ul>
<h4 id="3-1-2-1-ServerSocketChannel"><a href="#3-1-2-1-ServerSocketChannel" class="headerlink" title="3.1.2.1 ServerSocketChannel"></a>3.1.2.1 ServerSocketChannel</h4><p>ServerSocketChannel负责监听传入的连接和创建新的SocketChannel对象，它本身从不传输数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String GREETING = <span class="string">&quot;Hello I must be going.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">channelAccept</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> port = <span class="number">9123</span>;</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.wrap(GREETING.getBytes());</span><br><span class="line">    <span class="keyword">try</span> (ServerSocketChannel ssc = ServerSocketChannel.open()) &#123;</span><br><span class="line">      <span class="comment">// 设置监听的端口</span></span><br><span class="line">      ssc.socket().bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">      <span class="comment">// 设置accept方法是否阻塞。</span></span><br><span class="line">      ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Waiting for connections.&quot;</span>);</span><br><span class="line">        <span class="comment">// 监听新进来的连接。</span></span><br><span class="line">        SocketChannel sc = ssc.accept();</span><br><span class="line">        <span class="keyword">if</span> (sc == <span class="keyword">null</span>) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;sc is null.&quot;</span>);</span><br><span class="line">          Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;Incoming connection from: &quot;</span> + sc.socket().getRemoteSocketAddress());</span><br><span class="line">          buffer.rewind();</span><br><span class="line">          <span class="comment">// 响应，curl &quot;http://localhost:9123&quot;</span></span><br><span class="line">          sc.write(buffer);</span><br><span class="line">          sc.close();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-2-SocketChannel"><a href="#3-1-2-2-SocketChannel" class="headerlink" title="3.1.2.2 SocketChannel"></a>3.1.2.2 SocketChannel</h4><p>Java NIO中的SocketChannel是一个连接到TCP网络套接字的通道。可以通过以下2种方式创建SocketChannel：</p>
<ul>
<li>打开一个SocketChannel并连接到互联网上的某台服务器。</li>
<li>一个新连接到达ServerSocketChannel时，会创建一个SocketChannel。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">socketChannelTry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 内容可在浏览器中复制，&quot;Request -&gt; View source&quot;，但还是有问题，返回400。</span></span><br><span class="line">    String request =</span><br><span class="line">            <span class="string">&quot;GET /step/one HTTP/1.1 &quot;</span> + <span class="string">&quot;Host: localhost &quot;</span> + <span class="string">&quot;Connection: keep-alive &quot;</span></span><br><span class="line">                + <span class="string">&quot;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) &quot;</span></span><br><span class="line">                + <span class="string">&quot;Chrome/92.0.4515.159 Safari/537.36 &quot;</span></span><br><span class="line">                + <span class="string">&quot;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0&quot;</span></span><br><span class="line">                + <span class="string">&quot;.8,application/signed-exchange;v=b3;q=0.9 &quot;</span></span><br><span class="line">                + <span class="string">&quot;Accept-Encoding: gzip, deflate &quot;</span> + <span class="string">&quot;Accept-Language: zh-CN,zh;q=0.9&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> (SocketChannel socketChannel = SocketChannel.open()) &#123;</span><br><span class="line">      <span class="comment">// 设置为非阻塞</span></span><br><span class="line">      socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">      socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">      <span class="comment">// 轮询，直至连接建立。</span></span><br><span class="line">      <span class="keyword">while</span> (!socketChannel.finishConnect()) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 向SocketChannel中写入数据，即Http Request。</span></span><br><span class="line">      ByteBuffer wb = ByteBuffer.wrap(request.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">      <span class="comment">// 非阻塞模式下，write()方法在尚未写出任何内容时可能就返回了。所以需要在循环中调用write()。</span></span><br><span class="line">      <span class="keyword">while</span> (wb.hasRemaining()) &#123;</span><br><span class="line">        socketChannel.write(wb);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//从SocketChannel中读取数据</span></span><br><span class="line">      ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">      <span class="comment">// 非阻塞模式下,read()方法在尚未读取到任何数据时可能就返回了。所以需要关注它的int返回值，它会告诉你读取了多少字节。</span></span><br><span class="line">      <span class="keyword">int</span> bytesRead = socketChannel.read(buf);</span><br><span class="line">      <span class="keyword">boolean</span> readed = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bytesRead == <span class="number">0</span> &amp;&amp; readed) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytesRead == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buf.flip();</span><br><span class="line">        <span class="keyword">while</span> (buf.hasRemaining()) &#123;</span><br><span class="line">          System.out.print((<span class="keyword">char</span>) buf.get());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        buf.clear();</span><br><span class="line">        readed = <span class="keyword">true</span>;</span><br><span class="line">        bytesRead = socketChannel.read(buf);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(bytesRead);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>非阻塞模式与选择器搭配会工作的更好，通过将一或多个SocketChannel注册到Selector，可以询问选择器哪个通道已经准备好了读取，写入等。</li>
</ul>
<h4 id="3-1-2-3-DatagramChannel"><a href="#3-1-2-3-DatagramChannel" class="headerlink" title="3.1.2.3 DatagramChannel"></a>3.1.2.3 DatagramChannel</h4><ul>
<li>DatagramChannel则模拟包导向的无连接协议（如UDP/IP）。</li>
<li>每个数据报（datagram）都是一个自包含的实体，拥有它自己的目的地址及不依赖其他数据报的数据负载。</li>
</ul>
<h2 id="3-2-缓冲"><a href="#3-2-缓冲" class="headerlink" title="3.2 缓冲"></a>3.2 缓冲</h2><p>缓冲器除了基本的ByteBuffer外，还有CharBuffer、IntBuffer、ShortBuffer、LongBuffer、FloatBuffer、DoubleBuffer等基本类型缓冲器。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/1012728-20190126172205753-982325998.png" alt="img"></p>
<ul>
<li><p>仅ByteBuffer可直接与Channel交互，完成读写。</p>
</li>
<li><p>可以通过<strong>视图缓冲器</strong> 以特定基本数据类型查看底层的ByteBuffer，这个过程涉及编码的问题。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.wrap(<span class="keyword">new</span> <span class="keyword">byte</span>[] &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>&#125;);</span><br><span class="line">IntBuffer intBuffer = buffer.asIntBuffer();</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-3-选择器-gt-多路复用"><a href="#3-3-选择器-gt-多路复用" class="headerlink" title="3.3 选择器 -&gt; 多路复用"></a>3.3 选择器 -&gt; 多路复用</h2><p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/image-20210820143350800.png" alt="image-20210820143350800"></p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/image-20210820170510206.png" alt="image-20210820170510206"></p>
<p>选择器（Selector)</p>
<ul>
<li>SelectableChannel对象的<strong>多路复用器</strong>。</li>
<li>可以通过调用该类的 <code>open</code> 方法来创建选择器，该方法将使用系统默认的 <code>SelectorProvider</code> 来创建新的选择器。 也可以通过调用自定义选择器提供者的<code>openSelector</code>方法来创建选择器。 选择器保持打开状态，直到通过其<code>close</code>方法关闭为止。</li>
<li>一个 selectable channel 向选择器的注册由SelectionKey对象表示。 选择器维护三组选择键：<ul>
<li><strong><code>key set</code></strong> 包含着代表此选择器当前通道注册的键。 这个集合由keys方法返回。</li>
<li><strong><code>selected-key set</code></strong> 是这样一组key，在先前的选择操作期间，检测到每个键的通道为键的 <strong><code>interest set</code></strong> 中标识的至少一个操作做好了准备。 该集合由selectedKeys方法返回。 它始终是**<code>key set</code>** 的子集。</li>
<li><strong><code>cancelled-key set</code></strong> 是已经被取消但其通道还没有被注销的key集。 这个集合不能直接访问。 **<code>cancelled-key set</code><strong>集始终是</strong><code>key set</code>**的子集。</li>
</ul>
</li>
</ul>
<p><strong>interest集合</strong></p>
<p>Selector 监听四种不同类型的事件：</p>
<ol>
<li>Connect   -&gt;   SelectionKey.OP_CONNECT</li>
<li>Accept     -&gt;   SelectionKey.OP_ACCEPT</li>
<li>Read        -&gt;   SelectionKey.OP_READ</li>
<li>Write        -&gt;   SelectionKey.OP_WRITE</li>
</ol>
<p>如果对不止一种事件感兴趣，那么可以用“位或”操作符将常量连接起来，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个Selector</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line"><span class="comment">// channel必须设置为非阻塞的。</span></span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 将channel注册到selector上</span></span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">  <span class="comment">// select()阻塞到至少有一个通道在你注册的事件上就绪了。</span></span><br><span class="line">  <span class="keyword">int</span> readyChannels = selector.select();</span><br><span class="line">  <span class="keyword">if</span>(readyChannels == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="comment">// 可以遍历这个已选择的键集合来访问就绪的通道。</span></span><br><span class="line">  Set selectedKeys = selector.selectedKeys();</span><br><span class="line">  Iterator keyIterator = selectedKeys.iterator();</span><br><span class="line">  <span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>在每次迭代时, 我们都调用 “keyIterator.remove()” 将这个 key 从迭代器中删除, 因为 select() 方法仅仅是简单地将就绪的 IO 操作放到 selectedKeys 集合中, 因此如果我们从 selectedKeys 获取到一个 key, 但是没有将它删除, 那么下一次 select 时, 这个 key 所对应的 IO 事件还在 selectedKeys 中。<ul>
<li>例如此时我们收到 OP_ACCEPT 通知, 然后我们进行相关处理, 但是并没有将这个 Key 从 SelectedKeys 中删除, 那么下一次 select() 返回时 我们还可以在 SelectedKeys 中获取到 OP_ACCEPT 的 key.</li>
</ul>
</li>
<li> 我们可以动态更改 SekectedKeys 中的 key 的 interest set。 例如在 OP_ACCEPT 中, 我们可以将 interest set 更新为 OP_READ, 这样 Selector 就会将这个 Channel 的 读 IO 就绪事件包含进来了。</li>
</ul>
<p><strong>关于Selector执行选择的过程</strong></p>
<p>在每个选择操作期间，键可以被添加到选择器的选择键集中和从中删除，并且可以从其**<code>cancelled-key set</code><strong>和</strong><code>key set</code>**中删除。</p>
<p>选择由select() 、 select(long)和selectNow()方法执行，包括三个步骤：</p>
<ul>
<li>**<code>cancelled-key set</code><strong>中的每个key都从它所属的每个key set中删除，并取消其通道的注册。 此步骤将</strong><code>cancelled-key set</code>**置空。</li>
<li>在选择操作开始的那一刻，底层操作系统被查询关于每个剩余通道是否准备好执行由其键的兴趣集标识的任何操作的更新。 对于准备好进行至少一项此类操作的通道，将执行以下两个操作之一：<ul>
<li>如果通道的key不在**<code>selected-key set</code><strong>中，则将其添加到该集中，并修改其</strong><code>ready-operation set</code>** 以准确标识通道现在报告已准备就绪的那些操作。 任何先前记录在**<code>ready-operation set</code>**中的就绪信息都将被丢弃。</li>
<li>否则，通道的密钥已经在**<code>selected-key set</code><strong>中，因此它的</strong><code>ready-operation set</code>** 被修改以标识通道报告为准备就绪的任何新操作。 先前记录在**<code>ready-operation set</code><strong>中的任何就绪信息都将保留； 换句话说，底层系统返回的</strong><code>ready-operation set</code><strong>被逐位分解为键的当前</strong><code>ready-operation set</code><strong>。<br>如果在此步骤开始时</strong><code>key set</code><strong>中的所有键都具有空的兴趣集，则</strong><code>selected-key set</code><strong>和任何键的</strong><code>ready-operation set</code>**都不会更新。</li>
</ul>
</li>
<li>如果在执行步骤 (2) 时将任何键添加到**<code>cancelled-key set</code>**中，则它们将按照步骤 (1) 进行处理。</li>
</ul>
<p>选择操作是否阻塞等待一个或多个通道准备就绪，如果阻塞又等待多长时间，是三种选择方法之间唯一的本质区别。</p>
<p><strong>并发</strong></p>
<p>选择器本身对于多个并发线程使用是安全的； 然而，他们的键集不是。</p>
<p>在select()或select(long)方法之一中阻塞的线程可能会被其他线程以三种方式之一中断：</p>
<ul>
<li>通过调用选择器的wakeup方法；</li>
<li>通过调用选择器的close方法；</li>
<li>通过调用被阻塞线程的interrupt方法，在这种情况下将设置其中断状态并调用选择器的wakeup方法。</li>
</ul>
<h4 id="Selector-的实现"><a href="#Selector-的实现" class="headerlink" title="Selector 的实现"></a>Selector 的实现</h4><p>Selector.open()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> SelectorProvider.provider().openSelector();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SelectorProvider.provider()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为 Java 虚拟机的此调用返回系统范围的默认选择器提供程序。</span></span><br><span class="line"><span class="comment">	 * 此方法的第一次调用将定位默认提供程序对象，如下所示：</span></span><br><span class="line"><span class="comment">	 * 1. 如果定义了系统属性java.nio.channels.spi.SelectorProvider则它被视为具体提供者类的完全限定名称。 </span></span><br><span class="line"><span class="comment">	 * 类被加载并实例化； 如果此过程失败，则会引发未指定的错误。</span></span><br><span class="line"><span class="comment"> * 2. 如果提供程序类已安装在系统类加载器可见的 jar 文件中，并且该 jar 文件在资源目录META-INF/services 中包含名为	  </span></span><br><span class="line"><span class="comment"> * java.nio.channels.spi.SelectorProvider的提供程序配置文件，然后采用该文件中指定的第一个类名。 </span></span><br><span class="line"><span class="comment"> * 类被加载并实例化； 如果此过程失败，则会引发未指定的错误。</span></span><br><span class="line"><span class="comment">	 * 3. 最后，如果上述任何一种方式都没有指定提供者，则系统默认提供者类将被实例化并返回结果。</span></span><br><span class="line"><span class="comment">	 * 此方法的后续调用返回第一次调用返回的提供程序。</span></span><br><span class="line"><span class="comment">	 * 返回：系统范围的默认选择器提供程序</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">provider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">          <span class="keyword">if</span> (provider != <span class="keyword">null</span>)</span><br><span class="line">              <span class="keyword">return</span> provider;</span><br><span class="line">          <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">              <span class="keyword">new</span> PrivilegedAction&lt;SelectorProvider&gt;() &#123;</span><br><span class="line">                  <span class="function"><span class="keyword">public</span> SelectorProvider <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                          <span class="keyword">if</span> (loadProviderFromProperty())</span><br><span class="line">                              <span class="keyword">return</span> provider;</span><br><span class="line">                          <span class="keyword">if</span> (loadProviderAsService())</span><br><span class="line">                              <span class="keyword">return</span> provider;</span><br><span class="line">                          provider = sun.nio.ch.DefaultSelectorProvider.create();</span><br><span class="line">                          <span class="keyword">return</span> provider;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>sun.nio.ch下有两个SelectorProvider实现类</p>
<ul>
<li>KQueueSelectorProvider -&gt; KQueueSelectorImpl -&gt; doSelect -&gt; kqueueWrapper.poll -&gt; native kevent0</li>
<li>PollSelectorProvider -&gt; PollSelectorImpl -&gt; doSelect -&gt; pollWrapper.poll -&gt; native poll0</li>
</ul>
<p>可见最终是基于平台提供的实现了IO多路复用的系统调用函数（select、pool、epool、kqueue等）。</p>
<h1 id="4-Java-中的-AIO"><a href="#4-Java-中的-AIO" class="headerlink" title="4. Java 中的 AIO"></a>4. Java 中的 AIO</h1><p>同样基于事件驱动的思想，通常采用Proactor(前摄器模式)实现。在进行I/O操作时，直接调用API的read或write，这两种方法均为异步。对于读操作，操作系统将数据读到缓冲区，并通知应用程序，对于写操作，操作系统将write方法传递的流写入并主动通知应用程序。它节省了NIO中select函数遍历事件通知队列的代价(红黑树遍历)。</p>
<p>增加的新的类如下:</p>
<ul>
<li>AsynchronousChannel：支持异步通道，包括服务端AsynchronousServerSocketChannel和普通AsynchronousSocketChannel等实现。</li>
<li>CompletionHandler：用户处理器。定义了一个用户处理就绪事件的接口，由用户自己实现，异步io的数据就绪后回调该处理器消费或处理数据。</li>
<li>AsynchronousChannelGroup：一个用于资源共享的异步通道集合。处理IO事件和分配给CompletionHandler。</li>
</ul>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/image-20210821100932944.png" alt="image-20210821100932944"></p>
<p>另外，主要在java.nio.channels包下增加了下面四个异步通道：</p>
<ul>
<li>AsynchronousSocketChannel</li>
<li>AsynchronousServerSocketChannel</li>
<li>AsynchronousFileChannel</li>
</ul>
<p>AIO的实施需充分调用OS参与，IO需要操作系统支持、并发也同样需要操作系统的支持，所以性能方面不同操作系统差异会比较明显。因此在实际中AIO使用不是很广泛。</p>
<h2 id="Netty使用NIO放弃使用AIO的原因"><a href="#Netty使用NIO放弃使用AIO的原因" class="headerlink" title="Netty使用NIO放弃使用AIO的原因"></a>Netty使用NIO放弃使用AIO的原因</h2><p>Netty并没有使用AIO，只使用了NIO。</p>
<p>至于原因，先看下作者原话：</p>
<ul>
<li>Not faster than NIO (epoll) on unix systems (which is true)</li>
<li>There is no daragram suppport</li>
<li>Unnecessary threading model (too much abstraction without usage)</li>
</ul>
<p>扩展一下如下：</p>
<ol>
<li>Netty不看重Windows上的使用（这也不只是netty这一个开源框架的事）。在Linux2.6之后系统上，AIO的底层实现仍使用EPOLL，由于实现方式的不成熟，因此在性能上没有明显的优势，而且被JDK封装了一层不容易深度优化。</li>
<li>Netty整体架构是reactor模型, 而AIO是proactor模型, 混合在一起会非常混乱，把AIO也改造成reactor模型看起来是把epoll绕个弯又绕回来。</li>
<li>AIO有个重要的缺点是接收数据需要预先分配缓存，而NIO只需要在接收时才分配缓存, 所以对连接数量非常大但流量小的情况, 造成了大量的内存浪费。</li>
</ol>
<h1 id="5-零拷贝与直接内存映射"><a href="#5-零拷贝与直接内存映射" class="headerlink" title="5. 零拷贝与直接内存映射"></a>5. 零拷贝与直接内存映射</h1><h2 id="5-1-缓冲区与虚拟内存映射"><a href="#5-1-缓冲区与虚拟内存映射" class="headerlink" title="5.1 缓冲区与虚拟内存映射"></a>5.1 缓冲区与虚拟内存映射</h2><p>下面看一个java进程发起read请求加载数据大致的流程图：</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/16a057a50ad06f61~tplv-t2oaga2asx-watermark.image" alt="img"></p>
<p> 进程发起read请求之后，内核接收到read请求之后，会先检查内核空间中是否已经存在进程所需要的数据，如果已经存在，则直接把数据copy给进程的缓冲区；如果没有内核随即向磁盘控制器发出命令，要求从磁盘读取数据，磁盘控制器把数据直接写入内核read缓冲区，这一步通过DMA完成；接下来就是内核将数据copy到进程的缓冲区；<br>      如果进程发起write请求，同样需要把用户缓冲区里面的数据copy到内核的socket缓冲区里面，然后再通过DMA把数据copy到网卡中，发送出去。</p>
<p>所有现代操作系统都使用虚拟内存，使用虚拟的地址取代物理地址，这样做的好处是：<br>      1.一个以上的虚拟地址可以指向同一个物理内存地址，<br>      2.虚拟内存空间可大于实际可用的物理地址；<br>利用第一条特性可以把内核空间地址和用户空间的虚拟地址映射到同一个物理地址，这样DMA就可以填充对内核和用户空间进程同时可见的缓冲区了，大致如下图所示：</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/16a057ac4ffea504~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>
<h2 id="5-2-先读然后直接写情况下四种IO方式对比"><a href="#5-2-先读然后直接写情况下四种IO方式对比" class="headerlink" title="5.2 先读然后直接写情况下四种IO方式对比"></a>5.2 先读然后直接写情况下四种IO方式对比</h2><h3 id="5-2-1-缓存IO（Buffered-I-O）"><a href="#5-2-1-缓存IO（Buffered-I-O）" class="headerlink" title="5.2.1 缓存IO（Buffered I/O）"></a>5.2.1 缓存IO（Buffered I/O）</h3><p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/BufferIO1.png" alt="缓存IO"></p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/BufferIO2.png" alt="CacheIO"></p>
<p><strong>过程描述：</strong></p>
<ol>
<li>read()系统调用使上下文从用户态切换到内核态。DMA engine从磁盘中读取文件内容，然后把数据保存在内核地址空间缓存。</li>
<li>CPU从内核缓存复制数据到用户缓存，read()系统调用返回。Read()返回后，上下文从内核态切换到用户态。现在，数据储存在用户地址空间缓存。</li>
<li>write()系统调用使上下文从用户态切换到内核态。CPU把用户缓存中的数据复制到内核缓存中。这个内核缓存通常与某个特定的socket关联。</li>
<li>write()系统调用返回，使上下文从内核态切换到用户态。DMA engine把数据从内核缓存传递到protocal engine，这个过程是独立且异步的。独立且异步的意思是，write()返回不代表已经将所有数据写入到protocal engine，甚至不代表数据传输已经开始。write()返回仅仅表示Ethernet driver已经接受我们的数据传输，这项任务被置入一个队列。</li>
</ol>
<p>这种IO被称为缓存IO(buffered io). 当应用程序访问某块数据的时候，操作系统内核会先检查这块数据是不是因为前一次对相同文件的访问而已经被存放在操作系统内核地址空间的缓冲区(页缓存)内，如果在内核缓冲区中找不到这块数据，Linux操作系统内核会先将这块数据从磁盘读出来放到操作系统内核的缓冲区里去。</p>
<h3 id="5-2-2-直接IO（Direct-I-O）"><a href="#5-2-2-直接IO（Direct-I-O）" class="headerlink" title="5.2.2 直接IO（Direct I/O）"></a>5.2.2 直接IO（Direct I/O）</h3><p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/DirectIO.png" alt="DirectIO"></p>
<p>直接IO会把磁盘上的数据直接复制到用户地址空间，而不经过内核地址空间。直接IO适合自缓存应用(self-caching applications)。某些应用程序有自己的数据缓存机制，不需要使用操作系统内核缓存，这种应用程序称为自缓存应用。</p>
<blockquote>
<p>内核缓存区对读写磁盘数据做了优化,包括按顺序预读取,在成簇磁盘块上执行IO等等。因此在普通的应用中使用直接IO会降低性能。</p>
<p>一般会在数据库系统使用直接IO。数据库系统的高速缓存和IO优化机制均自成一体，无需内核消耗CPU时间和内存去完成相同的任务。</p>
<p>直接IO中read和write的行为必须是同步的，但是O_DIRECT不保证同步，因此O_DIRECT必须与O_SYNC连用来保证同步行为。</p>
<p>请慎用。</p>
</blockquote>
<h3 id="5-2-3-零拷贝：mmap-write"><a href="#5-2-3-零拷贝：mmap-write" class="headerlink" title="5.2.3 零拷贝：mmap + write"></a>5.2.3 零拷贝：mmap + write</h3><p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/mmp_write1.png" alt="mmp_write1"></p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/mmp_write2.png" alt="mmp_write2"></p>
<p><strong>过程描述：</strong></p>
<ol>
<li>mmap()系统调用使上下文从用户态切换到内核态。DMA engine从磁盘中读取文件内容，然后把数据保存在内核地址空间缓存。CPU将该内核缓存区与用户进程共享。</li>
<li>write()系统调用使上下文从用户态切换到内核态。 CPU把数据从原来的内核缓存复制到另一片与socket关联的内核缓存区。</li>
<li>write()系统调用返回，使上下文从内核态切换到用户态。DMA engine把数据从内核缓存传递到protocal engine。</li>
</ol>
<p><strong>使用mmap()代替read()可以减少一次CPU copy，但增加了share动作</strong>。当复制的数据量很大，一次CPU copy的花费大于share的花费时，使用mmap()代替read()是能优化性能的。但是，mmap()+write()有一个陷阱：You will fall into one of them when you memory map a file and then call write while another process truncates the same file.write()系统调用会被信号SIGBUS中断，这个信号的默认动作是kill进程然后dump core。作为一个server程序，我们通常不希望被KILL。我们有两种方法解决这个问题：</p>
<ol>
<li>第一个方法是修改SIGBUS的信号处理程序，将其改为简单的return。这样，SIGBUS信号就不会kill进程，write()会返回被信号中断前已经成功写入的字符数，并设置errno。但是当该进程因其他问题收到SIGBUS信号时，却也简单的return了，这会掩盖运行时出现的巨大问题。因此，不推荐使用方法一。</li>
<li>第二个方法是使用文件租借锁 (windows系统中称为opportunistic lock)。让进程a获得租借锁，当进程b对正在传输的文件进行截断时，内核会给进程a发送信号，进程a会被中断，以防止该进程访问到无效地址并被SIGBUS中断。进程a的write()会返回中断前写入的字符数，并设置errno。以下是租借锁的示例代码</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* l_type can be F_RDLCK F_WRLCK */</span></span><br><span class="line"><span class="keyword">if</span>(fcntl(fd, F_SETLEASE, l_type))&#123;</span><br><span class="line">    perror(<span class="string">&quot;kernel lease set type&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你应该在mapping file前获得租借锁，在你完成写之后释放租借锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fcntl(fd, F_SETLEASE, F_UNLCK)</span><br></pre></td></tr></table></figure>

<h3 id="5-2-4-零拷贝：sendfile"><a href="#5-2-4-零拷贝：sendfile" class="headerlink" title="5.2.4 零拷贝：sendfile"></a>5.2.4 零拷贝：sendfile</h3><p>CPU copy次数取决于硬件是否支持gather operation。</p>
<p><strong>如果硬件不支持gather operation：</strong></p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/zero_copy1.png" alt="zero_copy1"></p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/zero_copy2.png" alt="zero_copy2"></p>
<p><strong>过程描述：</strong></p>
<ol>
<li>sendfile()系统调用使上下文从用户态切换到内核态。DMA engine把文件内容复制到内核缓存区。然后CPU把该内核缓存区的数据复制到另一片与socket关联的内核缓存区。</li>
<li>sendfile()系统调用返回，使上下文从内核态切换到用户态。DMA engine把数据从内核缓存传递到protocal engine。</li>
</ol>
<p>如果调用sendfile()时，文件被截断。sendfile()会在在访问到无效地址前返回，以防止被SIGBUS信号中断。</p>
<p><strong>如果硬件支持gather operation,且Linux2.4以上：</strong></p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/zero_copy3.png" alt="zero_copy3"></p>
<p>数据不会从kernel buffer复制到sokcet buffer，仅会把包含kernel buffer地址和长度的信息的描述符append到socket buffer，DMA engine会把数据从kernel buffer直接传到protocol engine。</p>
<p><strong>sendfile()如果想要做到zero copy，那么被读文件的未写入到被写文件的部分不能被修改。</strong></p>
<blockquote>
<p>目前sendfile()由splice()实现的，是对splice()的包装。</p>
<p>splice() moves data between two file descriptors without copying between kernel address space and user address space.</p>
<p>但是两个fd中必须有一个是pipe。<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/24254098/does-linux-have-zero-copy-splice-or-sendfile">Stack over flow的Damon</a>不建议使用splice(),因为现在的实现不够完善。</p>
</blockquote>
<h2 id="5-3-Java-零拷贝"><a href="#5-3-Java-零拷贝" class="headerlink" title="5.3 Java 零拷贝"></a>5.3 Java 零拷贝</h2><p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/image-20210821114002614.png" alt="image-20210821114002614"></p>
<h3 id="5-3-1-MappedByteBuffer"><a href="#5-3-1-MappedByteBuffer" class="headerlink" title="5.3.1 MappedByteBuffer"></a>5.3.1 MappedByteBuffer</h3><p>java nio提供的<strong>FileChannel</strong>提供了<strong>map()<strong>方法，该方法可以在一个打开的文件和MappedByteBuffer之间建立一个</strong>虚拟内存映射</strong>，MappedByteBuffer继承于ByteBuffer，类似于一个基于内存的缓冲区，只不过该对象的数据元素存储在磁盘的一个文件中；调用get()方法会从磁盘中获取数据，此数据反映该文件当前的内容，调用put()方法会更新磁盘上的文件，并且对文件做的<strong>修改</strong>对其他阅读者也是<strong>可见</strong>的；下面看一个简单的读取实例，然后在对MappedByteBuffer进行分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedByteBufferTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;./db.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> len = file.length();</span><br><span class="line">        <span class="keyword">byte</span>[] ds = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) len];</span><br><span class="line">        MappedByteBuffer mappedByteBuffer = <span class="keyword">new</span> FileInputStream(file).getChannel().map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>,</span><br><span class="line">                len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> offset = <span class="number">0</span>; offset &lt; len; offset++) &#123;</span><br><span class="line">            <span class="keyword">byte</span> b = mappedByteBuffer.get();</span><br><span class="line">            ds[offset] = b;</span><br><span class="line">        &#125;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> ByteArrayInputStream(ds)).useDelimiter(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (scan.hasNext()) &#123;</span><br><span class="line">            System.out.print(scan.next() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要通过FileChannel提供的map()来实现映射，map()方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将此通道的文件的一个区域（region）直接映射到内存中。</span></span><br><span class="line"><span class="comment"> * 文件的一个区域可以以三种模式之一映射到内存:</span></span><br><span class="line"><span class="comment"> * 1. Read-only: 任何修改结果缓冲区的尝试都将导致抛出java.nio.ReadOnlyBufferException. (MapMode.READ_ONLY)</span></span><br><span class="line"><span class="comment"> * 2. Read/write: 对生成的缓冲区所做的更改最终将传播到文件;它们可能对映射了同一文件的其他程序可见，也可能不可见。 </span></span><br><span class="line"><span class="comment"> * (MapMode.READ_WRITE)</span></span><br><span class="line"><span class="comment"> * 3. Private: 对生成的缓冲区所做的更改将不会传播到文件中，并且对映射了同一文件的其他程序也不可见;</span></span><br><span class="line"><span class="comment"> * 相反，它们将导致创建缓冲区中 已修改部分的私有副本。(MapMode.PRIVATE)</span></span><br><span class="line"><span class="comment"> * 对于只读映射，此通道必须已打开用于读取； 对于读/写或私有映射，必须已打开此通道用于读和写。</span></span><br><span class="line"><span class="comment"> * 此方法返回的mapped byte buffer的位置为零，限制和容量为size ；它的标记将是未定义的。 </span></span><br><span class="line"><span class="comment"> * 缓冲区及其表示的映射将保持有效，直到缓 冲区本身被垃圾收集。</span></span><br><span class="line"><span class="comment"> * 映射一旦建立，就不再依赖于用于创建它的文件通道。 特别是关闭通道对映射的有效性没有影响。</span></span><br><span class="line"><span class="comment"> * 内存映射文件的许多细节本质上取决于底层操作系统，因此未指定。 当请求的区域未完全包含在此通道的文件中时，此方法的行为未指定。 </span></span><br><span class="line"><span class="comment"> * 未指定此程序或其他程序对基础文件的内容或大小所做的更改是否传播到缓冲区。 未指定缓冲区更改传播到文件的速率。</span></span><br><span class="line"><span class="comment"> * 对于大多数操作系统，文件映射到内存比通过一般的read和write读写几十k字节数据更昂贵。 </span></span><br><span class="line"><span class="comment"> * 从性能的角度来看，通常只值得将相对较大的文  件映射到内存中。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> MappedByteBuffer <span class="title">map</span><span class="params">(MapMode mode,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">long</span> position, <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-2-DirectByteBuffer"><a href="#5-3-2-DirectByteBuffer" class="headerlink" title="5.3.2 DirectByteBuffer"></a>5.3.2 DirectByteBuffer</h3><p>DirectByteBuffer继承于MappedByteBuffer，从名字就可以猜测出开辟了一段直接内存，并不会占用jvm的内存空间；上一节中通过Filechannel映射出的MappedByteBuffer其实际也是DirectByteBuffer，当然除了这种方式，也可以手动开辟一段空间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开辟100字节的直接内存空间。</span></span><br><span class="line">ByteBuffer directByteBuffer = ByteBuffer.allocateDirect(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<h3 id="5-3-3-Channel-to-Channel传输"><a href="#5-3-3-Channel-to-Channel传输" class="headerlink" title="5.3.3 Channel-to-Channel传输"></a>5.3.3 Channel-to-Channel传输</h3><p>经常需要从一个位置将文件传输到另外一个位置，FileChannel提供了transferTo()方法用来提高传输的效率，首先看一个简单的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelTransfer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String files[]=<span class="keyword">new</span> String[<span class="number">1</span>];</span><br><span class="line">        files[<span class="number">0</span>]=<span class="string">&quot;D://db.txt&quot;</span>;</span><br><span class="line">        catFiles(Channels.newChannel(System.out), files);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">catFiles</span><span class="params">(WritableByteChannel target, String[] files)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; files.length; i++) &#123;</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(files[i]);</span><br><span class="line">            FileChannel channel = fis.getChannel();</span><br><span class="line">            channel.transferTo(<span class="number">0</span>, channel.size(), target);</span><br><span class="line">            channel.close();</span><br><span class="line">            fis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过FileChannel的transferTo()方法将文件数据传输到System.out通道，接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将字节从此通道的文件传输到给定的可写字节通道。</span></span><br><span class="line"><span class="comment"> * 尝试从该通道文件中的给定位置开始读取count个字节并将它们写入目标通道。调用此方法可能会也可能不会传输所有请求的字节；是否这样做 </span></span><br><span class="line"><span class="comment"> * 取决于通道的性质和状态。如果此通道的文件从给定位置开始包含少于count个字节，或者如果目标通道是非阻塞的并且其输出缓冲区中的空闲</span></span><br><span class="line"><span class="comment"> * 字节少于count个字节，则传输的字节数少于请求的字节数。</span></span><br><span class="line"><span class="comment"> * 此方法不会修改此通道的位置。 如果给定的位置大于文件的当前大小，则不会传输任何字节。 如果目标通道有一个位置，则从该位置开始写入	* 字节，然后该位置增加写入的字节数。</span></span><br><span class="line"><span class="comment"> * 这种方法可能比从该通道读取并写入目标通道的简单循环更有效。许多操作系统可以将字节直接从文件系统缓存传输到目标通道，而无需实际复</span></span><br><span class="line"><span class="comment"> * 制它们。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">transferTo</span><span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> count,</span></span></span><br><span class="line"><span class="params"><span class="function">                                WritableByteChannel target)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-Netty零拷贝"><a href="#5-4-Netty零拷贝" class="headerlink" title="5.4 Netty零拷贝"></a>5.4 Netty零拷贝</h2><p>netty提供了零拷贝的buffer，在传输数据时，最终处理的数据会需要对单个传输的报文，进行组合和拆分，Nio原生的ByteBuffer无法做到，netty通过提供的Composite(组合)和Slice(拆分)两种buffer来实现零拷贝；看下面一张图会比较清晰：</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/16a0577f6f3da1c2~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>
<p>TCP层HTTP报文被分成了两个ChannelBuffer，这两个Buffer对我们上层的逻辑(HTTP处理)是没有意义的。 但是两个ChannelBuffer被组合起来，就成为了一个有意义的HTTP报文，这个报文对应的ChannelBuffer，才是能称之为”Message”的东西，这里用到了一个词”Virtual Buffer”。<br> 可以看一下netty提供的CompositeChannelBuffer源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositeChannelBuffer</span> <span class="keyword">extends</span> <span class="title">AbstractChannelBuffer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ByteOrder order;</span><br><span class="line">    <span class="keyword">private</span> ChannelBuffer[] components;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] indices;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> lastAccessedComponentId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> gathering;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> componentId = componentId(index);</span><br><span class="line">        <span class="keyword">return</span> components[componentId].getByte(index - indices[componentId]);</span><br><span class="line">    &#125;</span><br><span class="line">    ...省略...</span><br></pre></td></tr></table></figure>

<p>components用来保存的就是所有接收到的buffer，indices记录每个buffer的起始位置，lastAccessedComponentId记录上一次访问的ComponentId；CompositeChannelBuffer并不会开辟新的内存并直接复制所有ChannelBuffer内容，而是直接保存了所有ChannelBuffer的引用，并在子ChannelBuffer里进行读写，实现了零拷贝。</p>
<h2 id="5-5-其他零拷贝"><a href="#5-5-其他零拷贝" class="headerlink" title="5.5 其他零拷贝"></a>5.5 其他零拷贝</h2><ul>
<li>RocketMQ的消息采用顺序写到commitlog文件，然后利用consume queue文件作为索引；RocketMQ采用零拷贝mmap+write的方式来回对应Consumer的请求。</li>
<li>同样kafka中存在大量的网络数据持久化到磁盘和磁盘文件通过网络发送的过程，kafka使用了sendfile零拷贝方式。</li>
</ul>
<h1 id="6-服务端线程模型"><a href="#6-服务端线程模型" class="headerlink" title="6. 服务端线程模型"></a>6. 服务端线程模型</h1><p>在高性能的I/O设计中，有两个著名的模型：Reactor模型和Proactor模型，其中Reactor模型用于同步I/O，而Proactor模型运用于异步I/O操作。</p>
<blockquote>
<p>Y：这到底是线程模型还是IO设计模型？</p>
<p>为什么说Reactor用于同步IO？按下文描述Reactor应该基于的IO多路复用，而IO多路复用在IO模型中分为了异步阻塞IO。</p>
</blockquote>
<p>无论是Reactor模型还是Proactor模型，对于支持多连接的服务器，一般可以总结为2种fd和3种事件，如下图：</p>
<img src="https://gitee.com/qmlg/image-bed/raw/master/images/vxzkb57um9.jpeg" alt="vxzkb57um9" style="zoom: 50%;" />

<p><strong>2种fd</strong></p>
<ol>
<li>listenfd：一般情况，只有一个。用来监听一个特定的端口(如80)。</li>
<li>connfd：每个连接都有一个connfd。用来收发数据。</li>
</ol>
<blockquote>
<p>fd：file descriptor，文件描述符。</p>
</blockquote>
<p><strong>3种事件</strong></p>
<ol>
<li>listenfd进行accept阻塞监听，创建一个connfd</li>
<li>用户态/内核态copy数据。每个connfd对应着2个应用缓冲区：readbuf和writebuf。</li>
<li>处理connfd发来的数据。业务逻辑处理，准备response到writebuf。</li>
</ol>
<h2 id="6-1-Reactor-模型"><a href="#6-1-Reactor-模型" class="headerlink" title="6.1 Reactor 模型"></a>6.1 Reactor 模型</h2><p>无论是C++还是Java编写的网络框架，大多数都是基于Reactor模型进行设计和开发，<strong>Reactor模型基于事件驱动</strong>，特别适合处理<strong>海量的I/O事件</strong>。</p>
<p>基于IO多路复用。</p>
<p><strong>Reactor模型的三种角色：</strong></p>
<ul>
<li>Reactor（事件分离器）：负责监听和分配事件，将I/O事件分派给对应的Handler。新的事件包含连接建立就绪、读就绪、写就绪等。</li>
<li>Acceptor：处理客户端新连接，并分派请求到处理器链中。</li>
<li>Handler（事件处理器）：将自身与事件绑定，执行非阻塞读/写任务，完成channel的读入，完成处理业务逻辑后，负责将结果写出channel。可用资源池来管理。</li>
</ul>
<p><strong>Reactor模型处理请求的流程：</strong></p>
<p>读取操作：</p>
<ol>
<li>应用程序注册读就绪事件和相关联的事件处理器；</li>
<li>事件分离器等待事件的发生；</li>
<li>当发生读就绪事件的时候，事件分离器调用第一步注册的事件处理器。</li>
</ol>
<p>写入操作类似于读取操作，只不过第一步注册的是写就绪事件。</p>
<h3 id="6-1-1-单Reactor单线程模型"><a href="#6-1-1-单Reactor单线程模型" class="headerlink" title="6.1.1 单Reactor单线程模型"></a>6.1.1 单Reactor单线程模型</h3><p>Reactor线程负责多路分离套接字，accept新连接，并分派请求到handler。<strong>Redis</strong>使用单Reactor单线程的模型。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/kan4iva03p.jpeg" alt="kan4iva03p"></p>
<p><strong>消息处理流程：</strong></p>
<ol>
<li>Reactor对象通过select监控连接事件，收到事件后通过dispatch进行转发；</li>
<li>如果是连接建立的事件，则由acceptor接受连接，并创建关联的handler以处理后续事件；</li>
<li>如果不是建立连接事件，则Rreactor会分发调用该连接关联的handler来响应该事件；</li>
<li>handler会完成read-&gt;业务处理-&gt;send的完整业务流程。</li>
</ol>
<blockquote>
<p>单Reactor单线程模型只是在代码上进行了组件的区分，但是整体操作还是单线程，不能充分利用硬件资源。handler业务处理部分没有异步。</p>
</blockquote>
<p>对于一些小容量应用场景，可以使用单Reactor单线程模型。但是对于高负载、大并发的应用场景通常却不合适（Redis例外），主要原因如下：</p>
<ol>
<li>即便Reactor线程的CPU负荷达到100%，也无法满足海量消息的编码、解码、读取和发送。</li>
<li>当Reactor线程负载过重之后，处理速度将变慢，这会导致大量客户端连接超时，超时之后往往会进行重发，这更加重Reactor线程的负载，最终会导致大量消息积压和处理超时，成为系统的性能瓶颈。</li>
<li>一旦Reactor线程意外中断或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障。</li>
</ol>
<p>为了解决这些问题，演进出单Reactor多线程模型。</p>
<h3 id="6-1-2-单Reactor多线程模型"><a href="#6-1-2-单Reactor多线程模型" class="headerlink" title="6.1.2 单Reactor多线程模型"></a>6.1.2 单Reactor多线程模型</h3><p><strong>该模型在事件处理器（Handler）部分采用了多线程（线程池）。</strong></p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/ev2wc5eqhl.jpeg" alt="ev2wc5eqhl"></p>
<p><strong>消息处理流程：</strong></p>
<ol>
<li>Reactor对象通过select监控客户端请求事件，收到事件后通过dispatch进行分发；</li>
<li>如果是建立连接请求事件，则由acceptor通过accept处理连接请求，然后创建一个关联的Handler对象以处理后续的各种事件；</li>
<li>如果不是建立连接事件，则Reactor会分发调用该连接关联的Handler来响应该事件；</li>
<li>Handler<strong>只负责响应事件，不做具体业务处理</strong>，通过Read读取数据后，会分发给后面的<strong>Worker线程池</strong>进行业务处理；</li>
<li>Worker线程池会分配独立的线程完成真正的业务处理，然后将响应结果发给Handler；</li>
<li>Handler收到响应结果后通过send将响应结果返回给Client。</li>
</ol>
<p>相对于第一种模型来说，在处理业务逻辑，也就是获取到IO的读写事件之后，交由线程池来处理，handler收到响应后通过send将响应结果返回给客户端。这样可以降低Reactor的性能开销，从而更专注的做事件分发工作了，提升整个应用的吞吐。</p>
<blockquote>
<p>Y：为什么说降低了Reactor的性能开销，不应是提高了handler的处理效率吗？大概指循环遍历调用handler的过程在Reactor中，降低了这一块儿的性能开销。</p>
<p>单线程（Reactor + acceptor + handler[]）+ Worker线程池（处理handler中抽象出来的业务task）。</p>
</blockquote>
<p>但是这个模型存在的问题：</p>
<ol>
<li>多线程数据共享和访问比较复杂。如果子线程完成业务处理后，把结果传递给主线程Reactor进行发送，就会涉及共享数据的互斥和保护机制。</li>
<li>Reactor承担所有事件的监听和响应，只在主线程中运行，可能会存在性能问题。例如并发百万客户端连接，或者服务端需要对客户端握手进行安全认证，但是认证本身非常损耗性能。</li>
</ol>
<p>为了解决性能问题，产生了第三种主从Reactor多线程模型。</p>
<h3 id="6-1-3-主从Reactor多线程模型"><a href="#6-1-3-主从Reactor多线程模型" class="headerlink" title="6.1.3 主从Reactor多线程模型"></a>6.1.3 主从Reactor多线程模型</h3><p>比起第二种模型，它是将Reactor组件分成两部分：</p>
<ol>
<li>mainReactor负责监听server socket，用来处理网络IO连接建立操作，将建立的socketChannel指定注册给subReactor。</li>
<li>subReactor主要做和建立起来的socket做数据交互和事件业务处理操作。<strong>通常，subReactor个数上可与CPU个数等同</strong>。</li>
</ol>
<blockquote>
<p>Y：即将上文中的handler的遍历调用等工作也一并交给了subReactor。</p>
</blockquote>
<p><strong>Nginx</strong>、Swoole、Memcached和<strong>Netty</strong>都是采用这种实现。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/5vwph8mkvk.jpeg" alt="5vwph8mkvk"></p>
<p><strong>消息处理流程：</strong></p>
<ol>
<li>从主线程池中随机选择一个Reactor线程作为acceptor线程，用于绑定监听端口，接收客户端连接；</li>
<li>acceptor线程接收客户端连接请求之后创建新的SocketChannel，将其注册到主线程池的其它Reactor线程上，由其负责接入认证、IP黑白名单过滤、握手等操作；</li>
<li>步骤2完成之后，业务层的链路正式建立，将SocketChannel从主线程池的Reactor线程的多路复用器上摘除，重新注册到Sub线程池的线程上，并创建一个该连接关联的Handler用于处理后续各种事件；</li>
<li>当有新的事件发生时，SubReactor会调用该连接关联的Handler进行响应；</li>
<li>Handler通过Read读取数据后，会分发给后面的Worker线程池进行业务处理；</li>
<li>Worker线程池会分配独立的线程完成真正的业务处理，然后将响应结果发给Handler；</li>
<li>Handler收到响应结果后通过Send将响应结果返回给Client。</li>
</ol>
<blockquote>
<p>mainReactor线程池（Reactor + acceptor） + subReactor线程池（监听已有连接上的事件并触发hanler的task） + Worker线程池（处理handler中抽象出来的业务task）。</p>
</blockquote>
<h3 id="6-1-4-总结"><a href="#6-1-4-总结" class="headerlink" title="6.1.4 总结"></a>6.1.4 总结</h3><p>Reactor模型具有如下的优点：</p>
<ol>
<li>响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的；</li>
<li>编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销；</li>
<li>可扩展性，可以方便地通过增加Reactor实例个数来充分利用CPU资源；</li>
<li>可复用性，Reactor模型本身与具体事件处理逻辑无关，具有很高的复用性。</li>
</ol>
<h2 id="6-2-Proactor-模型"><a href="#6-2-Proactor-模型" class="headerlink" title="6.2 Proactor 模型"></a>6.2 Proactor 模型</h2><p>基于异步IO。</p>
<p>UML类图：</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/241052458282851.jpg" alt="Proactor"></p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/mz4ztz4g66.png" alt="mz4ztz4g66"></p>
<p><strong>模块关系：</strong></p>
<ol>
<li>Procator Initiator负责创建Procator和Handler，并将Procator和Handler都通过Asynchronous operation processor注册到内核。</li>
<li>Asynchronous operation processor负责处理注册请求，并完成IO操作。完成IO操作后会通知procator。</li>
<li>procator根据不同的事件类型回调不同的handler进行业务处理。handler完成业务处理，handler也可以注册新的handler到内核进程。</li>
</ol>
<p><strong>消息处理流程：</strong></p>
<p>读取操作：</p>
<ol>
<li>应用程序初始化一个异步读取操作，然后注册相应的事件处理器，<strong>此时事件处理器不关注读取就绪事件，而是关注读取完成事件</strong>，这是区别于Reactor的关键；</li>
<li>事件分离器等待读取操作完成事件；</li>
<li>在事件分离器等待读取操作完成的时候，操作系统调用内核线程完成读取操作，并将读取的内容放入用户传递过来的缓存区中，这也是区别于Reactor的一点，Proactor中，应用程序需要传递缓存区；</li>
<li>事件分离器捕获到读取完成事件后，激活应用程序注册的事件处理器，事件处理器直接从缓存区读取数据，而不需要进行实际的读取操作。</li>
</ol>
<blockquote>
<p>Y：零拷贝与直接内存映射。</p>
</blockquote>
<p>Proactor中写入操作和读取操作，只不过感兴趣的事件是写入完成事件。</p>
<p>Proactor有如下缺点：</p>
<ol>
<li>编程复杂性，由于异步操作流程的事件的初始化和事件完成在时间和空间上都是相互分离的，因此开发异步应用程序更加复杂。应用程序还可能因为反向的流控而变得更加难以Debug；</li>
<li>内存使用，缓冲区在读或写操作的时间段内必须保持住，可能造成持续的不确定性，并且每个并发操作都要求有独立的缓存，相比Reactor模型，在Socket已经准备好读或写前，是不要求开辟缓存的；</li>
<li>操作系统支持，Windows下通过IOCP实现了真正的异步 I/O，而在Linux系统下，Linux2.6才引入，并且异步I/O使用epoll实现的，所以还不完善。</li>
</ol>
<p>因此在 Linux 下实现高并发网络编程都是以Reactor模型为主。</p>
<h2 id="6-3-从设计模式角度比较Reactor与Proactor模型"><a href="#6-3-从设计模式角度比较Reactor与Proactor模型" class="headerlink" title="6.3 从设计模式角度比较Reactor与Proactor模型"></a>6.3 从设计模式角度比较Reactor与Proactor模型</h2><p>其来自另一篇文章《<a target="_blank" rel="noopener" href="https://www.cnblogs.com/me115/p/4452801.html">IO设计模式：Reactor和Proactor对比</a>》，结合着看可帮助理解。</p>
<h3 id="6-3-1-Reactor-反应器"><a href="#6-3-1-Reactor-反应器" class="headerlink" title="6.3.1 Reactor 反应器"></a>6.3.1 Reactor 反应器</h3><p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/241052434069024.jpg" alt="Reactor"></p>
<p><strong>Reactor包含如下角色：</strong></p>
<ul>
<li>Handle 句柄；用来标识socket连接或是打开文件；</li>
<li>Synchronous Event Demultiplexer：同步事件多路分解器：由操作系统内核实现的一个函数；用于阻塞等待发生在句柄集合上的一个或多个事件；（如select/epoll；）</li>
<li>Event Handler：事件处理接口</li>
<li>Concrete Event HandlerA：实现应用程序所提供的特定事件处理逻辑；</li>
<li>Reactor：反应器，定义一个接口，实现以下功能：<br>1）供应用程序注册和删除关注的事件句柄；<br>2）运行事件循环；<br>3）有就绪事件到来时，分发事件到之前注册的回调函数上处理；</li>
</ul>
<p><strong>业务流程及时序图</strong></p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/241052444538838.jpg" alt="seq_Reactor"></p>
<ol>
<li>应用启动，将关注的事件handle注册到Reactor中；</li>
<li>调用Reactor，进入无限事件循环，等待注册的事件到来；</li>
<li>事件到来，select返回，Reactor将事件分发到之前注册的回调函数中处理。</li>
</ol>
<h3 id="6-3-2-Proactor-主动器"><a href="#6-3-2-Proactor-主动器" class="headerlink" title="6.3.2 Proactor 主动器"></a>6.3.2 Proactor 主动器</h3><p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/241052458282851-20210821003116798.jpg" alt="Proactor"></p>
<p><strong>Proactor主动器模式包含如下角色：</strong></p>
<ul>
<li>Handle 句柄；用来标识socket连接或是打开文件；</li>
<li>Asynchronous Operation Processor：异步操作处理器；负责执行异步操作，一般由操作系统内核实现；</li>
<li>Asynchronous Operation：异步操作</li>
<li>Completion Event Queue：完成事件队列；异步操作完成的结果放到队列中等待后续使用</li>
<li>Proactor：主动器；为应用程序进程提供事件循环；从完成事件队列中取出异步操作的结果，分发调用相应的后续处理逻辑；</li>
<li>Completion Handler：完成事件接口；一般是由回调函数组成的接口；</li>
<li>Concrete Completion Handler：完成事件处理逻辑；实现接口定义特定的应用处理逻辑。</li>
</ul>
<p><strong>业务流程及时序图</strong></p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/241052468598435.jpg" alt="seq_Proactor"></p>
<ol>
<li>应用程序启动，调用异步操作处理器提供的异步操作接口函数，调用之后应用程序和异步操作处理就独立运行；应用程序可以调用新的异步操作，而其它操作可以并发进行；</li>
<li>应用程序启动Proactor主动器，进行无限的事件循环，等待完成事件到来；</li>
<li>异步操作处理器执行异步操作，完成后将结果放入到完成事件队列；</li>
<li>主动器从完成事件队列中取出结果，分发到相应的完成事件回调函数处理逻辑中。</li>
</ol>
<h1 id="7-Netty中的线程模型"><a href="#7-Netty中的线程模型" class="headerlink" title="7. Netty中的线程模型"></a>7. Netty中的线程模型</h1><p>Netty采用的是<strong>主从线程模型</strong>。下面是Netty使用中很常见的一段代码。</p>
<p>下面是Netty使用中很常见的一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childOption(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                    .childAttr(AttributeKey.newInstance(<span class="string">&quot;childAttr&quot;</span>), <span class="string">&quot;childAttrValue&quot;</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> ServerHandler())</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture f = b.bind(<span class="number">8888</span>).sync();</span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对Netty示例代码进行分析：</p>
<ol>
<li>定义了两个EventLoopGroup，其中bossGroup对应的就是主线程池，只接收客户端的连接（注册，初始化逻辑），具体的工作由workerGroup这个从线程池来完成。可以理解为老板负责招揽接待，员工负责任务完成。线程池和线程组是一个概念，所以名称里有group。之后就采用ServerBootstrap启动类，传入这两个主从线程组。</li>
<li>客户端和服务器建立连接后，NIO会在两者之间建立Channel，所以启动类调用channel方法就是为了指定建立什么类型的通道。这里指定的是NioServerSocketChannel这个通道类。</li>
<li>启动类还调用了handler()和childHandler()方法，这两个方法中提及的handler是一个处理类的概念，他负责处理连接后的一个个通道的相应处理。handler()指定的处理类是主线程池中对通道的处理类，childHandler()方法指定的是从线程池中对通道的处理类。</li>
<li>执行ServerBootstrap的bind方法进行绑定端口的同时也执行了sync()方法进行同步阻塞调用。</li>
<li>关闭通道采用Channel的closeFuture()方法关闭。</li>
<li>最终优雅地关闭两个线程组，执行shutdownGracefully()方法完成关闭线程组。</li>
</ol>
<blockquote>
<p>如果需要在客户端连接前的请求进行handler处理，则需要配置handler()；如果是处理客户端连接之后的handler，则需要配置在childHandler()。option和childOption也是一样的道理。</p>
</blockquote>
<p>boss线程池作用：</p>
<ol>
<li>接收客户端的连接，初始化Channel参数。</li>
<li>将链路状态变更时间通知给ChannelPipeline。</li>
</ol>
<p>worker线程池作用：</p>
<ol>
<li>异步读取通信对端的数据报，发送读事件到ChannelPipeline。</li>
<li>异步发送消息到通信对端，调用ChannelPipeline的消息发送接口。</li>
<li>执行系统调用Task。</li>
<li>执行定时任务Task。</li>
</ol>
<p>通过配置boss和worker线程池的线程个数以及是否共享线程池等方式，Netty的线程模型可以在以上三种Reactor模型之间进行切换。</p>
<h1 id="8-Nginx中的IO"><a href="#8-Nginx中的IO" class="headerlink" title="8. Nginx中的IO"></a>8. Nginx中的IO</h1><p>Nginx采用的是<strong>多进程（单线程）&amp; 多路IO复用模型</strong>。</p>
<p>工作模型：</p>
<ol>
<li>Nginx在启动后，会有一个master进程和多个相互独立的worker进程。</li>
<li>接收来自外界的信号，向所有worker进程发送信号，每个进程都有可能来处理这个连接。</li>
<li>master进程能监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动启动新的worker进程。</li>
</ol>
<p>master进程和worker进程</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/o_20170303170640322.png" alt="img"></p>
<blockquote>
<p>1、master  首先nginx 创建一个master 进程，通过socket() 创建一个sock文件描述符用来监听（sockfd） 绑定端口(bind) 开启监听（listen）。 nginx 一般监听80（http） 或 443 （https）端口 （fork 多个子进程后，master 会监听worker进程，和等待信号） </p>
<p>2、worker 然后 创建(fork)多个 worker子进程（复制master 进程的数据）， 此时所有的worker进程 继承了sockfd(socket文件描述符)， 当有连接进来之后 worker进程就可以accpet()创建已连接描述符， 然后通过已连接描述符与客户端通讯</p>
</blockquote>
<blockquote>
<p>惊群现象</p>
<p>由于worker进程 继承了master进程的sockfd,当连接进来是，所有的子进程都将收到通知并“争着”与<br>它建立连接，这就叫惊群现象。大量的进程被激活又挂起，最后只有一个进程accpet() 到这个连接，这会消耗系统资源<br>（等待通知，进程被内核全部唤醒，只有一个进程accept成功，其他进程又休眠。这种浪费现象叫惊群）</p>
<ul>
<li>nginx 对惊群现象的处理<ul>
<li>原因：多个进程监听同一个端口引发的。 </li>
<li>解决：如果可以同一时刻只能有一个进程监听端口，这样就不会发生“惊群”了，此时新连接事件只能唤醒正在监听的唯一进程。<ul>
<li>如何保持一个时刻只能有一个worker进程监听端口呢？<ul>
<li>nginx设置了一个accept_mutex锁，在使用accept_mutex锁时，只有进程成功调用了ngx_trylock_accept_mutex方法获取锁后才可以监听端口 。（linux 内核2.6 之后 不会出现惊群现象，只会有一个进程被唤醒）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="9-Redis中的IO"><a href="#9-Redis中的IO" class="headerlink" title="9. Redis中的IO"></a>9. Redis中的IO</h1><p><strong>文件事件处理器</strong></p>
<p>Redis基于<strong>单Reactor单线程模式</strong>开发了网络事件处理器，这个处理器被称为<strong>文件事件处理器</strong>。它的组成结构为4部分：</p>
<ul>
<li>多个套接字</li>
<li>IO多路复用程序</li>
<li>文件事件分派器</li>
<li>事件处理器</li>
</ul>
<p><strong>因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。</strong></p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/640-20210821005214541.jpg" alt="图片"></p>
<p><strong>消息处理流程</strong></p>
<ul>
<li>文件事件处理器使用I/O多路复用(multiplexing)程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应答(accept)、读取(read)、写入(write)、关闭(close)等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<p>尽管多个文件事件可能会并发地出现，但I/O多路复用程序总是会将所有产生事件的套接字都推到一个队列里面，然后通过这个队列，以有序（sequentially）、同步（synchronously）、每次一个套接字的方式向文件事件分派器传送套接字：当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕）， I/O多路复用程序才会继续向文件事件分派器传送下一个套接字。</p>
<p><strong>I/O 多路复用程序的实现</strong></p>
<p>Redis的I/O多路复用程序的所有功能是通过包装select、epoll、evport和kqueue这些I/O多路复用函数库来实现的，每个I/O多路复用函数库在Redis源码中都对应一个单独的文件，比如ae_select.c、ae_epoll.c、ae_kqueue.c等。</p>
<p>因为Redis为每个I/O多路复用函数库都实现了相同的API，所以I/O多路复用程序的底层实现是可以互换的，如下图所示。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/640-20210821005716490" alt="图片"></p>
<p><strong>文件事件的类型</strong></p>
<p>I/O 多路复用程序可以监听多个套接字的ae.h/AE_READABLE事件和ae.h/AE_WRITABLE事件，这两类事件和套接字操作之间的对应关系如下：</p>
<ul>
<li>当套接字变得可读时（客户端对套接字执行write操作，或者执行close操作），或者有新的可应答（acceptable）套接字出现时（客户端对服务器的监听套接字执行connect操作），套接字产生AE_READABLE 事件。</li>
<li>当套接字变得可写时（客户端对套接字执行read操作），套接字产生AE_WRITABLE事件。I/O多路复用程序允许服务器同时监听套接字的AE_READABLE事件和AE_WRITABLE事件，如果一个套接字同时产生了这两种事件，那么文件事件分派器会优先处理AE_READABLE事件，等到AE_READABLE事件处理完之后，才处理AE_WRITABLE 事件。这也就是说，如果一个套接字又可读又可写的话，那么服务器将先读套接字，后写套接字。</li>
</ul>
<p><strong>文件事件的处理器</strong></p>
<p>Redis为文件事件编写了多个处理器，这些事件处理器分别用于实现不同的网络通讯需求，常用的处理器如下：</p>
<ul>
<li>为了对连接服务器的各个客户端进行应答， 服务器要为监听套接字关联<strong>连接应答处理器</strong>。</li>
<li>为了接收客户端传来的命令请求， 服务器要为客户端套接字关联<strong>命令请求处理器</strong>。</li>
<li>为了向客户端返回命令的执行结果， 服务器要为客户端套接字关联<strong>命令回复处理器</strong>。</li>
</ul>
<p><strong>连接应答处理器</strong></p>
<p>networking.c中acceptTcpHandler函数是Redis的连接应答处理器，这个处理器用于对连接服务器监听套接字的客户端进行应答，具体实现为sys/socket.h/accept函数的包装。</p>
<p>当Redis服务器进行初始化的时候，程序会将这个连接应答处理器和服务器监听套接字的AE_READABLE事件关联起来，当有客户端用sys/socket.h/connect函数连接服务器监听套接字的时候， 套接字就会产生AE_READABLE 事件， 引发连接应答处理器执行， 并执行相应的套接字应答操作，如图所示。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/640-20210821010158979" alt="图片"></p>
<p><strong>命令请求处理器</strong></p>
<p>networking.c中readQueryFromClient函数是Redis的命令请求处理器，这个处理器负责从套接字中读入客户端发送的命令请求内容， 具体实现为unistd.h/read函数的包装。</p>
<p>当一个客户端通过连接应答处理器成功连接到服务器之后， 服务器会将客户端套接字的AE_READABLE事件和命令请求处理器关联起来，当客户端向服务器发送命令请求的时候，套接字就会产生 AE_READABLE事件，引发命令请求处理器执行，并执行相应的套接字读入操作，如图所示。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/640-20210821010244423" alt="图片"></p>
<p>在客户端连接服务器的整个过程中，服务器都会一直为客户端套接字的AE_READABLE事件关联命令请求处理器。</p>
<p><strong>命令回复处理器</strong></p>
<p>networking.c中sendReplyToClient函数是Redis的命令回复处理器，这个处理器负责将服务器执行命令后得到的命令回复通过套接字返回给客户端，具体实现为unistd.h/write函数的包装。</p>
<p>当服务器有命令回复需要传送给客户端的时候，服务器会将客户端套接字的AE_WRITABLE事件和命令回复处理器关联起来，当客户端准备好接收服务器传回的命令回复时，就会产生AE_WRITABLE事件，引发命令回复处理器执行，并执行相应的套接字写入操作， 如图所示。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/640-20210821010353301" alt="图片"></p>
<p>当命令回复发送完毕之后， 服务器就会解除命令回复处理器与客户端套接字的 AE_WRITABLE 事件之间的关联。</p>
<p><strong>一次完整的客户端与服务器连接事件示例</strong></p>
<p>假设Redis服务器正在运作，那么这个服务器的监听套接字的AE_READABLE事件应该正处于监听状态之下，而该事件所对应的处理器为连接应答处理器。</p>
<p>如果这时有一个Redis客户端向Redis服务器发起连接，那么监听套接字将产生AE_READABLE事件， 触发连接应答处理器执行：处理器会对客户端的连接请求进行应答， 然后创建客户端套接字，以及客户端状态，并将客户端套接字的 AE_READABLE 事件与命令请求处理器进行关联，使得客户端可以向主服务器发送命令请求。</p>
<p>之后，客户端向Redis服务器发送一个命令请求，那么客户端套接字将产生 AE_READABLE事件，引发命令请求处理器执行，处理器读取客户端的命令内容， 然后传给相关程序去执行。</p>
<p>执行命令将产生相应的命令回复，为了将这些命令回复传送回客户端，服务器会将客户端套接字的AE_WRITABLE事件与命令回复处理器进行关联：当客户端尝试读取命令回复的时候，客户端套接字将产生AE_WRITABLE事件， 触发命令回复处理器执行， 当命令回复处理器将命令回复全部写入到套接字之后， 服务器就会解除客户端套接字的AE_WRITABLE事件与命令回复处理器之间的关联。</p>
<h1 id="10-Tomcat的线程模型"><a href="#10-Tomcat的线程模型" class="headerlink" title="10. Tomcat的线程模型"></a>10. Tomcat的线程模型</h1><p>Tomcat支持四种接收请求的处理方式：BIO、NIO、APR和AIO</p>
<ul>
<li><p>NIO 同步非阻塞，比传统BIO能更好的支持大并发，tomcat 8.0 后默认采用该模型。 使用方法(配置server.xml)：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span>/&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 改为 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>BIO 阻塞式IO，tomcat7之前默认，采用传统的java IO进行操作，该模型下每个请求都会创建一个线程，适用于并发量小的场景。 使用方法(配置server.xml)：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span> =<span class="string">&quot; org.apache.coyote.http11.Http11Protocol&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>APR tomcat 以JNI形式调用http服务器的核心动态链接库来处理文件读取或网络传输操作，需要编译安装APR库。 使用方法(配置server.xml)：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span> =<span class="string">&quot;org.apache.coyote.http11.Http11AprProtocol&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>AIO 异步非阻塞 (NIO2)，tomcat8.0后支持。多用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。 使用方法(配置server.xml)：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span> =<span class="string">&quot;org.apache.coyote.http11.Http11Nio2Protocol&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<blockquote>
<p>内容来源：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/shuimuzhushui/p/10269203.html">JAVA I/O（一）基本字节和字符IO流</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/fengxianghui01/article/details/104398214">套接字之读写：recvfrom()、read() 和sendto() 、write()</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/duanxz/p/5507051.html">I/O模型之一：Unix的五种I/O模型</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/59975081">IO多路复用到底是不是异步的？</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/YdIdoZ_yusVWza1PU7lWaw">你管这破玩意叫 IO 多路复用？</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/shuimuzhushui/p/10269216.html">JAVA I/O（二）文件NIO</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/duanxz/p/6759814.html">Java NIO系列教程（二） Channel通道介绍及FileChannel详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/duanxz/p/6759823.html">Java NIO系列教程（三） Channel之Socket通道</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34290631/article/details/86005087">NIO–SocketChannel发送HTTP请求</a></li>
<li><a target="_blank" rel="noopener" href="https://ifeve.com/selectors/">Java NIO系列教程（六） Selector</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/duanxz/p/6782783.html">Java NIO系列教程（六） 多路复用器Selector</a></li>
<li><a target="_blank" rel="noopener" href="https://network.51cto.com/art/202102/645464.htm?pc">从网络I/O模型到Netty，先深入了解下I/O多路复用</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA4NjQ3ODQ2Mw==&mid=2247484168&idx=1&sn=fc68f2dfa7b061a547f7acf979aa9c32&chksm=9fc95818a8bed10e7b190c46b5a28d9013d38dca8fe7cdb4772302192b4a1197880e6dbed23c&scene=178&cur_album_id=1690085097271574533#rd">从I/O多路复用到Netty，还要跨过Java NIO包</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaobaiskill/p/10969180.html">nginx 多进程 + io多路复用 实现高并发</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0d40c69eb7ca">Redis和IO多路复用技术</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1488120">彻底搞懂Reactor模型和Proactor模型</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUyNzgyNzAwNg==&mid=2247483941&idx=1&sn=97628f4d69d8607badf39bfeb7557457&scene=21#wechat_redirect">彻底搞懂Java的网络IO</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1488087">NIO效率高的原理之零拷贝与直接内存映射</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/me115/p/4452801.html">IO设计模式：Reactor和Proactor</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUyNzgyNzAwNg==&mid=2247483945&idx=1&sn=1524a8ebf7adbdf61a98369c7f8ab145&scene=21#wechat_redirect">彻底搞懂Redis的线程模型</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzA4NjQ3ODQ2Mw==&mid=2247484205&idx=1&sn=2fe626dd4a3e2fa74e388715522c97fd&chksm=9fc9583da8bed12b899eabb6d69ec1fcc4359d9bb3bb681ff275a476f63c6c54843a08b93bee&scene=178&cur_album_id=1690085097271574533#rd">深入Netty逻辑架构，从Reactor线程模型开始</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903815913668615">关于零拷贝的一点认识</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangxm_qz/article/details/87636094">kafka消息存储机制和原理</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tuowang/p/9398876.html">Linux – 如何减少IO过程中的CPU copy</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/56da33b287dd">深度分析mmap：是什么 为什么 怎么用 性能总结（转载）</a></li>
</ul>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.coder.love/2021/08/17/Mysql-Optimize/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="青马流光">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="青马流光的博客">
      <meta itemprop="description" content="学习笔记">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 青马流光的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/17/Mysql-Optimize/" class="post-title-link" itemprop="url">Mysql 优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-17 18:54:41" itemprop="dateCreated datePublished" datetime="2021-08-17T18:54:41+08:00">2021-08-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-21 15:15:16" itemprop="dateModified" datetime="2022-03-21T15:15:16+08:00">2022-03-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="窄索引与宽索引"><a href="#窄索引与宽索引" class="headerlink" title="窄索引与宽索引"></a>窄索引与宽索引</h2><ul>
<li>窄索引</li>
</ul>
<ul>
<li>宽索引：包含查询中所需要的全部数据列。</li>
</ul>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/2017-09-11-Thin-Index-and-Fat-Index.jpg" alt="Thin-Index-and-Fat-Index"></p>
<p>​    对于查询 <code>SELECT id, username, age FROM users WHERE username=&quot;draven&quot;</code> 来说，(id, username) 就是一个窄索引，因为该索引没有包含存在于 SQL 查询中的 age 列，而 (id, username, age) 就是该查询的一个宽索引了，它<strong>包含这个查询中所需要的全部数据列</strong>。</p>
<p>​    宽索引能够避免二次的随机 IO，而窄索引就需要在对索引进行顺序读取之后再根据主键 id 从主键索引中查找对应的数据：</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/2017-09-11-Thin-Index-and-Clustered-Index.jpg" alt="Thin-Index-and-Clustered-Index"></p>
<p>​    对于窄索引，每一个在索引中匹配到的记录行最终都需要执行另外的随机读取从聚集索引中获得剩余的数据，如果结果集非常大，那么就会导致随机读取的次数过多进而影响性能。</p>
<h3 id="过滤因子"><a href="#过滤因子" class="headerlink" title="过滤因子"></a>过滤因子</h3><p>索引片变薄。</p>
<p>一个 SQL 查询扫描的索引片大小其实是由过滤因子决定的，也就是满足查询条件的记录行数所占的比例：</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/2017-09-11-Filter-Factor.jpg" alt="Filter-Facto"></p>
<p>对于 users 表来说，sex=“male” 就不是一个好的过滤因子，它会选择整张表中一半的数据，所以<strong>在一般情况下</strong>我们最好不要使用 sex 列作为整个索引的第一列；而 name=“draven” 的使用就可以得到一个比较好的过滤因子了，它的使用能过滤整个数据表中 99.9% 的数据；当然我们也可以将这三个过滤进行组合，创建一个新的索引 (name, age, sex) 并同时使用这三列作为过滤条件：</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/2017-09-11-Combined-Filter-Factor.jpg" alt="Combined-Filter-Facto"></p>
<blockquote>
<p>当三个过滤条件都是<strong>等值谓词</strong>时，几个索引列的顺序其实是无所谓的，<strong>索引列的顺序不会影响同一个 SQL 语句对索引的选择</strong>*，也就是索引 (name, age, sex) 和 (age, sex, name) 对于上图中的条件来说是完全一样的，这两个索引在执行查询时都有着完全相同的效果。</p>
</blockquote>
<p>这种直接使用乘积来计算组合条件的过滤因子其实有一个比较重要的问题：列与列之间不应该有太强的相关性。</p>
<p>对于一张表中的同一个列，不同的值也会有不同的过滤因子，这也就造成了同一列的不同值最终的查询性能也会有很大差别：</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/2017-09-11-Same-Columns-Filter-Factor.jpg" alt="Same-Columns-Filter-Facto"></p>
<p>当我们评估一个索引是否合适时，需要考虑极端情况下查询语句的性能，比如 0% 或者 50% 等；最差的输入往往意味着最差的性能，在平均情况下表现良好的 SQL 语句在极端的输入下可能就完全无法正常工作，这也是在设计索引时需要注意的问题。</p>
<p>总而言之，需要扫描的索引片的大小对查询性能的影响至关重要，而扫描的索引记录的数量，就是总行数与组合条件的过滤因子的乘积，索引片的大小最终也决定了从表中读取数据所需要的时间。</p>
<h3 id="匹配列与过滤列"><a href="#匹配列与过滤列" class="headerlink" title="匹配列与过滤列"></a>匹配列与过滤列</h3><p>假设在 users 表中有 name、age 和 (name, sex, age) 三个辅助索引；当 WHERE 条件中存在类似 age = 21 或者 name = “draven” 这种<strong>等值谓词</strong>时，它们都会成为<strong>匹配列</strong>（Matching Column）用于选择索引树中的数据行，但是当我们使用以下查询时：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;draven&quot; <span class="keyword">AND</span> sex <span class="operator">=</span> &quot;male&quot; <span class="keyword">AND</span> age <span class="operator">&gt;</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p>虽然我们有 (name, sex, age) 索引包含了上述查询条件中的全部列，但是在这里只有 name 和 sex 两列才是匹配列，MySQL 在执行上述查询时，会选择 name 和 sex 作为匹配列，扫描所有满足条件的数据行，然后将 age 当做<strong>过滤列</strong>（Filtering Column）：</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/2017-09-11-Match-Columns-Filter-Columns.jpg" alt="Match-Columns-Filter-Columns"></p>
<p><strong>过滤列虽然不能够减少索引片的大小，但是能够减少从表中随机读取数据的次数</strong>，所以在索引中也扮演着非常重要的角色。</p>
<h2 id="索引的设计"><a href="#索引的设计" class="headerlink" title="索引的设计"></a>索引的设计</h2><p>从总体来看如何<strong>减少随机读取的次数</strong>是设计索引时需要重视的最重要的问题。</p>
<h3 id="三星索引"><a href="#三星索引" class="headerlink" title="三星索引"></a>三星索引</h3><p>三星索引是对于一个查询语句可能的最好索引，如果一个查询语句的索引是三星索引，那么它只需要进行<strong>一次磁盘的随机读及一个窄索引片的顺序扫描</strong>就可以得到全部的结果集。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/2017-09-11-Three-Star-Index.jpg" alt="Three-Star-Index"></p>
<p>为了满足三星索引中的三颗星，我们分别需要做以下几件事情：</p>
<ol>
<li>第一颗星需要取出<strong>所有等值谓词中的列</strong>，作为索引开头的最开始的列（任意顺序）；</li>
<li>第二颗星需要将 <strong>ORDER BY 列</strong>加入索引中；</li>
<li>第三颗星需要将<strong>查询语句剩余的列</strong>全部加入到索引中。</li>
</ol>
<p>三星索引中每颗星都有其意义：</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/2017-09-11-Behind-Three-Star-Index.jpg" alt="Behind-Three-Star-Index"></p>
<ol>
<li>第一颗星不只是将等值谓词的列加入索引，它的作用是减少索引片的大小以减少需要扫描的数据行；</li>
<li>第二颗星用于避免排序，减少磁盘 IO 和内存的使用；</li>
<li>第三颗星用于避免每一个索引对应的数据行都需要进行一次随机 IO 从聚集索引中读取剩余的数据。</li>
</ol>
<p>在实际场景中，问题往往没有这么简单，我们虽然可以总能够通过宽索引避免大量的随机访问，但是在一些复杂的查询中（如同时拥有范围谓词和order by时）我们无法同时获得第一颗星和第二颗星。</p>
<p>总而言之，在设计单表的索引时，首先把查询中所有的<strong>等值谓词全部取出</strong>以任意顺序放在索引最前面，在这时，如果索引中同时存在范围索引和 ORDER BY 就需要权衡利弊了，希望最小化扫描的索引片厚度时，应该将<strong>过滤因子最小的范围索引列</strong>加入索引，如果希望避免排序就选择 <strong>ORDER BY 中的全部列</strong>，在这之后就只需要将查询中<strong>剩余的全部列</strong>加入索引了，通过这种固定的方法和逻辑就可以最快地获得一个查询语句的二星或者三星索引了。</p>
<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>当 MySQL 读取一个索引行或者一个表行时，就会发生一次访问，当使用全表扫描或者扫描索引片时，<strong>读取的第一个行就是随机访问</strong>，随机访问需要磁盘进行寻道和旋转，所以其代价巨大，而接下来顺序读取的所有行都是通过顺序访问读取的，代价只有随机访问的千分之一。</p>
<h1 id="Mysql-如何使用索引"><a href="#Mysql-如何使用索引" class="headerlink" title="Mysql 如何使用索引"></a>Mysql 如何使用索引</h1><p>大多数 MySQL 索引（<code>PRIMARY KEY</code>、 <code>UNIQUE</code>、<code>INDEX</code>和 <code>FULLTEXT</code>）都存储在 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_b_tree">B 树中</a>。例外：空间数据类型的索引使用 R 树；<code>MEMORY</code> 表也支持<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_hash_index">哈希索引</a>；<code>InnoDB</code>对<code>FULLTEXT</code>索引使用倒排列表。</p>
<p>通常，索引的使用如下面的讨论中所述。<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/index-btree-hash.html">第 8.3.9 节“B 树和哈希索引的比较”</a><code>MEMORY</code>中描述了特定于哈希索引（如表中使用的 ）的特征 。</p>
<p>MySQL 对这些操作使用索引：</p>
<ul>
<li><p>WHERE快速查找与<strong>子句匹配</strong>的行。</p>
</li>
<li><p>从考虑中排除行。如果有多个索引之间的选择，MySQL通常使用找到<strong>最少行数</strong>的索引（最具 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_selectivity">选择性的</a>索引）。</p>
</li>
<li><p>如果表具有多列索引，则优化器可以使用索引的任何<strong>最左边的前缀</strong>来查找行。举例来说，如果你有一个三列的索引 <code>(col1, col2, col3)</code>，你有索引的搜索功能<code>(col1)</code>， <code>(col1, col2)</code>以及<code>(col1, col2, col3)</code>。有关更多信息，请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/multiple-column-indexes.html">第 8.3.6 节，“多列索引”</a>。</p>
</li>
<li><p>在执行连接时从其他表中检索行。如果<strong>将列声明为相同的类型和大小</strong>，MySQL 可以更有效地使用列上的索引。在这种情况下， <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/char.html"><code>VARCHAR</code></a>与 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/char.html"><code>CHAR</code></a>被认为是相同的，如果它们被声明为相同的大小。例如， <code>VARCHAR(10)</code>和 <code>CHAR(10)</code>是相同的大小，但 <code>VARCHAR(10)</code>和 <code>CHAR(15)</code>不是。</p>
<p>对于非二进制字符串列之间的比较，两列应使用相同的字符集。例如，将一<code>utf8</code>列与一 <code>latin1</code>列进行比较排除了索引的使用。</p>
<p>如果不进行转换就无法直接比较值，则不同列的比较（例如，将字符串列与临时或数字列进行比较）可能会阻止使用索引。对于给定的值，如<code>1</code> 在数值列，它可能比较等于在字符串列，例如任何数量的值 <code>&#39;1&#39;</code>，<code>&#39; 1&#39;</code>， <code>&#39;00001&#39;</code>，或<code>&#39;01.e1&#39;</code>。这排除了对字符串列使用任何索引的可能性。</p>
</li>
<li><p>查找特定索引列的<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/aggregate-functions.html#function_min"><code>MIN()</code></a>或 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/aggregate-functions.html#function_max"><code>MAX()</code></a>值*<code>key_col</code><em>。这是由预处理器优化的，该预处理器检查您是否 在索引中之前出现的所有关键部分上使用。在这种情况下，MySQL 对每个or 表达式执行单个键查找，并将其替换为常量。如果所有表达式都替换为常量，则查询立即返回。例如： <code>WHERE *</code>key_part_N<code>* = *</code>constant<code>*</code></em><code>key_col</code>*<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/aggregate-functions.html#function_min"><code>MIN()</code></a><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/aggregate-functions.html#function_max"><code>MAX()</code></a></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(key_part2),<span class="built_in">MAX</span>(key_part2)</span><br><span class="line">  <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> key_part1<span class="operator">=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>如果排序或分组是在可用索引的最左前缀（例如，）上完成的，则对表进行排序或分组 。如果所有关键部分后跟，则以相反的顺序读取密钥。（或者，如果索引是降序索引，<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/order-by-optimization.html">则按</a>前向顺序读取键。）请参阅 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/order-by-optimization.html">第 8.2.1.16 节“ORDER BY 优化”</a>、 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/group-by-optimization.html">第 8.2.1.17 节“GROUP BY 优化”</a>和 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/descending-indexes.html">第 8.3.13 节“降序索引”</a>。 <code>ORDER BY *</code>key_part1<code>*, *</code>key_part2<code>*``DESC</code></p>
</li>
<li><p>在某些情况下，可以优化查询以在不咨询数据行的情况下检索值。（为查询提供所有必要结果的<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_covering_index">索引</a>称为 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_covering_index">覆盖索引</a>。）如果查询仅使用某个索引中包含的表中的列，则可以从索引树中检索所选值以提高速度：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> key_part3 <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_part1<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>索引对于小表或大表的查询不太重要</strong>，其中报告查询处理大部分或所有行。<strong>当查询需要访问大部分行时，顺序读取比通过索引读取要快。顺序读取最小化磁盘搜索，即使查询不需要所有行。</strong>有关详细信息<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/table-scan-avoidance.html">，</a>请参阅<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/table-scan-avoidance.html">第 8.2.1.23 节，“避免全表扫描”</a>。</p>
<h1 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h1><p>Explain输出列</p>
<table>
<thead>
<tr>
<th align="left">Column</th>
<th align="left">JSON Name</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="left">id</td>
<td align="left">select_id</td>
<td align="left">该SELECT语句的标识符</td>
</tr>
<tr>
<td align="left">select_type</td>
<td align="left">None</td>
<td align="left">该SELECT语句的类型</td>
</tr>
<tr>
<td align="left">table</td>
<td align="left">table_name</td>
<td align="left">表名</td>
</tr>
<tr>
<td align="left">partitions</td>
<td align="left">partitions</td>
<td align="left">查询将从其中匹配记录的分区。对于非分区表，该值为NULL。</td>
</tr>
<tr>
<td align="left">type</td>
<td align="left">access_type</td>
<td align="left">join 类型</td>
</tr>
<tr>
<td align="left">possible_keys</td>
<td align="left">possible_keys</td>
<td align="left">指示MySQL可以选择从哪些索引中查找该表中的行。</td>
</tr>
<tr>
<td align="left">key</td>
<td align="left">key</td>
<td align="left">表示MySQL实际决定使用的键(索引)。如果MySQL决定使用一个possible_keys索引来查找行，该索引将作为键值列出。</td>
</tr>
<tr>
<td align="left">key_len</td>
<td align="left">key_length</td>
<td align="left">key_len列表示MySQL决定使用的键的长度。key_len的值使您能够确定MySQL实际使用的多部分键的多少部分。如果key列为NULL, key_len列也为NULL。</td>
</tr>
<tr>
<td align="left">ref</td>
<td align="left">ref</td>
<td align="left">ref列显示哪些列或常量与key列中指定的索引进行比较，以从表中选择行。<br/>如果值是func，则使用的值是某个函数的结果。<br/>要查看哪个函数，请使用EXPLAIN后面的SHOW WARNINGS查看扩展的EXPLAIN输出。这个函数实际上可能是一个运算符，比如算术运算符。</td>
</tr>
<tr>
<td align="left">rows</td>
<td align="left">rows</td>
<td align="left">示MySQL认为执行查询时必须检查的行数。<br/>对于InnoDB表，这个数字是一个估计，可能并不总是准确的。</td>
</tr>
<tr>
<td align="left">filtered</td>
<td align="left">filtered</td>
<td align="left">按表条件过滤的行百分比。</td>
</tr>
<tr>
<td align="left">Extra</td>
<td align="left">None</td>
<td align="left">这一列包含关于MySQL如何解析查询的附加信息。</td>
</tr>
</tbody></table>
<p>select_type的值</p>
<table>
<thead>
<tr>
<th align="left">select_type Value</th>
<th align="left">JSON Name</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SIMPLE</td>
<td align="left">None</td>
<td align="left">简单的 SELECT (没有使用 UNION 或者 子查询)</td>
</tr>
<tr>
<td align="left">PRIMARY</td>
<td align="left">None</td>
<td align="left">SELECT中若包含任何复杂的子部分，最外层SELECT则被标记为Primary</td>
</tr>
<tr>
<td align="left">UNION</td>
<td align="left">None</td>
<td align="left">UNION语句中的第二个或之后的 SELECT 语句</td>
</tr>
<tr>
<td align="left">DEPENDENT UNION</td>
<td align="left">dependent (true)</td>
<td align="left">一个 UNION 语句中的第二个或之后的SELECT语句, 依赖于外层查询。</td>
</tr>
<tr>
<td align="left">UNION RESULT</td>
<td align="left">union_result</td>
<td align="left">UNION 的结果</td>
</tr>
<tr>
<td align="left">SUBQUERY</td>
<td align="left">None</td>
<td align="left">子查询中的第一个 SELECT。</td>
</tr>
<tr>
<td align="left">DEPENDENT SUBQUERY</td>
<td align="left">dependent (true)</td>
<td align="left">子查询中的第一个 SELECT, 依赖于外层查询。</td>
</tr>
<tr>
<td align="left">DERIVED</td>
<td align="left">None</td>
<td align="left">在FROM列表中包含的子查询被标记为DERIVED(衍生);MySQL会递归执行这些子查询, 把结果放在临时表里。</td>
</tr>
<tr>
<td align="left">DEPENDENT DERIVED</td>
<td align="left">dependent (true)</td>
<td align="left">依赖于另一张表的衍生表。</td>
</tr>
<tr>
<td align="left">MATERIALIZED</td>
<td align="left">materialized_from_subquery</td>
<td align="left">物化子查询</td>
</tr>
<tr>
<td align="left">UNCACHEABLE SUBQUERY</td>
<td align="left">cacheable (false)</td>
<td align="left">无法缓存其结果的子查询，必须对外部查询的每一行重新求值。</td>
</tr>
<tr>
<td align="left">UNCACHEABLE UNION</td>
<td align="left">cacheable (false)</td>
<td align="left">属于非缓存子查询的UNION中的第二或之后的SELECT。</td>
</tr>
</tbody></table>
<blockquote>
<p>通过物化来优化子查询</p>
<p>优化器使用物化能够更有效的来处理子查询。物化通过将子查询结果作为一个临时表来加快查询执行速度，正常来说是在内存中的。mysql第一次需要子查询结果是，它物化结果到一张<strong>临时表</strong>中。在之后的任何地方需要该结果集，mysql会再次引用临时表。优化器也许会使用一个哈希索引来使得查询更快速代价更小。索引是唯一的，排除重复并使得表数据更少。<br>子查询物化如果可以的话会使用一个内存临时表，如果表太大则会落实为磁盘存储。具体请看8.4.4的在mysql中使用内部临时表。</p>
</blockquote>
<p><strong>EXPLAIN 输出的 type 列描述表是如何连接的。</strong>在json格式的输出中，可以找到access_type属性的值。下面的列表描述了连接类型，按<strong>从好到坏</strong>的顺序排列:</p>
<ul>
<li><p>system</p>
<ul>
<li>该表只有一行(= system table)。这是const连接类型的特殊情况。</li>
</ul>
</li>
<li><p>const</p>
<ul>
<li><p>该表最多有一个匹配的行，在查询的开始读取。因为只有一行，所以这一行中的列的值可以被优化器的其余部分视为常量。const表非常快，因为它们只被读取一次。</p>
</li>
<li><p>当将<strong>PRIMARY KEY</strong>或<strong>UNIQUE索引</strong>的所有部分与<strong>常量</strong>进行比较时，使用const。在下面的查询中，tbl_name可以用作const表:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> primary_key<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> primary_key_part1<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> primary_key_part2<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>eq_ref</p>
<ul>
<li><p>对于前面表中的每个行组合，将从该表中读取一行。除了系统类型和const类型，这是最好的连接类型。当连接使用索引的所有部分，并且<strong>索引是主键或UNIQUE NOT NULL索引</strong>时使用。</p>
</li>
<li><p>eq_ref可以用于使用=操作符进行比较的索引列。比较值可以是常量或表达式，该表达式使用在该表之前读取的表中的列。在下面的例子中，MySQL可以使用eq_ref连接来处理ref_table:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ref_table,other_table</span><br><span class="line">  <span class="keyword">WHERE</span> ref_table.key_column<span class="operator">=</span>other_table.column;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ref_table,other_table</span><br><span class="line">  <span class="keyword">WHERE</span> ref_table.key_column_part1<span class="operator">=</span>other_table.column</span><br><span class="line">  <span class="keyword">AND</span> ref_table.key_column_part2<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>ref</p>
<ul>
<li><p>对于前面表中的每个行组合，将从该表中读取具有匹配索引值的所有行。如果连接仅使用键的最左边前缀，或者该键不是PRIMARY key或UNIQUE索引(换句话说，<strong>如果连接不能根据键值选择单行</strong>)，则使用ref。如果所使用的键只匹配少数行，那么这是一种很好的连接类型。</p>
</li>
<li><p>ref可用于使用=或&lt;=&gt;操作符进行比较的索引列。在下面的例子中，MySQL可以使用ref连接来处理ref_table:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ref_table <span class="keyword">WHERE</span> key_column<span class="operator">=</span>expr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ref_table,other_table</span><br><span class="line">  <span class="keyword">WHERE</span> ref_table.key_column<span class="operator">=</span>other_table.column;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ref_table,other_table</span><br><span class="line">  <span class="keyword">WHERE</span> ref_table.key_column_part1<span class="operator">=</span>other_table.column</span><br><span class="line">  <span class="keyword">AND</span> ref_table.key_column_part2<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>fulltext</p>
<ul>
<li>使用FULLTEXT索引执行的join。</li>
</ul>
</li>
<li><p>ref_or_null</p>
<ul>
<li><p>这个连接类型类似于ref，但是MySQL会额外搜索包含NULL值的行。这种连接类型优化最常用于解析子查询。在下面的例子中，MySQL可以使用ref_or_null连接来处理ref_table:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ref_table</span><br><span class="line">  <span class="keyword">WHERE</span> key_column<span class="operator">=</span>expr <span class="keyword">OR</span> key_column <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>index_merge</p>
<ul>
<li>此连接类型表明使用了Index Merge优化。在本例中，输出行中的key列包含所使用索引的列表，key_len包含所使用索引的最长key部分的列表。</li>
</ul>
</li>
<li><p>unique_subquery</p>
<ul>
<li><p>这个类型替换了以下形式的IN子查询的eq_ref:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">value</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> primary_key <span class="keyword">FROM</span> single_table <span class="keyword">WHERE</span> some_expr)</span><br></pre></td></tr></table></figure></li>
<li><p>unique_subquery只是一个<strong>索引查找函数</strong>，它完全替代子查询以提高效率。</p>
</li>
</ul>
</li>
<li><p>index_subquery</p>
<ul>
<li><p>这种连接类型类似于unique_subquery。它代替了IN子查询，但它适用于以下形式的子查询中的<strong>非唯一索引</strong>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">value</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key_column <span class="keyword">FROM</span> single_table <span class="keyword">WHERE</span> some_expr)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>range</p>
<ul>
<li><p>只检索给定范围内的行，使用索引选择行。输出行中的key列指示使用哪个索引。key_len包含所使用的最长的key部分。对于这种类型，ref列是NULL。</p>
</li>
<li><p>当使用任意的=，&lt;&gt;，&gt;，&gt;=，&lt;，&lt;=，is NULL， &lt;=&gt;， BETWEEN, LIKE, or IN()操作符将key列与常量进行比较时，可以使用range:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_column <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_column <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_column <span class="keyword">IN</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_part1 <span class="operator">=</span> <span class="number">10</span> <span class="keyword">AND</span> key_part2 <span class="keyword">IN</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>index</p>
<ul>
<li><p>index 连接类型与ALL相同，只是扫描的是索引树。这有两种方式:</p>
<ul>
<li>如果索引是查询的覆盖索引，并且可以用来满足表中所需的所有数据，则只扫描索引树。在本例中，Extra 列显示”<em>Using index</em>“。仅索引扫描通常比ALL扫描快，因为索引的大小通常小于表数据。</li>
<li>全表扫描是通过从索引中读取数据以按照索引顺序查找数据行来执行的。”<em>Using index</em>“不出现在 Extra 列。</li>
</ul>
<p>当查询只使用属于单个索引的列时，MySQL可以使用这种连接类型。</p>
</li>
</ul>
</li>
<li><p>all</p>
<ul>
<li>对前面表中的每个行组合进行全表扫描。如果表是第一个没有标记为const的表，这通常不太好，在所有其他情况下通常都很糟糕。通常，您可以通过添加索引来避免ALL，这些索引支持基于常量值或早期表中的列值从表中检索行。</li>
</ul>
</li>
</ul>
<h1 id="mysqldumpslow-慢查询日志"><a href="#mysqldumpslow-慢查询日志" class="headerlink" title="mysqldumpslow 慢查询日志"></a>mysqldumpslow 慢查询日志</h1><p>MySQL 慢查询日志包含有关需要很长时间执行的查询的信息。mysqldumpslow解析 MySQL 慢查询日志文件并汇总其内容。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow [<span class="operator">*</span>options<span class="operator">*</span>] [<span class="operator">*</span>log_file<span class="operator">*</span> ...]</span><br></pre></td></tr></table></figure>

<p>mysqldumpslow 支持以下 options：</p>
<table>
<thead>
<tr>
<th align="left">Option Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-a</td>
<td align="left">不要把所有数字抽象为N，字符串抽象为S。</td>
</tr>
<tr>
<td align="left">-n</td>
<td align="left">名称中至少包含N位的抽象数字。</td>
</tr>
<tr>
<td align="left">–debug</td>
<td align="left">以debug模式运行，输出debug信息。</td>
</tr>
<tr>
<td align="left">-g</td>
<td align="left">只考虑与模式匹配的语句。</td>
</tr>
<tr>
<td align="left">–help</td>
<td align="left">打印help信息并退出。</td>
</tr>
<tr>
<td align="left">-h</td>
<td align="left">日志文件名中添加服务器的主机名。</td>
</tr>
<tr>
<td align="left">-i</td>
<td align="left">server 实例的名称。</td>
</tr>
<tr>
<td align="left">-l</td>
<td align="left">不从总时间中减去 lock 的时间。</td>
</tr>
<tr>
<td align="left">-r</td>
<td align="left">反向排序</td>
</tr>
<tr>
<td align="left">-s</td>
<td align="left">如何对输出进行排序，sort_type：t、at、l、al、r、ar、c</td>
</tr>
<tr>
<td align="left">-t</td>
<td align="left">在输出中只显示前N个查询。</td>
</tr>
<tr>
<td align="left">–verbose</td>
<td align="left">详细模式。</td>
</tr>
</tbody></table>
<h1 id="semi-join"><a href="#semi-join" class="headerlink" title="semi-join"></a>semi-join</h1><p>semi-join Materialization 是用于semi-join的一种特殊的子查询物化技术。通常包含两种策略：</p>
<p>1.Materialization/lookup</p>
<p>2.Materialization/scan</p>
<p>考虑一个查询欧洲有大城市的国家:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Country</span><br><span class="line"><span class="keyword">where</span> Country.code <span class="keyword">IN</span> (<span class="keyword">select</span> City.Country</span><br><span class="line">                       <span class="keyword">from</span> City</span><br><span class="line">                       <span class="keyword">where</span> City.Population <span class="operator">&gt;</span> <span class="number">7</span><span class="operator">*</span><span class="number">1000</span><span class="operator">*</span><span class="number">1000</span>)</span><br><span class="line">      <span class="keyword">and</span> Country.continent<span class="operator">=</span><span class="string">&#x27;Europe&#x27;</span></span><br></pre></td></tr></table></figure>

<p>子查询是非相关子查询。也即是我们可以独立运行内查询。semi-materialization的思想是使用city.country中可能的值填充一个临时表，然后和欧洲的国家进行关联。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/764761-20190521094832948-695990984.png" alt="img"></p>
<p>这个join可以从两个方向进行：</p>
<ol>
<li>从物化表到国家表</li>
<li>从国家表到物化表</li>
</ol>
<p>第一个方向涉及一个全表扫描(在物化表上的全表扫描)，因此被称为”Materialization-scan”；如果从第二个方向进行，最廉价的方式是使用主键从物化表中lookup出匹配的记录。这种方式被称为”Materialization-lookup”。</p>
<h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><p>本节讨论MySQL 8.0中可用的分区类型。这些包括这里列出的类型:</p>
<ul>
<li>RANGE partitioning<ul>
<li>这种类型的分区根据位于给定范围内的列值将行分配给分区。</li>
</ul>
</li>
<li>LIST partitioning<ul>
<li>类似于RANGE分区，但分区是根据匹配一组离散值之一的列。</li>
</ul>
</li>
<li>HASH partitioning<ul>
<li>使用这种类型的分区，将根据用户定义表达式返回的值选择分区，该表达式对要插入到表中的行中的列值进行操作。这个函数可以包含任何在MySQL中有效的表达式，并产生一个非负整数值。该类型的扩展 LINEAR HASH 也可用。</li>
</ul>
</li>
<li>KEY partitioning<ul>
<li>这种类型的分区类似于HASH分区，除了只提供一个或多个要计算的列，而且MySQL服务器提供自己的哈希函数。这些列可以包含非整数值，因为MySQL提供的散列函数保证了一个整数结果，而不管列数据类型是什么。这种类型的扩展，LINEAR KEY，也可用。</li>
</ul>
</li>
</ul>
<p>数据库分区的一个非常常见的用途是按日期隔离数据。一些数据库系统支持显式的日期分区，MySQL在8.0中没有实现。然而，在MySQL中创建基于DATE、TIME或DATETIME列或基于使用这些列的表达式的分区方案并不困难。</p>
<p>当使用KEY或LINEAR KEY进行分区时，可以使用DATE、TIME或DATETIME列作为分区列，而不需要对列值进行任何修改。例如，这个表创建语句在MySQL中是完全有效的:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> members (</span><br><span class="line">    firstname <span class="type">VARCHAR</span>(<span class="number">25</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    lastname <span class="type">VARCHAR</span>(<span class="number">25</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">35</span>),</span><br><span class="line">    joined <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> KEY(joined)</span><br><span class="line">PARTITIONS <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<p>在MySQL 8.0中，也可以使用DATE或DATETIME列作为使用RANGE列和LIST列分区的分区列。</p>
<p>其他分区类型需要生成整数值或NULL的分区表达式。如果你想使用RANGE、LIST、HASH或LINEAR HASH的基于日期的分区，你可以简单地使用一个函数，在DATE、TIME或DATETIME列上操作并返回这样一个值，如下所示:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> members (</span><br><span class="line">    firstname <span class="type">VARCHAR</span>(<span class="number">25</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    lastname <span class="type">VARCHAR</span>(<span class="number">25</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">35</span>),</span><br><span class="line">    joined <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>( <span class="keyword">YEAR</span>(joined) ) (</span><br><span class="line">    <span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> LESS THAN (<span class="number">1960</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> LESS THAN (<span class="number">1970</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p2 <span class="keyword">VALUES</span> LESS THAN (<span class="number">1980</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p3 <span class="keyword">VALUES</span> LESS THAN (<span class="number">1990</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p4 <span class="keyword">VALUES</span> LESS THAN MAXVALUE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>使用日期进行分区的其他例子可在本章的以下章节中找到:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/partitioning-range.html">Section 24.2.1, “RANGE Partitioning”</a></li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/partitioning-hash.html">Section 24.2.4, “HASH Partitioning”</a></li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/partitioning-linear-hash.html">Section 24.2.4.1, “LINEAR HASH Partitioning”</a></li>
</ul>
<p>有关更复杂的基于日期的分区示例，请参见以下部分:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/partitioning-pruning.html">Section 24.4, “Partition Pruning”</a></li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/partitioning-subpartitions.html">Section 24.2.6, “Subpartitioning”</a></li>
</ul>
<p>MySQL分区通过TO_DAYS()、YEAR()和TO_SECONDS()函数进行了优化。但是，您可以使用其他返回整数或NULL的日期和时间函数，如WEEKDAY()、DAYOFYEAR()或MONTH()。</p>
<p>重要的是要记住—不管您使用的分区类型是什么—分区总是在创建时自动编号并按顺序编号，从0开始。当将新行插入分区表时，将使用这些分区号来标识正确的分区。例如，如果您的表使用4个分区，则这些分区编号为0、1、2和3。对于RANGE和LIST分区类型，必须确保为每个分区号定义了一个分区。对于HASH分区，用户提供的表达式必须计算为大于0的整数值。对于KEY分区，这个问题是由MySQL服务器内部使用的哈希函数自动处理的。</p>
<p>分区的名称通常遵循管理其他MySQL标识符(如表和数据库标识符)的规则。但是，您应该注意分区名称不区分大小写。例如，下面的CREATE TABLE语句失败，如下所示:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (val <span class="type">INT</span>)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">PARTITION</span> <span class="keyword">BY</span> LIST(val)(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     <span class="keyword">PARTITION</span> mypart <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     <span class="keyword">PARTITION</span> MyPart <span class="keyword">VALUES</span> <span class="keyword">IN</span> (<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> );</span><br><span class="line">ERROR <span class="number">1488</span> (HY000): Duplicate <span class="keyword">partition</span> name mypart</span><br></pre></td></tr></table></figure>

<p>因为MySQL看不到分区名mypart和mypart之间的区别，所以会发生失败。</p>
<p>当您指定表的分区数时，必须将其表示为一个正的、不带前导零的非零整数字面值，并且可能不是像0.8E+01或6-2这样的表达式，即使它计算出的值是一个整数值。小数是不允许的。</p>
<hr>
<blockquote>
<p>感谢摘抄（或参考）的文章：</p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/sql-index-intro/">MySQL 索引设计概要</a></p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/mysql-indexes.html">8.3.1 How MySQL Uses Indexes</a></p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-join-types">8.8.2 EXPLAIN Output Format</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/abclife/p/10899350.html">semi-join子查询优化 – semi-join Materialization策略</a></p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/mysqldumpslow.html">4.6.10 mysqldumpslow — Summarize Slow Query Log Files</a></p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/partitioning-types.html">24.2 Partitioning Types</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">青马流光</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
