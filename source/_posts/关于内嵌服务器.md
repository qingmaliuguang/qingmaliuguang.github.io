---
title: 关于内嵌服务器
date: 2022-03-24 17:12:25
tags: SpringBoot

---

# 1. 内嵌服务器是如何注入的？

## 注入ServletWebServerFactory实例

- spring-boot-autoconfigure -> spring.factory

-  -> EnableAutoConfiguration=ServletWebServerFactoryAutoConfiguration


- -> ServletWebServerFactoryAutoConfiguration

  > ```java
  > @Configuration(proxyBeanMethods = false)
  > @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
  > @ConditionalOnClass(ServletRequest.class)
  > // 应用类型推断为SERVLET
  > @ConditionalOnWebApplication(type = Type.SERVLET)
  > // 注册ServerProperties bean 用于web服务器的配置。
  > @EnableConfigurationProperties(ServerProperties.class)
  > // 导入组件类：
  > // - ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar注册一个WebServerFactoryCustomizerBeanPostProcessor，通过ImportBeanDefinitionRegistrar提前注册
  > // - EmbeddedTomcat、EmbeddedJetty、EmbeddedUndertow根据条件会启用一个，用于注册一个ServletWebServerFactory实例。
  > @Import({ ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,
  > 		ServletWebServerFactoryConfiguration.EmbeddedTomcat.class,
  > 		ServletWebServerFactoryConfiguration.EmbeddedJetty.class,
  > 		ServletWebServerFactoryConfiguration.EmbeddedUndertow.class })
  > public class ServletWebServerFactoryAutoConfiguration {
  >   // 通过@Bean注入ServletWebServerFactoryCustomizer、TomcatServletWebServerFactoryCustomizer、    FilterRegistrationBean【@ConditionalOnMissingFilterBean(ForwardedHeaderFilter.class)】
  >   ......
  > }
  > ```

- ServletWebServerFactoryConfiguration -> 以Tomcat为例 -> ServletWebServerFactoryConfiguration.EmbeddedTomcat

  > ```java
  > @Configuration(proxyBeanMethods = false)
  >   // 都是tomcat-embed中的类，即添加tomcat-embed依赖的情况下生效。
  > 	@ConditionalOnClass({ Servlet.class, Tomcat.class, UpgradeProtocol.class })
  >   // ServletWebServerFactory实例当前上下文中只需要一个。
  > 	@ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT)
  > 	static class EmbeddedTomcat {
  > 
  > 		@Bean
  > 		TomcatServletWebServerFactory tomcatServletWebServerFactory(
  >       // ObjectProvider为一种依赖注入方式容器会自动将T类型beans包装成一个ObjectProvider，然后注入到依赖ObjectProvider<T>中。
  > 				ObjectProvider<TomcatConnectorCustomizer> connectorCustomizers,
  > 				ObjectProvider<TomcatContextCustomizer> contextCustomizers,
  > 				ObjectProvider<TomcatProtocolHandlerCustomizer<?>> protocolHandlerCustomizers) {
  > 			TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();
  > 			factory.getTomcatConnectorCustomizers()
  > 					.addAll(connectorCustomizers.orderedStream().collect(Collectors.toList()));
  > 			factory.getTomcatContextCustomizers()
  > 					.addAll(contextCustomizers.orderedStream().collect(Collectors.toList()));
  > 			factory.getTomcatProtocolHandlerCustomizers()
  > 					.addAll(protocolHandlerCustomizers.orderedStream().collect(Collectors.toList()));
  > 			return factory;
  > 		}
  > 	}
  > ```

- -> 注册 TomcatServletWebServerFactory 实例 （即TomcatWebServer的工厂bean）

## 创建WebServer实例

- AnnotationConfigServletWebServerApplicationContext.refresh()

- -> ServletWebServerApplicationContext.onRefresh()

- -> ServletWebServerApplicationContext.createWebServer()

  > - 创建WebServer实例
  >
  >   > - 注意TomcatServer构造函数中调用了initialize()，调用了tomcat.start()。
  >
  > - 将获取的WebServer实例，分别构造WebServerGracefulShutdownLifecycle和WebServerStartStopLifecycle单例注册到beanFactory，用于管理其生命周期，即服务器的启动、关闭等。

- -> 单例：webServerGracefulShutdown、webServerStartStop

## 启动服务器webServer

- -> AbstractApplicationContext.finishRefresh()

  > 完成这个上下文的刷新，调用LifecycleProcessor的onRefresh()方法并发布ContextRefreshedEvent

- -> getLifecycleProcessor().onRefresh();

  > 首先将刷新传播到生命周期处理器。

- -> DefaultLifecycleProcessor.onRefresh();

  > 上下文刷新的通知，例如自动启动组件

- -> DefaultLifecycleProcessor.startBeans()

  > - webServerGracefulShutdown：getPhase() == Integer.MAX_VALUE;
  >
  > - webServerStartStop：getPhase() == Integer.MAX_VALUE - 1;

- LifecycleGroup.start() -> LifecycleGroup.doStart()

- -> webServerStartStop.start()

  > - 其后也会触发webServerGracefulShutdown.start()，但只是修改其自身标志位，用于webServer关闭，与webServer启动无关。
  > - 在WebServer就绪之后还会发布一个**ServletWebServerInitializedEvent**事件，用于获取运行中的服务器的本地端口。

- -> webServer.start() 【TomcatWebServer.start()】

## TomcatWebServer启动过程

- start() 方法体全部通过 synchronized 进行同步控制。

- 启动流程图

  > ![TomcatWebServer-start](https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/TomcatWebServer-start.jpg)
  >
  > - 由于servlet实例dispatcherServlet的创建交给了Spring容器，所以实际流程中通常不会执行wrapper.load()。
  > - 可以看到performDeferredLoadOnStartup()实际并没有触发什么特殊的操作。
  > - TomcatWebServer.start()的实际效果就只剩了设置connectors和设置启动标志started。

## Wrapper是什么时候构造的，加载的哪个Servlet实例？

- spring-boot-autoconfigure -> spring.factory

- -> EnableAutoConfiguration=org.springframework.boot.autoconfigure.web.servlet.**DispatcherServletAutoConfiguration**

- -> **DispatcherServletAutoConfiguration**

  > Spring DispatcherServlet的自动配置。应该适用于已经有嵌入式web服务器的独立应用程序，也适用于使用SpringBootServletInitializer的可部署应用程序。

- -> 生成DispatcherServlet 实例 dispatcherServlet 和 DispatcherServletRegistrationBean 实例 dispatcherServletRegistration。

  > - **DispatcherServletRegistrationBean**
  >
  >   > <img src="https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/DispatcherServletRegistrationBean.jpg" alt="DispatcherServletRegistrationBean" style="zoom: 50%;" />
  >
  > - **DispatcherServlet**
  >
  >   > <img src="https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/DispatcherServlet.jpg" alt="DispatcherServlet" style="zoom:50%;" />

- -> ServletWebServerApplicationContext.createWebServer()

- -> TomcatServletWebServerFactory.getWebServer(ServletContextInitializer... initializers)

- -> TomcatServletWebServerFactory.getTomcatWebServer(tomcat)

  > 构造并初始化TomcatWebServer实例。

- -> TomcatWebServer.initialize()

- -> Tomcat.start()

- -> StandardServer.start()

- -> StandardContext.startInternal()

  > 实际为TomcatEmbeddedContext实例。

- -> TomcatStarter.onStartUp()

  遍历initializers，依次调用其onStartup

- -> ServletWebServerApplicationContext.selfInitialize((ServletContext servletContext))

- -> RegistrationBean.onStartUp()

  > - 实际为**DispatcherServletRegistrationBean**实例dispatcherServletRegistration，其通过自动配置实例化时有设置servlet，即**DispatcherServlet**实例dispatcherServlet。

- -> ApplicationContext.addServlet(String servletName, Servlet servlet)

  > 1. 通过StandardContext.createWrapper()生成Wrapper实例，没有填充servlet等属性。
  > 2. 对Wrapper实例填充name、servlet、servletClass等属性。

- 参考下面的ServletWebServerApplicationContext.createWebServer()流程图

  > ![ServletWebServerApplicationContext-createWebServer](https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/ServletWebServerApplicationContext-createWebServer.jpg)



## 相关配置文件

- 启用自动配置都是通过spring-boot-autoconfigure -> spring.factory 的 EnableAutoConfiguration。

- 自动配置类

  - ServerProperties

    > - prefix：“server”
    > - 用于servlet web服务器的自动配置

  - WebMvcProperties

    > - prefix：“spring.mvc” 
    > - Spring MVC的属性。

## 都添加了哪些ServletContextInitializer

- ServletWebServerApplicationContext$lambda

  > ```java
  > private void selfInitialize(ServletContext servletContext) throws ServletException {
  > 		prepareWebApplicationContext(servletContext);
  > 		registerApplicationScope(servletContext);
  > 		WebApplicationContextUtils.registerEnvironmentBeans(getBeanFactory(), servletContext);
  > 		for (ServletContextInitializer beans : getServletContextInitializerBeans()) {
  > 			beans.onStartup(servletContext);
  > 		}
  > 	}
  > ```

- AbstractServletWebServerFactory$lambda

  > ```java
  > (servletContext) -> this.initParameters.forEach(servletContext::setInitParameter)
  > ```

- AbstractServletWebServerFactory.SessionConfiguringInitializer

  > ServletContextInitializer，应用合适部分的Session配置。
  >
  > ![TomcatServletWebServerFactory](https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/TomcatServletWebServerFactory.jpg)

以上三者都是在AbstractServletWebServerFactory.mergeInitializers(ServletContextInitializer... initializers)方法中合并与添加的。

**在哪里生效的？**：TomcatStarter.onStartUp()

# 2. 内嵌服务器是怎么提供服务的？

## 是谁监听的请求？

> <img src="https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/tomcat-embed-%E6%A6%82%E5%BF%B5%E5%85%B3%E7%B3%BB.jpg" alt="tomcat-embed-概念关系" style="zoom: 33%;" />
>
> - 概念的理解：
>
>   - Server是tomcat中服务器的概念，实现为StandardServer。
>
>   - Service为提供的服务的概念，实现为StandardService。
>
>   - Servlet为服务提供者。
>
>   - 从 Engine 到 Wrapper 为承载Servlet的四级容器，即servlet容器。
>
>   - Connector 连接器
>
>     > - 在Tomcat.getConnector()中可看到服务端口port被通过Connector.setPort配置到Connector实例中。
>     > - Connector.setPort将port设置为 ProtocolHandler 成员 protocolHandler 的“port”属性。
>
> - 猜测：请求监听者一定与port有关，Connector中并没有相关内容，那么可能是 protocolHandler。
>
>   > - Connector是在Tomcat.getConnector()时创建的，在StandardServer.start过程中完成的初始化（initInternal）和启动（startInternal）。
>   >
>   > - Connector创建时通过ProtocolHandler.create(protocol)创建了protocolHandler，对于默认的“HTTP/1.1”，对应**Http11NioProtocol**实例。
>   >
>   > - Connector.startInternal()注释中提到“通过这个连接器开始处理请求”，其中主要处理为protocolHandler.start();
>   >
>   > - protocolHandler.start();  - >  endpoint.start()
>   >
>   >   > Http11NioProtocol的默认构造中的endpoint为**NioEndpoint**的实例。
>   >
>   > - **NioEndpoint**
>   >
>   >   > NIO定制线程池，提供以下服务:
>   >   >
>   >   > - Socket acceptor thread  套接字受体线程
>   >   >
>   >   >   > 单个线程，线程名称以“-Acceptor”结尾。
>   >   >
>   >   > - Socket poller thread  套接字轮询器线程
>   >   >
>   >   >   > 单个线程，线程名称以“-Poller”结尾。
>   >   >
>   >   > - Worker threads pool  工作线程池
>   >   >
>   >   >   > 基于ThreadPoolExecutor的线程池 executor，名称含“-exec-”，形如“http-nio-8080-exec-3”。
>   >
>   > - 结论：NioEndpoint中的 acceptor 线程负责监听请求。

## 请求处理过程-如何传递到dispatcherServlet？

> - tomcat-embed请求处理流程：
>
>   ![tomcat-embed请求处理流程](https://love-coder-blog-images.oss-cn-beijing.aliyuncs.com/images/tomcat-embed%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.jpg)
>
> - 简要描述：
>
>   > - -> endpoint的acceptor线程负责监听服务端口port，将接收到的请求包装成NioSocketWrapper对象向poller实例注册为PollerEvent对象，添加到poller的events队列中，唤醒poller的selector。
>   >
>   > - -> poller的selector获取到sk，转换回NioSocketWrapper对象。
>   >
>   > - -> 通过Http11Processor实例来处理NioSocketWrapper对象，转换为Request。
>   >
>   > - -> 委托给Coyote处理器处理该请求。
>   >
>   > - -> 通过connector调用service关联各级容器（自上而下）关联Valve pipeline，处理请求。
>   >
>   > - -> 调用此请求的过滤器链
>   >
>   > - -> 过滤器链执行完之后调用servlet（即dispatcherServlet）的service方法，真正服务于该请求以获取响应。
>   >
>   >   > dispatcherServlet继承的超类的service方法，doGet、doPost、doPut、do Delete等方法最终会调用dispatcherServlet的doService方法来处理请求。

## DispatcherServlet的处理过程

> 