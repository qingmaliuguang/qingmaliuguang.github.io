<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.coder.love","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="学习笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="青马流光的博客">
<meta property="og:url" content="http://blog.coder.love/page/3/index.html">
<meta property="og:site_name" content="青马流光的博客">
<meta property="og:description" content="学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="青马流光">
<meta property="article:tag" content="Java、数据">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://blog.coder.love/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>青马流光的博客</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">青马流光的博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Code the love to the world.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">青马流光</p>
  <div class="site-description" itemprop="description">学习笔记</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.coder.love/2021/08/16/InnoDB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="青马流光">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="青马流光的博客">
      <meta itemprop="description" content="学习笔记">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 青马流光的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/16/InnoDB/" class="post-title-link" itemprop="url">InnoDB</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-16 13:06:04" itemprop="dateCreated datePublished" datetime="2021-08-16T13:06:04+08:00">2021-08-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-21 13:23:20" itemprop="dateModified" datetime="2022-03-21T13:23:20+08:00">2022-03-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Mysql-架构"><a href="#Mysql-架构" class="headerlink" title="Mysql 架构"></a>Mysql 架构</h1><p>Mysql 架构图</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/v2-973b9ba05057d3f610619a1efb38bef6_720w.jpg" alt="img"></p>
<p>MySQL区别于其他数据库的一个最重要的特点是<strong>插件式存储引擎</strong>。它是<strong>基于表</strong>的，而不是数据库。MySql常用存储引擎如下：</p>
<p><strong>MyISAM存储引擎</strong></p>
<ul>
<li>不支持事务。</li>
<li>缓冲池只缓存索引文件，不缓冲数据文件。</li>
<li>由MYD和MYI文件组成，MYD用来存放数据文件，MYI用来存放索引文件。</li>
</ul>
<p><strong>InnoDB存储引擎</strong></p>
<ul>
<li>独立表空间，支持MVCC，行锁设计，提供一致性非锁定读。</li>
<li>支持外键，插入缓冲，二次写，自适应哈希索引，预读。</li>
<li>使用聚集的方式存储数据，每张表的存储都是按主键顺序存放。</li>
</ul>
<p><strong>InnoDB架构图</strong></p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/v2-5271f9ac34525757edd866a8f9fbba80_720w.jpg" alt="img"></p>
<p>以下主要从内存和线程的角度分析InnoDB的架构。</p>
<h2 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h2><p>主要工作：</p>
<ul>
<li>维护所有进程/线程需要使用的多个内部数据结构</li>
<li>缓存磁盘上的数据，方便快速地读取，同时对磁盘文件数据修改之前在这里缓存</li>
<li>重做日志缓存</li>
</ul>
<p>InnoDB内存池主要有以下部分</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/v2-210d508df6c12e9df71982754ee3225d_720w.jpg" alt="img"></p>
<p><strong>缓冲池</strong><br>InnoDB是基于磁盘存储的，并将其中的记录按照页的方式进行管理。<br>而缓冲池就是一块内存区域，主要缓冲数据页和索引页。<br>InnoDB中对页的读取操作，首先判断该页是否在缓冲池中，若在，直接读取该页，若不在则从磁盘读取页数据，并存放在缓冲池中。<br>对页的修改操作，首先修改在缓冲池中的页，再以一定的频率（Checkpoint机制）刷新到磁盘。<br>参数：innodb_buffer_pool_size设置缓冲池大小</p>
<p>缓冲池通过<strong>LRU（Latest Recent Used，最近最少使用）算法</strong>进行管理。最频繁使用的页在LRU列表前端，最少使用的页在尾端，当缓冲池不能存放新读取的页时，首先释放LRU列表尾端的页（页数据刷新到磁盘，并从缓冲次中删除）。<br>InnoDB对于新读取的页，不是放到LRU列表最前端，而是放到midpoint位置（默认为5/8处）。<br>这是因为一些SQL操作会访问大量的页（如全表扫描），读取大量非热点数据，如果直接放到首部，可能导致真正的热点数据被移除。</p>
<p>关于页的概念会在存储篇解释，这里就理解为InnoDB将表数据拆分为若干固定大小的页，每页保存若干表记录。</p>
<p><strong>重做日志缓存</strong><br>重做日志先放到这个缓冲区，然后按一定频率刷新到重做日志文件。重做日志文件都是以块(block)的方法进行保存的，称为重做日志块（redo log block）<br>参数：innodb_log_buffer_size</p>
<p>刷新规则：</p>
<ol>
<li>Master Thread每秒将一部分重做日志缓冲刷新到重做日志文件。</li>
<li>每一事务提交时会将重做日志刷新到重做日志文件（如果配置了）。</li>
<li>重做日志缓冲区使用空间大于1/2。</li>
</ol>
<p><strong>额外的内存池</strong><br>内存堆，对InnoDB内部使用的数据结构对象进行管理。</p>
<h2 id="Checkpoint机制"><a href="#Checkpoint机制" class="headerlink" title="Checkpoint机制"></a>Checkpoint机制</h2><p>InnoDB对于对于DML语句操作（如Update或Delete），事务提交时只需在缓冲池中完成操作，然后再通过Checkpoint将修改后的脏页数据刷新到磁盘。</p>
<p>InnoDB有两种Checkpoint：</p>
<ul>
<li>Sharp Checkpoint：数据库关闭时将所有脏页刷新会磁盘</li>
<li>Fuzzy Checkpoint：<ul>
<li>Master Thread Checkpoint<br>Master Thread每个1秒或10秒按一定比例将缓存池的脏页列表刷新会磁盘</li>
<li>FLUSH LRU LIST Checkpoint<br>Page Cleaner线程发现LRU列表中可用页数量少于innodb_lru_scan_depth(1024)，就将LRU列表尾端移除，如果这些页中有脏页，就需要Checkpoint</li>
<li>Async/Sync Flush Checkpoint<br>重做日志文件空间不可以用时，将一部分脏页刷新到磁盘。</li>
<li>Dirty Page too much Checkpoint:<br>脏页数量太多（超过比例innodb_max_dirty_pages_pct,默认75），执行Checkpoint。</li>
</ul>
</li>
</ul>
<h2 id="重做日志"><a href="#重做日志" class="headerlink" title="重做日志"></a>重做日志</h2><p><strong>重做日志 redo log 是为了保证事务的原子性，持久性。</strong>InnoDB采用<strong>Write Ahread Log</strong>策略，事务提交时，先写重做日志，再修改页。</p>
<p>数据库宕机重启时通过执行重做日志恢复数据。</p>
<p>但由于Checkpoint机制，数据库宕机重启并不需要重做所有的日志，因为Checkpoint之前的页都刷新到磁盘了，只需执行最新一次Checkpoint后的重做日志进行恢复，这样可以缩短数据库的恢复时间。</p>
<p>InnoDB中重做日志文件是循环使用的。当页被Checkpoint刷新到磁盘后，对应的重做日志就不需要使用 ，其空间可以被覆盖重用。</p>
<p>如果待写入的重做日志文件空间不可用（脏页还没有刷新到磁盘），就需要强制产生Checkpoint，将缓冲池中的页至少刷新到当前重做日志的位置。</p>
<p>InnoDB 1.2.x(MySql 5.6)后，FLUSH LRU LIST Checkpoint以及Async/Sync Flush Checkpoint操作放到Page Cleaner线程，以免阻塞用户线程。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>主要作用：</p>
<ul>
<li>负责刷新内存池中的数据，保证缓冲池的内存缓冲的是最近的数据</li>
<li>已修改的数据文件刷新到磁盘文件</li>
<li>保证数据库发生异常的情况下InnoDB能恢复到正常状态。</li>
</ul>
<p>InnoDB运行时主要有以下线程</p>
<ul>
<li><p>Master Thread<br>负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新，合并插入缓冲（INSERT BUFFER），UNDO页的回收等。</p>
</li>
<li><p>IO Thread<br>负责AIO请求的回调处理。<br>参数：innodb_read_io_threads，innodb_write_io_threads</p>
</li>
<li><p>Purge Thread<br>事务提交后，undo log可能不再需要，由Purge Thread负责回收并重新分配的这些已经使用的undo页。<br>注意：Purge Thread需要离散地读取undo页。</p>
</li>
<li><p>Page Cleaner Thread</p>
<p>InnoDB 1.2.x引入，将Master Threader中刷新脏页的工作移至该线程，如上面说的FLUSH LRU LIST Checkpoint以及Async/Sync Flush Checkpoint。</p>
</li>
</ul>
<h2 id="InnoDB关键特性"><a href="#InnoDB关键特性" class="headerlink" title="InnoDB关键特性"></a>InnoDB关键特性</h2><h3 id="插入缓冲"><a href="#插入缓冲" class="headerlink" title="插入缓冲"></a>插入缓冲</h3><p>插入聚集索引一般是顺序的，不需要磁盘的随机读取。但插入非聚集索引叶子节点不是顺序的，需要离散访问非聚集索引页，速度较慢。对于<strong>非聚集索引的插入或更新</strong>，先判断插入的非聚集索引页<strong>是否在缓存池</strong>中，若在，直接插入，或不在，先放到一个<strong>Inser Buffer对象</strong>中，然后根据一些算法将Insert Buffer缓存的记录通过后台线程慢慢合并刷新回辅助索引。插入缓冲将多次插入合并为一次操作，减少磁盘的离散操作。</p>
<p>使用Insert Buffer需满足两个条件：</p>
<ul>
<li>索引是辅助索引</li>
<li>索引不是唯一的（不需要查找索引页判断唯一性）</li>
</ul>
<p>InnoDB从1.0.x引入Change Buffer，对INSERT，DELETE，UPDATE都进行缓冲。</p>
<p>参数：innodb_change_buffer_max_size，Change Buffer最多使用缓冲池内存空间。</p>
<h3 id="doublewrite"><a href="#doublewrite" class="headerlink" title="doublewrite"></a>doublewrite</h3><p>这是mysql一个崩溃恢复很重要的特性-重复写入。</p>
<blockquote>
<p>doublewrite缓冲区是位于系统表空间中的存储区域，在该区域中，InnoDB会在将页面写入数据文件中的适当位置之前，从InnoDB缓冲池中刷新这些页面。仅在刷新页面并将其写入doublewrite缓冲区后，InnoDB才会将页面写入其适当位置。如果在页面写入过程中发生操作系统，存储子系统或mysqld进程崩溃，InnoDB稍后可以在崩溃恢复期间从doublewrite缓冲区中找到该页面的良好副本。</p>
</blockquote>
<p><strong>部分写失效</strong>：页数据写入到磁盘时只写了一部分（如16K数据只写了2K），数据库就宕机了，导致页数据损坏，这时无法使用重做日志恢复。（执行重做日志时需要利用页的一些变量，如checksum）</p>
<p>因此在使用重做日志恢复数据库，需要有一个页的副本，当发生写失效时，先通过页的副本还原该页，再进行重做。于是InnoDB实现了doublewrite技术。</p>
<p>doublewrite有两部分，一部分是内存中的doublewrite buffer，大小为2MB，另一部分是磁盘共享表空间连续的128个页，也是2MB。<br>doublewrite要求刷新缓冲池的脏页时执行以下步骤：</p>
<ol>
<li>通过memcpy函数将脏页复制到内存的doublewrite buffer；</li>
<li>doublewrite buffer分两次，每次1MB，顺序写入共享表空间；</li>
<li>调用fsync函数同步磁盘，避免缓冲写带来问题，确保数据刷新到共享表空间（顺序写，开销小）；</li>
<li>将上述的脏页数据写入各个表空间文件（离散写）。</li>
</ol>
<h3 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h3><p>InnoDB会监控对表上各索引页的查询执行情况，如发现建立哈希索引可以提升速度，则建立哈希索引，这是过程不需要用户干预。<br>参数：innodb_adaptive_hash_index，默认AHI为开启状态。</p>
<h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p>InnoDB使用异步IO操作磁盘，避免同步IO导致阻塞，也可以进行IO Merge操作，将多个IO操作合并为一个IO操作。</p>
<h3 id="刷新邻接页"><a href="#刷新邻接页" class="headerlink" title="刷新邻接页"></a>刷新邻接页</h3><p>当刷新一个脏页时，InnoDB会检测该页所在区的所有页，如果是脏页，一起刷新，这是可以通过AIO将多个IO写入操作合并为一个IO操作。<br>参数：innodb_flush_neighbors，控制开关。</p>
<h1 id="数据的存储"><a href="#数据的存储" class="headerlink" title="数据的存储"></a>数据的存储</h1><p>在 InnoDB 存储引擎中，所有的数据都被<strong>逻辑地</strong>存放在表空间中，表空间（tablespace）是存储引擎中最高的存储逻辑单位，在表空间的下面又包括<strong>段（segment）</strong>、<strong>区（extent）</strong>、<strong>页（page）</strong>：</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/dd5b5b00329248b3a3c9d5eba40ffc6b.jpeg" alt="img"></p>
<ul>
<li>表空间<ul>
<li>InnoDB将所有数据（包括表数据，索引，回滚信息，插入缓冲索引页，系统事务信息，二次写缓冲）逻辑地放在一个空间中，称为<strong>共享表空间</strong>。<br>默认表空间的存储文件为data目录下的ibdata1，初始化为10M。</li>
</ul>
</li>
<li>段<ul>
<li>一个索引（InnoDB都是B+索引）由两个段管理，叶子节点段（leaf segment）和非叶子节点段（non leaf segment）</li>
<li>回滚数据也是通过段管理。</li>
</ul>
</li>
<li>区<ul>
<li>InnoDB申请空间的最小单位，由连续页组成的空间，大小为1MB，保持不变。</li>
<li>InnoDB一次从磁盘中申请4~5个区。</li>
</ul>
</li>
<li>页<ul>
<li>InnoDB访问的最小单位，同一个数据库实例的所有表空间都有相同的页大小；默认情况下，表空间中的页大小都为 16KB。</li>
<li>缓冲池是以页为管理单位，每次读取或刷新一页数据。</li>
<li>可以通过改变 innodb_page_size选项对默认大小进行修改</li>
</ul>
</li>
</ul>
<p>需要注意的是不同的页大小最终也会导致区大小的不同：</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/4ecc11c77b7a4f67b101d3a0ebc003fa.jpeg" alt="img"></p>
<p>从图中可以看出，在 InnoDB 存储引擎中，一个区的大小最小为 1MB，页的数量最少为 64 个。</p>
<h2 id="如何存储表"><a href="#如何存储表" class="headerlink" title="如何存储表"></a>如何存储表</h2><p>MySQL 使用 InnoDB 存储表时，会将<strong>表的定义</strong>和<strong>数据索引</strong>等信息分开存储，其中前者存储在 .frm文件中，后者存储在 .ibd文件中，这一节就会对这两种不同的文件分别进行介绍。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/d06d7df771f647acb8fe2ebe5ad9ee3f.jpeg" alt="img"></p>
<h3 id="frm-文件"><a href="#frm-文件" class="headerlink" title=".frm 文件"></a>.frm 文件</h3><p>无论在 MySQL 中选择了哪个存储引擎，所有的 MySQL 表都会在硬盘上创建一个 .frm文件用来描述表的格式或者说定义； .frm文件的格式在不同的平台上都是相同的。详见<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/internals/en/frm-file-format.html">11.1 MySQL .frm File Format</a></p>
<h3 id="ibd-文件"><a href="#ibd-文件" class="headerlink" title=".ibd 文件"></a>.ibd 文件</h3><p>InnoDB 中用于存储数据的文件总共有两个部分，一是系统表空间文件，包括 ibdata1、 ibdata2等文件，其中存储了 InnoDB 系统信息和用户数据库表数据和索引，是所有表公用的。</p>
<p>当打开 innodb_file_per_table选项时， .ibd文件就是每一个表独有的表空间，文件存储了当前表的数据和相关的索引数据。</p>
<h2 id="如何存储记录"><a href="#如何存储记录" class="headerlink" title="如何存储记录"></a>如何存储记录</h2><p>与现有的大多数存储引擎一样，InnoDB 使用页作为磁盘管理的最小单位；数据在 InnoDB 存储引擎中都是按行存储的，<strong>每个 16KB 大小的页中可以存放 2-200 行的记录</strong>。</p>
<p>当 InnoDB 存储数据时，它可以使用不同的行格式进行存储；MySQL 5.7 版本支持以下格式的行存储方式：</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/a7d9d6b7b3a24cb7917dde4c3e8ae134.jpeg" alt="img"></p>
<blockquote>
<p>Antelope 是 InnoDB 最开始支持的文件格式，它包含两种行格式 Compact 和 Redundant，它最开始并没有名字；Antelope 的名字是在新的文件格式 Barracuda 出现后才起的，Barracuda 的出现引入了两种新的行格式 Compressed 和 Dynamic；InnoDB 对于文件格式都会向前兼容，而官方文档中也对之后会出现的新文件格式预先定义好了名字：Cheetah、Dragon、Elk 等等。</p>
</blockquote>
<p>两种行记录格式 Compact 和 Redundant 在磁盘上按照以下方式存储：</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/29fabb2da77243758ba324c75ed25e21.jpeg" alt="img"></p>
<p>Compact 和 Redundant 格式最大的不同就是记录格式的第一个部分；在 Compact 中，行记录的第一部分倒序存放了一行数据中列的长度（Length），而 Redundant 中存的是每一列的偏移量（Offset），从总体上上看，Compact 行记录格式相比 Redundant 格式能够减少 20% 的存储空间。</p>
<h3 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h3><p>当 InnoDB 使用 Compact 或者 Redundant 格式存储<strong>极长的 VARCHAR 或者 BLOB 这类大对象</strong>时，我们并不会直接将所有的内容都存放在数据页节点中，而是将行数据中的前 <strong>768</strong> 个字节存储在<strong>数据页</strong>中，后面会通过偏移量指向<strong>溢出页</strong>。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/7636bec2081d4035bfa8abd2e6e402e1.jpeg" alt="img"></p>
<p>但是当我们使用新的行记录格式 Compressed 或者 Dynamic 时都只会在行记录中保存 20 个字节的指针，实际的数据都会存放在溢出页面中。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/78c3c2b5a0f54e418ae4a8d82ba31593.jpeg" alt="img"></p>
<p>当然在实际存储中，可能会对不同长度的 TEXT 和 BLOB 列进行优化，不过这就不是本文关注的重点了。</p>
<p>想要了解更多与 InnoDB 存储引擎中记录的数据格式的相关信息，可查看官方文档 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/internals/en/innodb-record-structure.html">InnoDB Record Structure</a></p>
<h3 id="数据页结构"><a href="#数据页结构" class="headerlink" title="数据页结构"></a>数据页结构</h3><p>页是 InnoDB 存储引擎管理数据的最小磁盘单位，而 B-Tree 节点就是实际存放表中数据的页面，我们在这里将要介绍页是如何组织和存储记录的；首先，一个 InnoDB 页有以下七个部分：</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/481bd5bdd7c44c4a92b5b1fee845b952.jpeg" alt="img"></p>
<p>每一个页中包含了两对 header/trailer：内部的 Page Header/Page Directory 关心的是页的状态信息，而 Fil Header/Fil Trailer 关心的是记录页的头信息。</p>
<p>在页的头部和尾部之间就是用户记录和空闲空间了，每一个数据页中都包含 Infimum 和 Supremum 这两个<strong>虚拟</strong>的记录（可以理解为占位符），Infimum 记录是比该页中任何主键值都要小的值，Supremum 是该页中的最大值：</p>
<p>User Records 就是整个页面中真正用于存放行记录的部分，而 Free Space 就是空余空间了，它是一个链表的数据结构，为了保证插入和删除的效率，整个页面并不会按照主键顺序对所有记录进行排序，它会自动从左侧向右寻找空白节点进行插入，行记录在物理存储上并不是按照顺序的，它们之间的顺序是由 next_record这一指针控制的。</p>
<p><strong>B+ 树在查找对应的记录时，并不会直接从树中找出对应的行记录，它只能获取记录所在的页，将整个页加载到内存中，再通过 Page Directory 中存储的稀疏索引和 n_owned、 next_record属性取出对应的记录，不过因为这一操作是在内存中进行的，所以通常会忽略这部分查找的耗时。</strong></p>
<p>InnoDB 存储引擎中对数据的存储是一个非常复杂的话题，这一节中也只是对表、行记录以及页面的存储进行一定的分析和介绍，想要真正消化这部分内容还需要很多的努力和实践。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引是数据库中非常非常重要的概念，它是存储引擎能够快速定位记录的秘密武器，对于提升数据库的性能、减轻数据库服务器的负担有着非常重要的作用；<strong>索引优化是对查询性能优化的最有效手段</strong>，它能够轻松地将查询的性能提高几个数量级。</p>
<h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><p>在上一节中，我们谈了行记录的存储和页的存储，在这里我们就要从更高的层面看 InnoDB 中对于数据是如何存储的；InnoDB 存储引擎在绝大多数情况下使用 B+ 树建立索引，这是关系型数据库中查找最为常用和有效的索引，但是B+ 树索引并不能找到一个给定键对应的具体值，它只能找到数据行对应的页，然后正如上一节所提到的，数据库把整个页读入到内存中，并在内存中查找具体的数据行。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/1ee74dd1ddf0471e8744c704993ec642.jpeg" alt="img"></p>
<p>B+ 树是平衡树，它查找任意节点所耗费的时间都是完全相同的，比较的次数就是 B+ 树的高度；在这里，我们并不会深入分析或者动手实现一个 B+ 树，只是对它的特性进行简单的介绍。</p>
<h3 id="聚集索引和辅助索引"><a href="#聚集索引和辅助索引" class="headerlink" title="聚集索引和辅助索引"></a>聚集索引和辅助索引</h3><p>数据库中的 B+ 树索引可以分为聚集索引（clustered index）和辅助索引（secondary index），它们之间的最大区别就是，聚集索引中存放着一条行记录的全部信息，而辅助索引中只包含索引列和一个用于查找对应行记录的『书签』。</p>
<h4 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h4><p>InnoDB 存储引擎中的表都是使用索引组织的，也就是按照键的顺序存放；聚集索引就是按照表中主键的顺序构建一棵 B+ 树，并在叶节点中存放表中的行记录数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users(</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    first_name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    last_name <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    age <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(id),</span><br><span class="line">    KEY(last_name, first_name, age)</span><br><span class="line">    KEY(first_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>如果使用上面的 SQL 在数据库中创建一张表，B+ 树就会使用 <code>id</code> 作为索引的键，并在叶子节点中存储一条记录中的<strong>所有</strong>信息。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/Clustered-Index.jpg" alt="Clustered-Index"></p>
<p>图中对 B+ 树的描述与真实情况下 B+ 树中的数据结构有一些差别，不过这里想要表达的主要意思是：聚集索引叶节点中保存的是整条行记录，而不是其中的一部分。</p>
<p>聚集索引与表的物理存储方式有着非常密切的关系，所有正常的表应该<strong>有且仅有一个</strong>聚集索引（绝大多数情况下都是主键），表中的所有行记录数据都是按照<strong>聚集索引</strong>的顺序存放的。</p>
<p>当我们使用聚集索引对表中的数据进行检索时，可以直接获得聚集索引所对应的整条行记录数据所在的<strong>页</strong>，不需要进行第二次操作。</p>
<h4 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h4><p>数据库将所有的非聚集索引都划分为辅助索引，但是这个概念对我们理解辅助索引并没有什么帮助；辅助索引也是通过 B+ 树实现的，但是它的叶节点并不包含行记录的全部数据，仅包含索引中的所有键和一个用于查找对应行记录的『书签』，在 InnoDB 中这个书签就是当前记录的主键。</p>
<p>辅助索引的存在并不会影响聚集索引，因为聚集索引构成的 B+ 树是数据实际存储的形式，而辅助索引只用于加速数据的查找，所以一张表上往往有多个辅助索引以此来提升数据库的性能。</p>
<blockquote>
<p>一张表一定包含一个聚集索引构成的 B+ 树以及若干辅助索引的构成的 B+ 树。</p>
</blockquote>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/Secondary-Index.jpg" alt="Secondary-Index"></p>
<p>如果在表 <code>users</code> 中存在一个辅助索引 <code>(first_name, age)</code>，那么它构成的 B+ 树大致就是上图这样，按照 <code>(first_name, age)</code> 的字母顺序对表中的数据进行排序，当查找到主键时，再通过聚集索引获取到整条行记录。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/Clustered-Secondary-Index.jpg" alt="Clustered-Secondary-Index"></p>
<p>上图展示了一个使用辅助索引查找一条表记录的过程：通过辅助索引查找到对应的主键，最后在聚集索引中使用主键获取对应的行记录，这也是通常情况下行记录的查找方式。</p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h2><h3 id="共享和互斥的锁"><a href="#共享和互斥的锁" class="headerlink" title="共享和互斥的锁"></a>共享和互斥的锁</h3><p>InnoDB 实现了标准的行级锁，也就是共享锁（Shared Lock）和互斥锁（Exclusive Lock）</p>
<ul>
<li><strong>共享锁（读锁）</strong>：允许事务对一条行数据进行读取；</li>
<li><strong>互斥锁（写锁）</strong>：允许事务对一条行数据进行删除或更新；</li>
</ul>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>无论是共享锁还是互斥锁其实都只是对某一个数据行进行加锁，InnoDB 支持多种粒度的锁，也就是行锁和表锁；为了支持多粒度锁定，InnoDB 存储引擎引入了意向锁（Intention Lock），意向锁就是一种<strong>表级锁</strong>。</p>
<p>意向锁也分为两种：</p>
<ul>
<li><strong>意向共享锁</strong>：事务想要在获得表中某些记录的共享锁，需要在表上先加意向共享锁；</li>
<li><strong>意向互斥锁</strong>：事务想要在获得表中某些记录的互斥锁，需要在表上先加意向互斥锁；</li>
</ul>
<p>LOCK_MODE分别是：IS或IX。</p>
<p>随着意向锁的加入，锁类型之间的兼容矩阵也变得愈加复杂：</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/Lock-Type-Compatibility-Matrix.jpg" alt="Lock-Type-Compatibility-Matrix"></p>
<p>意向锁其实不会阻塞全表扫描之外的任何请求，它们的主要目的是为了表示<strong>是否有人请求锁定表中的某一行数据</strong>。</p>
<h3 id="Record-Lock-记录锁"><a href="#Record-Lock-记录锁" class="headerlink" title="Record Lock 记录锁"></a>Record Lock 记录锁</h3><p>记录锁（Record Lock）是加到<strong>索引记录</strong>上的锁，假设我们存在下面的一张表 <code>users</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users(</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    last_name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    first_name <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    age <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(id),</span><br><span class="line">    KEY(last_name),</span><br><span class="line">    KEY(age)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>如果我们使用 <code>id</code> 或者 <code>last_name</code> 作为 SQL 中 <code>WHERE</code> 语句的过滤条件，那么 InnoDB 就可以通过索引建立的 B+ 树找到行记录并添加锁，但是如果使用 <code>first_name</code> 作为过滤条件时，由于 InnoDB 不知道待修改的记录具体存放的位置，也无法对将要修改哪条记录提前做出判断就会锁定整个表。</p>
<h3 id="Gap-Lock-间隙锁"><a href="#Gap-Lock-间隙锁" class="headerlink" title="Gap Lock 间隙锁"></a>Gap Lock 间隙锁</h3><p>间隙锁是对<strong>索引记录</strong>中的一段<strong>连续区域</strong>的锁；当使用类似 <code>SELECT * FROM users WHERE id BETWEEN 10 AND 20 FOR UPDATE;</code> 的 SQL 语句时，就会阻止其他事务向表中插入 <code>id = 15</code> 的记录，因为整个范围都被间隙锁锁定了。</p>
<blockquote>
<p>间隙锁是存储引擎对于性能和并发做出的权衡，并且只用于某些事务隔离级别。</p>
</blockquote>
<p>虽然间隙锁中也分为共享锁和互斥锁，不过它们之间并不是互斥的，也就是不同的事务可以同时持有一段相同范围的共享锁和互斥锁，它<strong>唯一阻止的就是其他事务向这个范围中添加新的记录</strong>。可以解决幻读的问题。</p>
<h3 id="Next-Key-Lock-临键锁"><a href="#Next-Key-Lock-临键锁" class="headerlink" title="Next-Key Lock 临键锁"></a>Next-Key Lock 临键锁</h3><p>Next-Key Lock 是记录锁和记录前的间隙锁的结合，在 <code>users</code> 表中有以下记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">------|-------------|--------------|-------+</span></span><br><span class="line"><span class="operator">|</span>   id <span class="operator">|</span> last_name   <span class="operator">|</span> first_name   <span class="operator">|</span>   age <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span><span class="comment">------|-------------|--------------|-------|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> stark       <span class="operator">|</span> tony         <span class="operator">|</span>    <span class="number">21</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> tom         <span class="operator">|</span> hiddleston   <span class="operator">|</span>    <span class="number">30</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> morgan      <span class="operator">|</span> freeman      <span class="operator">|</span>    <span class="number">40</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> jeff        <span class="operator">|</span> dean         <span class="operator">|</span>    <span class="number">50</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> donald      <span class="operator">|</span> trump        <span class="operator">|</span>    <span class="number">80</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------|-------------|--------------|-------+</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>既然叫 Next-Key 锁，锁定的应该是当前值和后面的范围，但是实际上却不是，Next-Key 锁锁定的是当前值和前面的范围。</p>
</blockquote>
<p>如果使用 Next-Key 锁，那么 Next-Key 锁就可以在需要的时候锁定以下的范围：</p>
<p>当我们更新一条记录，比如 <code>SELECT * FROM users WHERE age = 30 FOR UPDATE;</code>，InnoDB 不仅会在范围 <code>(21, 30]</code> 上加 Next-Key 锁，还会在这条记录后面的范围 <code>(30, 40]</code> 加间隙锁，所以插入 <code>(21, 40]</code> 范围内的记录都会被锁定。</p>
<p>​    Next-Key 锁的作用其实是为了<strong>解决幻读</strong>的问题。<br>Next-Key Lock在不同的场景中会退化:</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>退化成的锁类型</th>
</tr>
</thead>
<tbody><tr>
<td>使用unique index精确匹配（=），且记录存在</td>
<td>Record Lock</td>
</tr>
<tr>
<td>使用unique index精确匹配（=），且记录不存在</td>
<td>Gap Lock</td>
</tr>
<tr>
<td>使用unique index范围匹配（&lt; 和 &gt; ）</td>
<td>Record Lock + Gap Lock，锁上界不锁下界（或者锁下界不锁上界，与&gt;还是&lt;有关）</td>
</tr>
</tbody></table>
<h3 id="Insert-Intention-Locks-插入意向锁"><a href="#Insert-Intention-Locks-插入意向锁" class="headerlink" title="Insert Intention Locks 插入意向锁"></a>Insert Intention Locks 插入意向锁</h3><ul>
<li>插入意向锁是一种Gap锁，不是意向锁，是在行插入之前通过INSERT操作设置的一种特殊间隙锁。</li>
<li>在多事务同时写入不同数据至同一索引间隙的时候，并不需要等待其他事务完成，不会发生锁等待。</li>
<li>假设有一个记录索引包含键值4和7，不同的事务分别插入5和6，每个事务都会产生一个加在4-7之间的插入意向锁，获取在插入行上的排它锁，但是不会被互相锁住，因为数据行并不冲突。</li>
<li>不同事务请求同一个间隙的Gap锁并不会阻塞，但如果一个事务请求了Gap锁，另一个事务再请求插入意向锁，则会阻塞。</li>
</ul>
<p>锁的兼容性</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/suodejianrongxing.png" alt="锁的兼容性"></p>
<h3 id="自增锁-AUTO-INC-Locks"><a href="#自增锁-AUTO-INC-Locks" class="headerlink" title="自增锁(AUTO-INC Locks)"></a>自增锁(AUTO-INC Locks)</h3><p>AUTO-INC锁是一种特殊的<strong>表级锁</strong>，发生涉及AUTO_INCREMENT列的事务性插入操作时产生。</p>
<p>AUTO-INC锁是在语句结束后被释放。</p>
<h3 id="空间索引的谓词锁"><a href="#空间索引的谓词锁" class="headerlink" title="空间索引的谓词锁"></a>空间索引的谓词锁</h3><h2 id="锁的选择"><a href="#锁的选择" class="headerlink" title="锁的选择"></a>锁的选择</h2><ol>
<li>如果更新条件没有走索引，例如执行”update test set name=“hello” where name=“world”;” ，此时会进行全表扫描，扫表的时候，要阻止其他任何的更新操作，所以上升为表锁。</li>
<li>如果更新条件为索引字段，但是并非唯一索引（包括主键索引），例如执行“update test set name=“hello” where code=9;” 那么此时更新会使用Next-Key Lock。使用Next-Key Lock的原因：<ol>
<li>首先要保证在符合条件的记录上加上排他锁，会锁定当前非唯一索引和对应的主键索引的值；</li>
<li>还要保证锁定的区间不能插入新的数据。</li>
</ol>
</li>
<li>如果更新条件为唯一索引，则使用Record Lock（记录锁）。</li>
</ol>
<h2 id="加锁操作"><a href="#加锁操作" class="headerlink" title="加锁操作"></a>加锁操作</h2><p>重要影响因素：</p>
<ul>
<li>当前系统隔离级别<ul>
<li>RR</li>
<li>RC</li>
<li>Serializable</li>
</ul>
</li>
<li>根据sql或者执行计划判断其所使用的索引类型<ul>
<li>主键索引</li>
<li>二级索引 &amp; 唯一索引</li>
<li>二级索引 &amp; ！唯一索引</li>
<li>无索引，全表扫描</li>
</ul>
</li>
</ul>
<p>下面列举几种常见场景下的加锁逻辑</p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><ol>
<li>首先对表加上IX锁。</li>
<li>唯一索引冲突检查：如果唯一索引上存在相同项，进行S锁当前读，读到数据则唯一索引冲突，返回异常，否则检查通过。</li>
<li>判断插入位置是否存在Gap锁或Next-Key锁，没有的话直接插入，有的话等待锁释放，并产生插入意向锁。</li>
<li>对插入记录的所有索引项加X锁。</li>
</ol>
<h2 id="死锁原理与分析"><a href="#死锁原理与分析" class="headerlink" title="死锁原理与分析"></a>死锁原理与分析</h2><p>下面，来看看两个死锁的例子 (一个是两个Session的两条SQL产生死锁；另一个是两个Session的一条SQL，产生死锁)：</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/53abaeb5e5aefad98d02e0240739dcc41603799550974.jpeg" alt="sql死锁示例1"></p>
<p>情况一很好理解，也是最常见的死锁，<strong>每个事务</strong>执行两条SQL，分别持有了一把锁，然后加另一把锁，产生死锁。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/f08513e2d2380ea4a428c40ee9c114cb1603799550974.jpeg" alt="sql死锁示例2）——数据库锁看这一篇就足够了12"></p>
<p>​    第二个用例，虽然每个Session都只有一条语句，仍旧会产生死锁。要分析这个死锁，首先必须用到本文前面提到的MySQL加锁的规则。针对Session 1，从name索引出发，读到的[hdc, 1]，[hdc, 6]均满足条件，不仅会加name索引上的记录X锁，而且会加聚簇索引上的记录X锁，加锁顺序为先[1,hdc,100]，后[6,hdc,10]。而Session 2，从pubtime索引出发，[10,6],[100,1]均满足过滤条件，同样也会加聚簇索引上的记录X锁，加锁顺序为[6,hdc,10]，后[1,hdc,100]。发现没有，跟Session 1的加锁顺序正好相反，如果两个Session恰好都持有了第一把锁，请求加第二把锁，死锁就发生了。</p>
<p><strong>结论：</strong>死锁的发生与否，并不在于事务中有多少条SQL语句，<strong>死锁的关键在于</strong>：两个(或以上)的Session<strong>加锁的顺序</strong>不一致。</p>
<h2 id="锁信息查看"><a href="#锁信息查看" class="headerlink" title="锁信息查看"></a>锁信息查看</h2><p>MySQL5.7及之前，可以通过information_schema.innodb_locks查看事务的锁情况，但，只能看到阻塞事务的锁；如果事务并未被阻塞，则在该表中看不到该事务的锁情况。</p>
<p>MySQL8.0删除了information_schema.innodb_locks，添加了performance_schema.data_locks，可以通过performance_schema.data_locks查看事务的锁情况，和MySQL5.7及之前不同，performance_schema.data_locks不但可以看到阻塞该事务的锁，还可以看到该事务所持有的锁，也就是说即使事务并未被阻塞，依然可以看到事务所持有的锁（不过，正如文中最后一段所说，performance_schema.data_locks并不总是能看到全部的锁）。表名的变化其实还反映了8.0的performance_schema.data_locks更为通用了，即使你使用InnoDB之外的存储引擎，你依然可以从performance_schema.data_locks看到事务的锁情况。</p>
<p>data_locks详见<a target="_blank" rel="noopener" href="https://www.huaweicloud.com/articles/f571bafcbe55475cd94d1f2f65e729a9.html">官方文档</a>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> performance_schema.data_locks\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: <span class="number">139664434886512</span>:<span class="number">1059</span>:<span class="number">139664350547912</span></span><br><span class="line">ENGINE_TRANSACTION_ID: <span class="number">2569</span></span><br><span class="line">            THREAD_ID: <span class="number">46</span></span><br><span class="line">             EVENT_ID: <span class="number">12</span></span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: t1</span><br><span class="line">       PARTITION_NAME: <span class="keyword">NULL</span></span><br><span class="line">    SUBPARTITION_NAME: <span class="keyword">NULL</span></span><br><span class="line">           INDEX_NAME: <span class="keyword">NULL</span></span><br><span class="line">OBJECT_INSTANCE_BEGIN: <span class="number">139664350547912</span></span><br><span class="line">            LOCK_TYPE: <span class="keyword">TABLE</span></span><br><span class="line">            LOCK_MODE: IX</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: <span class="keyword">NULL</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">2.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: <span class="number">139664434886512</span>:<span class="number">2</span>:<span class="number">4</span>:<span class="number">1</span>:<span class="number">139664350544872</span></span><br><span class="line">ENGINE_TRANSACTION_ID: <span class="number">2569</span></span><br><span class="line">            THREAD_ID: <span class="number">46</span></span><br><span class="line">             EVENT_ID: <span class="number">12</span></span><br><span class="line">        OBJECT_SCHEMA: test</span><br><span class="line">          OBJECT_NAME: t1</span><br><span class="line">       PARTITION_NAME: <span class="keyword">NULL</span></span><br><span class="line">    SUBPARTITION_NAME: <span class="keyword">NULL</span></span><br><span class="line">           INDEX_NAME: GEN_CLUST_INDEX</span><br><span class="line">OBJECT_INSTANCE_BEGIN: <span class="number">139664350544872</span></span><br><span class="line">            LOCK_TYPE: RECORD</span><br><span class="line">            LOCK_MODE: X</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: supremum pseudo<span class="operator">-</span>record</span><br></pre></td></tr></table></figure>

<p>重点字段：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ENGINE_TRANSACTION_ID,OBJECT_NAME,INDEX_NAME,LOCK_TYPE,LOCK_MODE,LOCK_STATUS,LOCK_DATA <span class="keyword">from</span> performance_schema.data_locks;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ENGINE_TRANSACTION_ID</p>
<ul>
<li>请求锁的事务的存储引擎内部ID。这可以被认为是锁的所有者，尽管锁可能仍然是挂起的，实际上还没有授予(LOCK_STATUS=’WAITING’)。如果事务还没有执行任何写操作(仍然认为是只读的)，则该列包含用户不应该尝试解释的内部数据。否则，列就是事务ID。对于InnoDB，为了获得事务的详细信息，将该列与INFORMATION_SCHEMA <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/information-schema-innodb-trx-table.html">INNODB_TRX</a>表中的TRX_ID列连接。</li>
</ul>
</li>
<li><p>OBJECT_NAME</p>
<ul>
<li>被锁住的表的名称。</li>
</ul>
</li>
<li><p>INDEX_NAME</p>
<ul>
<li>锁定索引的名称(如果有的话);否则为null。实际上，InnoDB总是创建一个索引(GEN_CLUST_INDEX)，所以InnoDB表的INDEX_NAME是非null。</li>
</ul>
</li>
<li><p>LOCK_TYPE</p>
<ul>
<li>锁的类型。取值依赖存储引擎。对于InnoDB，行级锁允许的值是RECORD，表级锁允许的值是TABLE。</li>
</ul>
</li>
<li><p>LOCK_MODE</p>
<ul>
<li>如何请求锁。取值依赖存储引擎。对于InnoDB，允许的值为S[，GAP]， X[，GAP]， IS[，GAP]， IX[，GAP]， AUTO_INC, UNKNOWN。除AUTO_INC和UNKNOWN之外的锁模式表示间隙锁(如果存在)。关于S, X, IS, IX和gap锁的信息，请参考<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html">InnoDB Locking</a>。</li>
</ul>
</li>
<li><p>LOCK_STATUS</p>
<ul>
<li>锁的请求状态。取值依赖存储引擎。对于InnoDB，允许的值是GRANTED(锁被持有)和WAITING(锁被等待)。</li>
</ul>
</li>
<li><p>LOCK_DATA</p>
<ul>
<li>与锁相关联的数据(如果有)。取值依赖存储引擎。对于InnoDB, LOCK_TYPE为RECORD时显示一个值，否则为NULL。对于放置在主键索引上的锁，将显示锁定记录的主键值。显示被锁定记录的次级索引值，并为放置在次级索引上的锁附加主键值。如果没有主键，根据管理InnoDB集群索引使用的规则(参见集群索引和二级索引)，LOCK_DATA将显示所选唯一索引的键值或唯一InnoDB内部行ID号。LOCK_DATA对一个最高伪记录上获取的锁报告为“supremum pseudo-record”。如果包含锁定记录的页面不在缓冲池中，因为它在锁被持有时被写入了磁盘，InnoDB不会从磁盘获取该页面。相反，LOCK_DATA报告为NULL。</li>
</ul>
</li>
</ul>
<h1 id="几种隔离级别"><a href="#几种隔离级别" class="headerlink" title="几种隔离级别"></a>几种隔离级别</h1><p>事务的隔离性是数据库处理数据的几大基础之一，而隔离级别其实就是提供给用户用于在性能和可靠性做出选择和权衡的配置项。</p>
<p>ISO 和 ANSI SQL 标准制定了四种事务隔离级别，而 InnoDB 遵循了 SQL:1992 标准中的四种隔离级别：<code>READ UNCOMMITED</code>、<code>READ COMMITED</code>、<code>REPEATABLE READ</code> 和 <code>SERIALIZABLE</code>；每个事务的隔离级别其实都比上一级多解决了一个问题：</p>
<ul>
<li><code>RAED UNCOMMITED</code>：使用查询语句不会加锁，可能会读到未提交的行（Dirty Read）；</li>
<li><code>READ COMMITED</code>：只对记录加记录锁，而不会在记录之间加间隙锁，所以允许新的记录插入到被锁定记录的附近，所以再多次使用查询语句时，可能得到不同的结果（Non-Repeatable Read）；</li>
<li><code>REPEATABLE READ</code>：多次读取同一范围的数据会返回第一次查询的快照，不会返回不同的数据行，但是可能发生幻读（Phantom Read）；</li>
<li><code>SERIALIZABLE</code>：InnoDB 隐式地将全部的查询语句加上共享锁，解决了幻读的问题；</li>
</ul>
<p><strong>MySQL 中默认的事务隔离级别就是 <code>REPEATABLE READ</code>，但是它通过 Next-Key 锁也能够在某种程度上解决幻读的问题。</strong></p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/Transaction-Isolation-Matrix.jpg" alt="Transaction-Isolation-Matrix"></p>
<p><strong>快照读（一致性非锁定读）：</strong></p>
<p>简单的select操作，没有lock in share mode或for update，快照读不会加任何的锁，而且由于mysql的一致性非锁定读的机制存在，任何快照读也不会被阻塞。但是如果事务的隔离级别是SERIALIZABLE的话，那么快照读也会被加上共享的next-key锁，本文不对SERIALIZABLE隔离级别做叙述。</p>
<p><strong>当前读（一致性锁定读）：</strong></p>
<p>官方文档的术语叫locking read，也就是insert，update，delete,select..in share mode和select..for update,当前读会在所有扫描到的索引记录上加锁，不管它后面的where条件到底有没有命中对应的行记录。当前读可能会引起死锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? lock <span class="keyword">in</span> share mode;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">for</span> update;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="keyword">values</span> (…);</span><br><span class="line">update <span class="keyword">table</span> <span class="keyword">set</span> ? <span class="keyword">where</span> ?;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ?;</span><br></pre></td></tr></table></figure>

<ul>
<li>所有以上的语句，都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句，<strong>对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)。</strong></li>
</ul>
<p>为什么将 插入/更新/删除 操作，都归为当前读？可以看看下面这个 更新 操作，在数据库中的执行流程：</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/c391f56ae077738c088a69e5d9fd3eed1603799550970.jpeg" alt="MySQL 加锁处理分析"></p>
<p>从图中，可以看到，一个Update操作的具体流程。当Update SQL被发给MySQL后，MySQL Server会根据where条件，读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，并加锁 (current read)。待MySQL Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，Update操作内部，就包含了一个当前读。同理，Delete操作也一样。Insert操作会稍微有些不同，简单来说，就是Insert操作可能会触发Unique Key的冲突检查，也会进行一个当前读。</p>
<p><strong>注</strong>：根据上图的交互，针对一条当前读的SQL语句，InnoDB与MySQL Server的交互，是一条一条进行的，因此，加锁也是一条一条进行的。先对一条满足条件的记录加锁，返回给MySQL Server，做一些DML操作；然后在读取下一条加锁，直至读取完毕。</p>
<h1 id="Binlog"><a href="#Binlog" class="headerlink" title="Binlog"></a>Binlog</h1><p>Mysql binlog是二进制日志文件，在mysql主从复制中就是依靠的binlog。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> binlog events <span class="keyword">in</span> <span class="string">&#x27;binlogfile&#x27;</span>; <span class="comment">-- 查看binlog的具体事件类型。</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;binlog_format&#x27;</span>; <span class="comment">-- 查看binlog format。</span></span><br></pre></td></tr></table></figure>

<p>binlog记录的所有操作实际上都有对应的事件类型的，MySQL binlog的三种工作模式：</p>
<ul>
<li>Row level（用到MySQL的特殊功能如存储过程、触发器、函数，又希望数据最大化，则选择Row模式）<br> 　简介：日志中会记录每一行数据被修改的情况，然后在slave端对相同的数据进行修改。<pre><code>　优点：能清楚的记录每一行数据修改的细节
　缺点：数据量太大
</code></pre>
</li>
<li>Statement level（默认）<br> 　简介：每一条被修改数据的sql都会记录到master的bin-log中，slave在复制的时候sql进程会解析成和原来master端执行过的相同的sql再次执行。在主从同步中一般是不建议用statement模式的，因为会有些语句不支持，比如语句中包含UUID函数，以及LOAD DATA IN FILE语句等<pre><code>　优点：解决了 Row level下的缺点，不需要记录每一行的数据变化，减少bin-log日志量，节约磁盘IO，提高新能
　缺点：容易出现主从复制不一致
</code></pre>
</li>
<li>Mixed（混合模式）<br> 　简介：结合了Row level和Statement level的优点，同时binlog结构也更复杂。在Mixed模式下，一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog，MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。</li>
</ul>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/webp-20210817172959146" alt="img"></p>
<p>下面描述几个重要的EVENT类型：</p>
<ul>
<li>QUERY_EVENT<ul>
<li>QUERY_EVENT以文本的形式来记录事务的操作。QUERY_EVENT类型的事件通常在以下几种情况下使用：<ol>
<li>事务开始时，执行的BEGIN操作。</li>
<li>STATEMENT格式中的DML操作。</li>
<li>ROW格式中的DDL操作。</li>
</ol>
</li>
</ul>
</li>
<li>FORMAT_DESCRIPTION_EVENT<ul>
<li>它是binlog文件中的第一个事件，而且，该事件只会在binlog中出现一次。MySQL根据FORMAT_DESCRIPTION_EVENT的定义来解析其它事件。<br> 它通常指定了MySQL Server的版本，binlog的版本，该binlog文件的创建时间。</li>
</ul>
</li>
<li>ROWS_EVENT<ul>
<li>对于ROW格式的binlog，所有的DML语句都是记录在ROWS_EVENT中。<br> ROWS_EVENT分为三种：WRITE_ROWS_EVENT，UPDATE_ROWS_EVENT，DELETE_ROWS_EVENT，分别对应insert，update和delete操作。<ul>
<li>对于insert操作，WRITE_ROWS_EVENT包含了要插入的数据</li>
<li>对于update操作，UPDATE_ROWS_EVENT不仅包含了修改后的数据，还包含了修改前的值。</li>
<li> 对于delete操作，仅仅需要指定删除的主键（在没有主键的情况下，会给定所有列）</li>
</ul>
</li>
</ul>
</li>
<li>XID_EVENT<ul>
<li>在事务提交时，不管是STATEMENT还是ROW格式的binlog，都会在末尾添加一个XID_EVENT事件代表事务的结束。该事件记录了该事务的ID，在MySQL进行崩溃恢复时，根据事务在binlog中的提交情况来决定是否提交存储引擎中状态为prepared的事务。</li>
</ul>
</li>
<li>ROTATE_EVENT<ul>
<li>当binlog文件的大小达到max_binlog_size的值或者执行flush logs命令时，binlog会发生切换，这个时候会在当前的binlog日志添加一个ROTATE_EVENT事件，用于指定下一个日志的名称和位置。</li>
</ul>
</li>
<li>GTID_LOG_EVENT</li>
<li>PREVIOUS_GTIDS_LOG_EVENT</li>
<li>STOP_EVENT<ul>
<li>当MySQL数据库停止时，会在当前的binlog末尾添加一个STOP_EVENT事件表示数据库停止。</li>
</ul>
</li>
<li>HEARTBEAT_LOG_EVENT<ul>
<li>这个事件是由master发给slave的，让slave知道master还活着。</li>
</ul>
</li>
</ul>
<h1 id="WAL机制"><a href="#WAL机制" class="headerlink" title="WAL机制"></a>WAL机制</h1><p>WAL（Write-Ahead Logging）技术，也就是<strong>先写日志，再写磁盘</strong>。</p>
<p>当内存数据页跟磁盘数据页内容不一致的时候，我们成这个内存页为“<strong>脏页</strong>”。内存数据写入磁盘后，内存和磁盘上的数据页内容就一致了，称为“干净页”。</p>
<p>MySQL 从 内存更新到磁盘的过程，称为刷脏页的过程（flush）。</p>
<h4 id="InnoDB-刷脏页的时机"><a href="#InnoDB-刷脏页的时机" class="headerlink" title="InnoDB 刷脏页的时机"></a>InnoDB 刷脏页的时机</h4><ul>
<li>内存中的<strong>redo log 写满</strong>了，这时系统就会<strong>停止所有更新</strong>操作，把checkoutpoint 往前推，redo log留出空间可以继续写。</li>
</ul>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/webp-20210817164427455" alt="img"></p>
<p>往前推进之后，就要把两个点之间的日志对应的所有脏页都 flush 到磁盘上。</p>
<p>这种情况是 InnoDB 要尽量避免的。因为出现这种情况，整个系统都不能接受更新。更新数会跌为0。 </p>
<ul>
<li><p>系统中内存不足时，当这个时候需要新的数据页到内存中，就要淘汰掉一些数据页，如果淘汰的是“脏页”，就要先将“脏页”写到磁盘。</p>
<p>这种情况在日常应用中其实是常态。<strong>在InnoDB 中，使用缓冲池 （buffer pool）管理内存，缓冲池中的内存页有三种状态：</strong></p>
<ul>
<li>还没有使用的；</li>
<li>使用了并且是干净页</li>
<li>使用了并且是脏页</li>
</ul>
</li>
<li><p>数据库空闲的时候刷脏页。</p>
</li>
<li><p>数据库正常关闭的时候，也要把内存中所有的脏页全都flush 到磁盘上。</p>
</li>
</ul>
<h4 id="对性能的影响"><a href="#对性能的影响" class="headerlink" title="对性能的影响"></a>对性能的影响</h4><p>刷脏页是常态，所以如果出现以下的情况，都会明明显影响性能：</p>
<ul>
<li>一个查询要淘汰的脏页太多，会导致查询的响应时间明显变长；</li>
<li>日志写满，更新全部堵住，写性能跌为0，这种情况对于敏感业务来说是不能接受的。</li>
</ul>
<h4 id="binlog-的写入机制"><a href="#binlog-的写入机制" class="headerlink" title="binlog 的写入机制"></a>binlog 的写入机制</h4><p>binlog 的写入机制比较简单：事务执行的过程中，先把日志写到 binlog cache，事务提交的时候，再把 binlog cache 写到binlog 文件中。</p>
<p>系统给 binlog cache 分配了一片内存，每个线程一个，参数 binglog_cache_size 用于控制单个线程内 binlog cache 的内存大小，超过就要暂存在磁盘。</p>
<p>事务提交的时候，执行器把 binlog cache 里完整事务写入到 binlog 中，并清空 binlog cache。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/webp-20210817165909518" alt="img"></p>
<ul>
<li>write 指的是把日志写入到<strong>文件系统的 page cache</strong>，并没有把数据持久化到磁盘，所以速度比较快。</li>
<li>fsync 是持久化到磁盘的操作，一般情况下， fsync 才会占磁盘的 IOPS。</li>
</ul>
<p>write 和 fsync 的时机，是由参数 sync_binlog 控制的：</p>
<ul>
<li>sync_binlog=0 的时候，表示每次提交事务都只 write，不 fsync；</li>
<li>sync_binlog=1 的时候，表示每次提交事务都会执行 fsync；</li>
<li>sync_binlog=N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</li>
</ul>
<p>因此，在出现 IO 瓶颈的场景里，将 sync_binlog 设置成一个比较大的值，可以提升性能。在实际的业务场景中，考虑到丢失日志量的可控性，一般不建议将这个参数设成 0，比较常见的是将其设置为 100~1000 中的某个数值。但是，将 sync_binlog 设置为 N，对应的风险是：如果主机发生异常重启，会丢失最近 N 个事务的 binlog 日志。</p>
<h4 id="redo-log-的写入机制"><a href="#redo-log-的写入机制" class="headerlink" title="redo log 的写入机制"></a>redo log 的写入机制</h4><p>事务的执行过程中，生成的 redo log 是要先写到 redo log buffer。</p>
<p>redo log 三种状态：</p>
<ul>
<li>存在 redo log buffer 中，物理上是在 MySQL 进程内存中。</li>
<li>写到磁盘（write），但是没有持久化（fsync），物理上是在文件系统的 page cache 里。</li>
<li>持久化磁盘，对应的是 hard disk。</li>
</ul>
<p>日志写到 redo log buffer 是很快的，write 到 page cache 也差不多，但是持久化到磁盘的速度就慢多了。</p>
<p>InnoDB 提供了 innodb_flush_log_at_trx_commit 参数，取值如下：</p>
<ul>
<li>设置为 0 时，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中；</li>
<li>设置为 1 时，表示每次事务提交时都将 redo log 直接持久化到磁盘；</li>
<li>设置为 2 时，表示每次事务提交时都只是把 redo log 写到 page cache。</li>
</ul>
<p>InnoDB 有一个后台线程，每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。</p>
<p><strong>组提交机制</strong></p>
<p>日志逻辑序列号（log sequence number，LSN）是一个单调递增的值，对应 redo log 的一个个写入点。每次写入的长度为 length 的 redo log，LSN的值就会加上 length。</p>
<p>LSN 也会写到 InnoDB 的数据页中，来确保数据也不会被多次执行重复的 redo log。<br> 在一组提交里面，组员越多，节约磁盘 IOPS 的效果越好。在并发更新的场景下，第一个事务写完 redo log buffer 以后，接下来这个 fsync 越晚调用，组员可能越多，节约 IOPS 的效果就越好。</p>
<ol>
<li>binlog_group_commit_sync_delay 参数，表示延迟多少微秒后才调用 fsync;</li>
<li>binlog_group_commit_sync_no_delay_count 参数，表示累积多少次以后才调用 fsync。</li>
</ol>
<p><strong>WAL机制主要得益于两个方面：</strong></p>
<ol>
<li>redo log 和binlog 都是顺序写，磁盘的顺序写比随机写速度要快；</li>
<li>组提交机制，可以大幅度降低磁盘的 IOPS 消耗。</li>
</ol>
<p><strong>如果你的 MySQL 现在出现了性能瓶颈，而且瓶颈在 IO 上，可以通过哪些方法来提升性能呢？</strong></p>
<p>针对这个问题，可以考虑以下三种方法：</p>
<ol>
<li>设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，减少 binlog 的写盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但没有丢失数据的风险。</li>
<li>将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000）。这样做的风险是，主机掉电时会丢 binlog 日志。</li>
<li>将 innodb_flush_log_at_trx_commit 设置为 2。这样做的风险是，主机掉电的时候会丢数据。</li>
</ol>
<hr>
<blockquote>
<p>感谢参考（摘抄）的文章及其作者</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/158978012">深入理解InnoDB</a></li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/mysql-innodb/">『浅入浅出』MySQL 和 InnoDB</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010841296/article/details/84204701">Mysql锁详解（行锁、表锁、意向锁、Gap锁、插入意向锁）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.huaweicloud.com/articles/f571bafcbe55475cd94d1f2f65e729a9.html">MySQL 加锁处理分析（MVVC、快照读、当前读、GAP锁（间隙锁））</a></li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/mysql-perfschema-excerpt/8.0/en/performance-schema-data-locks-table.html">10.13.1 The data_locks Table</a></li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-predicate-locks">15.7.1 InnoDB Locking</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f242bc1e95ff">MySQL的WAL（Write-Ahead Logging）机制</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ea666baf0d82">Binlog详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lovezhr/p/14820974.html"><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lovezhr/p/14820974.html">MySQL-DoubleWrite</a></a></li>
</ul>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.coder.love/2021/08/14/mysql-transaction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="青马流光">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="青马流光的博客">
      <meta itemprop="description" content="学习笔记">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 青马流光的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/14/mysql-transaction/" class="post-title-link" itemprop="url">Mysql事务</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-14 09:46:09" itemprop="dateCreated datePublished" datetime="2021-08-14T09:46:09+08:00">2021-08-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-21 15:17:04" itemprop="dateModified" datetime="2022-03-21T15:17:04+08:00">2022-03-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h1><ul>
<li>A (atomicity) 原子性<ul>
<li>一个事务中的所有操作要么全部提交成功，要么全部失败回滚，不可能出现只执行其中一部分的情况，这就是原子性。</li>
<li>针对该事务自身而言。</li>
</ul>
</li>
<li>C (consistency) 一致性<ul>
<li>数据库总是从一个一致性的状态到另外一个一致性的状态，不会出现事务开始和结束之间的状态被其他事务看到。</li>
<li>针对该事务自身而言。保证其所产生的结果一定是符合规则（如**<a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Integrity_constraints">constraints</a>, <a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Cascading_rollback">cascades</a>,<a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Database_trigger">triggers</a>**等）的。</li>
</ul>
</li>
<li>I (isolation) 隔离性<ul>
<li>一个事务所做的修改在最终提交以前，对其他事务是不可见的。</li>
<li>针对事务间的互相影响而言。</li>
</ul>
</li>
<li>D (durability) 持久性<ul>
<li>一旦事务提交，则其所做的修改就会永久保存到数据库中。</li>
<li>针对该事务自身而言。</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/ACID_(computer_science)">Wikipedia中关于数据库事务一致性的定义</a>：</p>
<p><a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Consistency_(database_systems)">Consistency</a> ensures that a transaction can <strong>only bring the database from one valid state to another</strong>, maintaining database <a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Invariant_(computer_science)">invariants</a>: <strong>any data written to the database must be valid according to all defined rules, including <a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Integrity_constraints">constraints</a>, <a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Cascading_rollback">cascades</a>,<a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Database_trigger">triggers</a>, and any combination thereof.</strong> This prevents database corruption by an illegal transaction, but does <strong>not guarantee that a transaction is <em>correct</em>.</strong></p>
<p>This(Consistency）does not guarantee correctness of the transaction in all ways the application programmer might have wanted (that is the responsibility of application-level code) but merely that any programming errors cannot result in the violation of any defined database constraints.[1]</p>
</blockquote>
<p>​    事务的实现：事务的(A)原子性、(C)一致性、(D)持久性是由我们的RedoLog(重做日志)、UndoLog(回滚日志)实现，而我们的(I)隔离性由锁实现。</p>
<h1 id="并发事务"><a href="#并发事务" class="headerlink" title="并发事务"></a>并发事务</h1><h2 id="数据库的三种并发场景"><a href="#数据库的三种并发场景" class="headerlink" title="数据库的三种并发场景"></a>数据库的三种并发场景</h2><ul>
<li><strong>读-读</strong>：不存在任何问题，也不需要并发控制。</li>
<li><strong>读-写</strong>：有线程安全问题，可能会造成事务隔离性问题，可能遇到<strong>脏读</strong>、<strong>不可重复读</strong>、<strong>幻读</strong>。</li>
<li><strong>写-写</strong>：有线程安全问题，可能会存在<strong>更新</strong>丢失问题，比如<strong>第一类更新丢失</strong>，<strong>第二类更新丢失</strong>。</li>
</ul>
<h2 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h2><ul>
<li><p><strong>第一类更新丢失(脏写)：</strong></p>
<p>A事务撤销时，把已提交的B事务的数据覆盖掉 。</p>
</li>
<li><p><strong>第二类更新丢失(丢失更新)：</strong>  </p>
<p>A事务提交时，把已提交的B事务的数据覆盖掉。</p>
</li>
<li><p> <strong>脏读：</strong></p>
</li>
</ul>
<p>  A事务对一数据进行了修改，但尚未提交，B事务读取了A事物修改但未提交的数据。A事务发生异常，回滚了数据，那么此时B事务读取的数据就是脏数据。</p>
<ul>
<li><p><strong>不可重复读：</strong>  </p>
<p>A事务内，多次读写同一数据，在A事务并没有结束，B事务对这数据进行了修改，那么A事务两次读取的数据可能就不一样的，这样就发生了同一事务内两次相同的查询读到的数据不一样。 </p>
</li>
<li><p><strong>幻读：</strong>  </p>
<p>事务A 按照一定条件进行数据读取， 期间事务B 插入了相同搜索条件的新数据，事务A再次按照原先条件进行读取时，发现了事务B 新插入的数据 称为幻读。</p>
</li>
</ul>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/%E4%BA%8B%E5%8A%A1%E5%B9%B6%E8%A1%8C%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98.jpg" alt="事务并行带来的问题"></p>
<p>未提交数据的数据引起的问题，为“脏”。</p>
<p>不可重复读的是由update和delete引起，幻读是由insert引起。</p>
<p>幻读产生的原因：行锁只能锁住行，即使把所有行记录都上锁，也阻止不了新插入的记录。</p>
<p>为了解决这些问题，才有了事务的隔离。</p>
<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><ul>
<li><p>读未提交 Read Uncomitted</p>
<ul>
<li>当数据库系统使用READ UNCOMMITTED隔离级别时，一个事务在执行过程中可以看到其他事务没有提交的新插入的记录，而且还能看到其他事务没有提交的对已有记录的更新。</li>
<li>以上问题都可能发生</li>
</ul>
</li>
<li><p>读已提交 Read Committed</p>
<ul>
<li>当数据库系统使用READ COMMITTED隔离级别时，一个事务在执行过程中可以看到其他事务已经提交的新插入的记录，而且还能看到其他事务已经提交的对已有记录的更新。</li>
<li>解决了<strong>脏读</strong>问题，可能有<strong>不可重复读</strong>、<strong>幻读</strong>问题</li>
</ul>
</li>
<li><p>可重复读 Repeable Read（默认）</p>
<ul>
<li><p>当数据库系统使用REPEATABLE READ隔离级别时，一个事务在执行过程中可以看到其他事务已经提交的新插入的记录，但是不能看到其他事务对已有记录的更新。</p>
</li>
<li><p>解决了<strong>脏读</strong>、<strong>不可重复读问题</strong>，但是可能有<strong>幻读</strong>问题</p>
</li>
<li><p><strong>Innodb 引擎</strong>下采用<strong>MVCC</strong>解决了<strong>幻读</strong>问题</p>
</li>
</ul>
</li>
<li><p>串行化 Serializable</p>
<ul>
<li>当数据库系统使用SERIALIZABLE隔离级别时，一个事务在执行过程中完全看不到其他事务对数据库所做的更新。当两个事务同时操作数据库中相同数据时，如果第一个事务已经在访问该数据，第二个事务只能停下来等待，必须等到第一个事务结束后才能恢复运行。因此这两个事务实际上是<strong>串行化方式运行</strong>。</li>
<li>什么问题都不会发生</li>
</ul>
</li>
</ul>
<h2 id="事务的并发控制"><a href="#事务的并发控制" class="headerlink" title="事务的并发控制"></a>事务的并发控制</h2><h2 id="悲观并发控制"><a href="#悲观并发控制" class="headerlink" title="悲观并发控制"></a>悲观并发控制</h2><p>​    在悲观并发控制（Pessimistic Concurrency Control）中，数据库程序对于数据被修改持悲观的态度，在数据处理的过程中都会被锁定，以此来解决竞争的问题。</p>
<h3 id="读写锁（共享锁、互斥锁）"><a href="#读写锁（共享锁、互斥锁）" class="headerlink" title="读写锁（共享锁、互斥锁）"></a>读写锁（共享锁、互斥锁）</h3><p>​    为了最大化数据库事务的并发能力，数据库中的锁被设计为两种模式，分别是<strong>共享锁（S）</strong>和<strong>互斥锁（X）</strong>。当一个事务获得共享锁之后，它只可以进行读操作，所以共享锁也叫<strong>读锁</strong>；而当一个事务获得一行数据的互斥锁时，就可以对该行数据进行读和写操作，所以互斥锁也叫<strong>写锁</strong>。</p>
<p>​    多个事务可以同时获得某一<strong>行</strong>数据的共享锁。</p>
<h3 id="多粒度锁"><a href="#多粒度锁" class="headerlink" title="多粒度锁"></a>多粒度锁</h3><p>有些时候我们希望将多个节点看做一个数据单元，使用锁直接将这个数据单元、表甚至数据库锁定起来。这个目标的实现需要我们在数据库中定义不同粒度的锁。</p>
<ul>
<li><p>显示加锁（explicit）:树上每个结点都可以单独加锁</p>
</li>
<li><p>隐式加锁（implicit）:对当前结点加锁会导致隐式地对全部后代结点加上同类型的锁</p>
</li>
</ul>
<p>但这样的话，检查锁冲突时,必须检查祖先、后代结点，性能比较低，于是有了意向锁。</p>
<h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>在原来的X/S锁基础上引入了IX/IS，<strong>IX/IS都是表锁</strong>，用来表示一个事务想要或者正在在表中的某个数据行上加X锁或S锁。有以下两个规定：</p>
<ul>
<li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li>
<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li>
</ul>
<p><strong>锁类型兼容关系矩阵</strong>如下：</p>
<table>
<thead>
<tr>
<th align="left">-</th>
<th align="left">X</th>
<th align="left">IX</th>
<th align="left">S</th>
<th align="left">IS</th>
</tr>
</thead>
<tbody><tr>
<td align="left">X</td>
<td align="left">×</td>
<td align="left">×</td>
<td align="left">×</td>
<td align="left">×</td>
</tr>
<tr>
<td align="left">IX</td>
<td align="left">×</td>
<td align="left">√</td>
<td align="left">×</td>
<td align="left">√</td>
</tr>
<tr>
<td align="left">S</td>
<td align="left">×</td>
<td align="left">×</td>
<td align="left">√</td>
<td align="left">√</td>
</tr>
<tr>
<td align="left">IS</td>
<td align="left">×</td>
<td align="left">√</td>
<td align="left">√</td>
<td align="left">√</td>
</tr>
</tbody></table>
<ul>
<li><strong>任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁；</strong></li>
<li>S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可能已经获得对表或者表中的行的 S 锁。</li>
</ul>
<h3 id="两阶段锁协议（2PL）"><a href="#两阶段锁协议（2PL）" class="headerlink" title="两阶段锁协议（2PL）"></a>两阶段锁协议（2PL）</h3><p>两阶段锁协议（2PL）是一种能够保证事务可串行化的协议，它将事务的获取锁和释放锁划分成了<strong>增长（Growing）</strong>和<strong>缩减（Shrinking）</strong>两个不同的阶段。</p>
<ul>
<li>增长阶段：事务可以获得锁但是不能释放锁；</li>
<li>缩减阶段：事务只可以释放锁，并不能获得新的锁。</li>
</ul>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/v2-3d15b3ae70603f60e5507569ace8a819_r.jpg" alt="preview"></p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/v2-4aef706dd8bc745ef269d6c741ce6b3a_r.jpg" alt="preview"></p>
<p>2PL存在级联回滚的可能，于是有了它的两个变种：</p>
<ul>
<li><strong>Strict 2PL</strong>：事务持有的<strong>互斥锁</strong>必须在提交后再释放；</li>
<li><strong>Rigorous 2PL</strong>：事务持有的<strong>所有锁</strong>必须在提交后释放。</li>
</ul>
<p>可能会引发死锁。</p>
<h4 id="死锁的处理"><a href="#死锁的处理" class="headerlink" title="死锁的处理"></a>死锁的处理</h4><ul>
<li><p>预防死锁</p>
<ul>
<li><p>抢占加事务回滚</p>
<ul>
<li><p>wait-die机制</p>
<p>当执行事务的时间戳小于另一事务时，即事务 A 先于 B 开始，那么它就会等待另一个事务释放对应资源的锁，否则就会保持当前的时间戳并回滚。</p>
<p>非抢占。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/wait-die.png" alt="img"></p>
</li>
<li><p>wound-wait机制</p>
<p>当前事务如果先于另一事务执行并请求了另一事务的资源，那么另一事务会立刻回滚，将资源让给先执行的事务，否则就会等待其他事务释放资源。抢占。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/wound-wait.png" alt="img"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>死锁的检测与恢复</p>
<ul>
<li>将事务环中的一个事务进行回滚。选择牺牲品（Victim）时的黄金原则就是<strong>最小化代价</strong>。</li>
<li>回滚分为：全部回滚、部分回滚（回滚到上一个检查点，如果有的话，没有则全部回滚）。</li>
</ul>
</li>
</ul>
<h2 id="乐观并发控制"><a href="#乐观并发控制" class="headerlink" title="乐观并发控制"></a>乐观并发控制</h2><p>乐观并发控制（Optimistic Concurrency Control）也叫乐观锁，但是它并不是真正的锁，很多人都会误以为乐观锁是一种真正的锁，然而<strong>它只是一种并发控制的思想</strong>。</p>
<h3 id="基于时间戳的协议"><a href="#基于时间戳的协议" class="headerlink" title="基于时间戳的协议"></a>基于时间戳的协议</h3><p><strong>基于锁的协议</strong>执行事务的顺序与获得锁的顺序有关。<strong>基于时间戳的协议</strong>能够在事务执行之前先决定事务的执行顺序。</p>
<p>每一个事务都会具有一个<strong>全局唯一</strong>的时间戳，它即可以使用系统的时钟时间，也可以使用计数器，只要能够保证所有的时间戳都是唯一并且是<strong>随时间递增</strong>的就可以。</p>
<p>Basic T/O协议主要特点：</p>
<ul>
<li>每个事务都会被赋予一个Timestamp</li>
<li>每条数据都会记录最近读取该数据的事务id，以及最近写入的事务id</li>
<li>每个事务在读写数据时需要根据事务的timestamp和数据的读写timestamp进行冲突检测</li>
<li>DBMS会把事务读取过的数据拷贝到一个private的空间，来实现可重复读</li>
</ul>
<p>Basic T/O需要对每条记录额外存储以下几个信息：</p>
<ol>
<li><strong>Read Timestamp</strong>: 表示读过该数据中最大的事务Timestamp</li>
<li><strong>Write Timestamp</strong>: 最近更新该数据的事务Timestamp</li>
</ol>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/timestamp-ordering.png" alt="timestamp-ordering-protocol-process"></p>
<p>​    无论是读操作还是写操作都会从左到右依次比较读写时间戳的值，如果小于当前值就会直接被拒绝然后回滚，数据库系统会给回滚的事务添加一个新的时间戳并重新执行这个事务。</p>
<ul>
<li><p>read流程：</p>
<p>If TS &lt; W-ts(x) then reject read request and abort corresponding transaction else execute transaction Set R-ts(x) to max{R-ts(x), TS}</p>
</li>
<li><p>write流程：</p>
<p>If TS &lt; R-ts(x) or TS &lt; W-ts(x) then reject write request and abort corresponding transaction else execute transaction Set W-ts(x) to TS.</p>
</li>
</ul>
<p>Y: 总结就是后来的事务B已经执行操作（对A当前操作有影响的操作）了该数据，那当前事务A就需要回滚。但是这样有一个问题，就是在此之前B已经读了A写入的数据，即“脏读”。</p>
<p><strong>Basic T/O协议的优点和缺点：</strong></p>
<ul>
<li>TO协议确保可串行化，因为优先级图如下：</li>
</ul>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/101018_18427.png" alt="img"></p>
<ul>
<li><p>TS协议确保免于死锁，这意味着没有事务等待。</p>
</li>
<li><p>但是时间表可能无法恢复，甚至可能无法级联。基于时间戳的协议。</p>
</li>
</ul>
<h3 id="基于验证的协议"><a href="#基于验证的协议" class="headerlink" title="基于验证的协议"></a>基于验证的协议</h3><p><em>乐观并发控制</em>其实本质上就是基于验证的协议，因为在多数的应用中只读的事务占了绝大多数，事务之间因为写操作造成冲突的可能非常小，也就是说大多数的事务在不需要并发控制机制也能运行的非常好，也可以保证数据库的一致性；而并发控制机制其实向整个数据库系统添加了很多的开销，我们其实可以通过别的策略降低这部分开销。</p>
<p>而验证协议就是找到的解决办法，它也叫乐观并发控制技术。在基于验证的协议中，根据事务的只读或者更新将所有事务的执行分为两到三个阶段：</p>
<ol>
<li><strong>读阶段</strong> ：在此阶段，读取并执行事务T。它用于读取各种数据项的值并将它们存储在临时局部变量中。 它可以对临时变量执行所有写操作，而无需更新实际数据库。</li>
<li><strong>验证阶段</strong> ：在此阶段，将根据实际数据验证临时变量值，以查看它是否违反了可串行性，即是否有其他事务在读阶段期间更新了数据。</li>
<li><strong>写入阶段</strong> ：如果通过了事务的验证，则将临时结果写入数据库或系统，否则将回滚事务。</li>
</ol>
<h2 id="多版本并发控制-MVCC"><a href="#多版本并发控制-MVCC" class="headerlink" title="多版本并发控制 MVCC"></a>多版本并发控制 MVCC</h2><p>上述的并发控制机制其实都是通过延迟或者终止相应的事务来解决事务之间的竞争条件（Race condition）来保证事务的可串行化；虽然前面的两种并发控制机制确实能够从根本上解决并发事务的可串行化的问题，但是在实际环境中数据库的事务大都是只读的，读请求是写请求的很多倍，如果写请求和读请求之前没有并发控制机制，那么最坏的情况也是读请求读到了已经写入的数据，这对很多应用完全是可以接受的。</p>
<p>在这种大前提下，数据库系统引入了另一种并发控制机制 - <em>多版本并发控制</em>（Multiversion Concurrency Control），每一个写操作都会创建一个新版本的数据，读操作会从有限多个版本的数据中挑选一个最合适的结果直接返回；在这时，读写操作之间的冲突就不再需要被关注，而管理和快速挑选数据的版本就成了 MVCC 需要解决的主要问题。</p>
<p>即<strong>MVCC就是为了以不加锁的方式解决读-写冲突问题</strong>。</p>
<p>MVCC 并不是一个与乐观和悲观并发控制对立的东西，它能够与两者很好的结合以增加事务的并发量。</p>
<ul>
<li><strong>MVCC + 悲观锁</strong><br>MVCC解决读写冲突，悲观锁解决写写冲突</li>
<li><strong>MVCC + 乐观锁</strong><br>MVCC解决读写冲突，乐观锁解决写写冲突</li>
</ul>
<p>在目前最流行的 SQL 数据库 MySQL 和 PostgreSQL 中都对 MVCC 进行了实现：</p>
<ul>
<li><p>PostgreSQL中的MVCC与乐观锁结合，实现的多版本时间戳排序协议（Multiversion Timestamp Ordering）。</p>
</li>
<li><p>Mysql将MVCC与2PL相结合，实现的多版本两段锁协议（Multiversion 2PL）。</p>
</li>
</ul>
<h3 id="Mysql中的MVCC"><a href="#Mysql中的MVCC" class="headerlink" title="Mysql中的MVCC"></a>Mysql中的MVCC</h3><h4 id="当前读-amp-快照读"><a href="#当前读-amp-快照读" class="headerlink" title="当前读&amp;快照读"></a>当前读&amp;快照读</h4><ul>
<li><p><strong>当前读</strong></p>
<p>像select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的<strong>最新版本</strong>，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行<strong>加锁</strong>。</p>
</li>
<li><p><strong>快照读</strong></p>
<p> 像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是<strong>隔离级别不是串行级别</strong>，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC,可以认为MVCC是行锁的一个变种，但它<strong>在很多情况下，避免了加锁</strong>操作，降低了开销；既然是基于多版本，即快照读可能读到的并<strong>不一定是数据的最新版本</strong>，而有可能是之前的历史版本</p>
</li>
</ul>
<h4 id="MVCC实现原理"><a href="#MVCC实现原理" class="headerlink" title="MVCC实现原理"></a>MVCC实现原理</h4><h5 id="隐式字段"><a href="#隐式字段" class="headerlink" title="隐式字段"></a>隐式字段</h5><p>每行记录除了我们自定义的字段外，还有数据库隐式定义的字段：</p>
<ul>
<li><strong>DB_TRX_ID</strong><br> 6byte，最近修改(修改/插入)事务ID，记录创建这条记录/最后一次修改该记录的事务ID。</li>
<li><strong>DB_ROLL_PTR</strong><br> 7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）。</li>
<li><strong>DB_ROW_ID</strong><br> 6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引。</li>
<li>DELETE_BIT: 删除标志位, 即记录被更新或删除并不代表真的删除，而是删除标志位变了。</li>
</ul>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/person.png" alt="img"></p>
<p>如上图，DB_ROW_ID是数据库默认为该行记录生成的唯一隐式主键，DB_TRX_ID是当前操作该记录的事务ID,而DB_ROLL_PTR是一个回滚指针，用于配合undo日志，指向上一个旧版本。</p>
<h5 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h5><p>undo log主要分为两种：</p>
<ul>
<li><p><strong>insert undo log</strong></p>
<p>代表事务在insert新记录时产生的undo log, 只在<strong>事务回滚</strong>时需要，并且在事务提交后可以被立即丢弃代表事务在insert新记录时产生的undo log, 只在事务回滚时需要，并且在<strong>事务提交后可以被立即丢弃</strong>。</p>
</li>
<li><p><strong>update undo log</strong></p>
<p>事务在进行<strong>update或delete</strong>时产生的undo log; 不仅在<strong>事务回滚</strong>时需要，在<strong>快照读</strong>时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除。</p>
</li>
</ul>
<blockquote>
<p>purge</p>
<ul>
<li>从前面的分析可以看出，InnoDB的MVCC机制，更新或者删除操作都只是设置一下老记录的deleted_bit，并不真正将过时的记录删除。</li>
<li>为了节省磁盘空间，InnoDB有专门的purge线程来清理deleted_bit为true的记录。为了不影响MVCC的正常工作，purge线程自己也维护了一个read view（这个read view相当于系统中最老活跃事务的read view）;如果某个记录的deleted_bit为true，并且DB_TRX_ID相对于purge线程的read view可见，那么这条记录一定是可以被安全清除的。</li>
</ul>
</blockquote>
<p>不同事务或者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录版本线性表，即链表，undo log的链首就是最新的旧记录，链尾就是最早的旧记录（当然就像之前说的该undo log的节点可能是会purge线程清除掉）。</p>
<h5 id="Read-View-读视图"><a href="#Read-View-读视图" class="headerlink" title="Read View 读视图"></a>Read View 读视图</h5><p>Read View就是事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)。</p>
<p>Read View主要是用来做可见性判断的, 即当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。</p>
<p>Read View遵循一个可见性算法，主要是将要被修改的数据的最新记录中的DB_TRX_ID（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由Read View维护），如果DB_TRX_ID跟Read View的属性做了某些比较，不符合可见性，那就通过DB_ROLL_PTR回滚指针去取出Undo Log中的DB_TRX_ID再比较，即遍历链表的DB_TRX_ID（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的DB_TRX_ID, 那么这个DB_TRX_ID所在的旧记录就是当前事务能看见的最新老版本。</p>
<p>那么这个可见性的判断条件是什么呢？</p>
<p>说明：下面内容及源码所摘录的文章应该是基于mysql 5.7版本的。</p>
<p>我们可以把Read View简单的理解成有四个全局属性：</p>
<blockquote>
<ul>
<li><p>m_ids<br> 快照创建时，处于活动即尚未提交的读写事务的ID集合。</p>
</li>
<li><p>m_up_limit_id<br> 一个快照，有左右边界，左边界是最小值，右边界是最大值，此变量是左边界即m_ids列表中事务ID最小的ID。</p>
</li>
<li><p>m_low_limit_id<br> ReadView生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值+1。</p>
</li>
<li><p>m_createor_trx_id </p>
<p> 创建该ReadView事务的事务ID，即当前事务ID。</p>
</li>
</ul>
</blockquote>
<p>左右边界字段中的up和low让我们有些怀疑其含义，如下源码中可以看到上述几个变量的初始化，可以更准确地理解其定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">ReadView::prepare</span><span class="params">(<span class="keyword">trx_id_t</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ut_ad(mutex_own(&amp;trx_sys-&gt;mutex));</span><br><span class="line"></span><br><span class="line">	m_creator_trx_id = id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// trx_sys-&gt;max_trx_id是当前最小未分配的事务id。</span></span><br><span class="line">	m_low_limit_no = m_low_limit_id = trx_sys-&gt;max_trx_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前只读事务的id拷贝到view中的m_ids。</span></span><br><span class="line">	<span class="keyword">if</span> (!trx_sys-&gt;rw_trx_ids.empty()) &#123;</span><br><span class="line">		copy_trx_ids(trx_sys-&gt;rw_trx_ids);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		m_ids.clear();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// trx_sys-&gt;serialisation_list是事务提交时会加入的一个按照trx-&gt;no排序的列表。</span></span><br><span class="line">    <span class="comment">// 这里取列表中第一个（如果有的话）为m_low_limit_no供purge线程作为是否清理undo的依据。</span></span><br><span class="line">	<span class="keyword">if</span> (UT_LIST_GET_LEN(trx_sys-&gt;serialisation_list) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">trx_t</span>*	trx;</span><br><span class="line"></span><br><span class="line">		trx = UT_LIST_GET_FIRST(trx_sys-&gt;serialisation_list);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (trx-&gt;no &lt; m_low_limit_no) &#123;</span><br><span class="line">			m_low_limit_no = trx-&gt;no;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">ReadView::complete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// m_up_limit_id取活跃事务最小id。</span></span><br><span class="line">	m_up_limit_id = !m_ids.empty() ? m_ids.front() : m_low_limit_id;</span><br><span class="line"></span><br><span class="line">	ut_ad(m_up_limit_id &lt;= m_low_limit_id);</span><br><span class="line"></span><br><span class="line">	m_closed = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于<strong>Read Committed</strong>的隔离级别，在一致性读语句结束后（即一次快照读完成），会关闭掉Read View，即每次快照读都创建新的快照，让其可以读到最新commit的事务的修改。</li>
<li>而对于<strong>Repeatable Read</strong>的隔离级别，Read View在创建后（在该事务第一次快照读时创建）会一直到事务结束时才被关闭，即其创建快照之后所有事务所做的修改对其都不可见。</li>
</ul>
<h5 id="Read-View可见性判断"><a href="#Read-View可见性判断" class="headerlink" title="Read View可见性判断"></a>Read View可见性判断</h5><h6 id="走聚簇索引的情况"><a href="#走聚簇索引的情况" class="headerlink" title="走聚簇索引的情况"></a>走聚簇索引的情况</h6><p>假设sql查询走的是聚簇索引，则通过下面的lock_clust_rec_cons_read_sees方法来判断记录rec是否对当前事务可见。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">lock_clust_rec_cons_read_sees</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> <span class="keyword">rec_t</span>*	rec,	</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">dict_index_t</span>*	index,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> ulint*	offsets,</span></span></span><br><span class="line"><span class="params"><span class="function">	ReadView*	view)</span>	</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ut_ad(dict_index_is_clust(index));</span><br><span class="line">	ut_ad(page_rec_is_user_rec(rec));</span><br><span class="line">	ut_ad(rec_offs_validate(rec, index, offsets));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于InnoDB处于只读模式或者表为临时表的情况永远都是可见的。</span></span><br><span class="line">	<span class="keyword">if</span> (srv_read_only_mode || dict_table_is_temporary(index-&gt;table)) &#123;</span><br><span class="line">		ut_ad(view == <span class="number">0</span> || dict_table_is_temporary(index-&gt;table));</span><br><span class="line">		<span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取行记录上的事务id。</span></span><br><span class="line">	<span class="keyword">trx_id_t</span>	trx_id = row_get_rec_trx_id(rec, index, offsets);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否可见。</span></span><br><span class="line">	<span class="keyword">return</span>(view-&gt;changes_visible(trx_id, index-&gt;table-&gt;name));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面再来看看ReadView::changes_visible方法的实现源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">changes_visible</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">trx_id_t</span>		id,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> <span class="keyword">table_name_t</span>&amp;	name)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    <span class="title">MY_ATTRIBUTE</span><span class="params">((warn_unused_result))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ut_ad(id &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果行记录上的id&lt;m_up_limit_id或者等于m_creator_trx_id则可见。</span></span><br><span class="line">    <span class="keyword">if</span> (id &lt; m_up_limit_id || id == m_creator_trx_id) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    check_trx_id_sanity(id, name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果行记录上的id&gt;=m_low_limit_id，则不可见。</span></span><br><span class="line">    <span class="keyword">if</span> (id &gt;= m_low_limit_id) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m_ids.empty()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ids_t</span>::value_type*	p = m_ids.data();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分判断是否在m_ids中，如果存在则不可见。</span></span><br><span class="line">    <span class="keyword">return</span>(!<span class="built_in">std</span>::binary_search(p, p + m_ids.size(), id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理一下这里判断的依据</p>
<ul>
<li>记录的事务id为m_creator_trx_id即<strong>当前事务</strong>的修改，一定<strong>可见</strong>。</li>
<li>记录的事务id&lt;m_up_limit_id，说明Read View在初始化的时候，修改此记录的事务已经提交了，因此可见。</li>
<li>记录的事务id&gt;=m_low_limit_id，说明Read View在初始化的时候，修改此记录的事务还没开启（准确说是还没被分配到事务id），因此不可见。</li>
</ul>
<p>如果这里不满足的话，会走到<em>row_sel_build_prev_vers_for_mysql-&gt;row_vers_build_for_consistent_read</em>的调用，根据回滚段中的信息不断<strong>构建前一个版本信息</strong>直至当前事务可见。</p>
<h6 id="走二级索引的情况"><a href="#走二级索引的情况" class="headerlink" title="走二级索引的情况"></a>走二级索引的情况</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span></span></span><br><span class="line"><span class="function"><span class="title">lock_sec_rec_cons_read_sees</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> <span class="keyword">rec_t</span>*		rec,	</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> <span class="keyword">dict_index_t</span>*	index,</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="keyword">const</span> ReadView*	view)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ut_ad(page_rec_is_user_rec(rec));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (recv_recovery_is_on()) &#123;</span><br><span class="line">		<span class="keyword">return</span>(<span class="literal">false</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (dict_table_is_temporary(index-&gt;table)) &#123;</span><br><span class="line">		<span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 取索引页上的PAGE_MAX_TRX_ID字段。</span></span><br><span class="line">	<span class="keyword">trx_id_t</span>	max_trx_id = page_get_max_trx_id(page_align(rec));</span><br><span class="line"></span><br><span class="line">	ut_ad(max_trx_id &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>(view-&gt;sees(max_trx_id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是ReadView:sees的实现，可以看到其实就是判断是否PAGE_MAX_TRX_ID小于ReadView初始化时的最小事务id，也就是判断修改页上记录的最大事务id是否在快照生成的时候已经提交了，简单粗暴的很。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sees</span><span class="params">(<span class="keyword">trx_id_t</span> id)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(id &lt; m_up_limit_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此这里<code>lock_sec_rec_cons_read_sees</code>方法如果返回true，那么是一定可见的，返回false的话未必不可见，但下一步就需要利用聚簇索引来获取可见版本的数据了。<br>在这之前InnoDB会先利用ICP(Index Push Down)根据索引信息来判断搜索条件是否满足，如果不满足那也没必要再去聚簇索引中取了；若ICP判断出符合条件，则会走到<code>row_sel_get_clust_rec_for_mysql</code>方法中去聚簇索引中取可见版本数据。</p>
<hr>
<blockquote>
<p>感谢参考的文章及其作者：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.sohu.com/a/408963027_100016227">8张图说清楚MySql 脏写、脏读、不可重复读、幻读到底是怎么回事儿 </a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43081805/article/details/98493923">数据库隔离级别——串行化，可重复读，读提交，读未提交</a></li>
<li><a target="_blank" rel="noopener" href="https://draveness.me/database-concurrency-control/">浅谈数据库并发控制 - 锁和 MVCC</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/158499690">基于封锁的并发控制机制</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010486124/article/details/42426127">数据库事务调度的可恢复性和级联回滚</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/amoscykl/article/details/88784028">数据库系统原理: 封锁 (封锁粒度、封锁类型、封锁协议)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/38dd4f64ebd1">意向锁</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/168746376">基于时间戳的并发控制协议</a></li>
<li><a target="_blank" rel="noopener" href="https://www.knowledgedict.com/tutorial/dbms-validation-based-protocol.html">DBMS基于验证的协议</a></li>
<li><a target="_blank" rel="noopener" href="https://www.knowledgedict.com/tutorial/dbms-timestamp-ordering-protocol.html">DBMS时间戳顺序协议</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8845ddca3b23">MVCC多版本并发控制</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/micrari/p/8144339.html">初探InnoDB MVCC源码实现</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.51cto.com/itzhoujun/2357430">MVCC讲解</a></li>
</ul>
<p>Mysql 官方手册：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html">Mysql官方手册-5.7版本</a></li>
<li><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html">Mysql官方手册-8.0版本</a></li>
</ul>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.coder.love/2021/08/12/HashMap-TreeNode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="青马流光">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="青马流光的博客">
      <meta itemprop="description" content="学习笔记">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 青马流光的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/12/HashMap-TreeNode/" class="post-title-link" itemprop="url">HashMap中的红黑树实现-TreeNode</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-12 11:30:25" itemprop="dateCreated datePublished" datetime="2021-08-12T11:30:25+08:00">2021-08-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-21 12:56:20" itemprop="dateModified" datetime="2022-03-21T12:56:20+08:00">2022-03-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>红黑树源于对2-3-4树的简易实现。参考《<a target="_blank" rel="noopener" href="https://www.cnblogs.com/eniac12/p/5558848.html">Sedgewick的红黑树</a>》</p>
<p>TreeNode 同时实现了两种数据结构：</p>
<ul>
<li>双向链表：prev、next</li>
<li>红黑树：parent、left、right、red</li>
</ul>
<p>​      方便了不同场景的应用，也方便了上层即HashMap中的封装，比如在没有HashMap的containsValue()方法中遍历冲突链表就没有特别去判断是否为树结构，因为TreeNode本身也还是链表结构。</p>
<p>​      这两种结构字段是相互独立的，可以看做两条线，但在发生节点位置变化时，需同时维护两条线的正确。如树结构的平衡性调整之后，root节点可能会变更，root变更即意味了链表结构的头节点变更，所以有了moveRootToFront()方法，将新的头节点（root节点）移动到链表头部。</p>
<p>TreeNode 中元素是如何排序的？</p>
<ol>
<li>通过元素key的hash值：HashMap.hash(key)。（记为1级排序方式）</li>
<li>若hash相同，且元素key为可比较类型，则使用compareComparables方法比较其key。（记为2级排序方式）</li>
<li>若hash相同，且元素key为不可比较类型，则使用tieBreakOrder来 比较两个元素的key。（记为3级排序方式）<ol>
<li>先使用类名即getClass().getName()进行比较</li>
<li>若相同则使用由System.identityHashCode(key)生成的key对象的hashCode。</li>
</ol>
</li>
</ol>
<p><strong>find方法源码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用给定的散列和键查找从根 p 开始的节点。 kc 参数在第一次使用比较key时缓存的其可比较类型。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">            TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">          <span class="comment">// 1. 先使用key的hash进行比较排序，即1级排序方式。</span></span><br><span class="line">            <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                p = pl;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                p = pr;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 2. 执行到此处说明其左右子树的节点均与key的hash相等，但是与key不等，需要使用其它方式进一步排序</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 左节点为空的情况，直接将右节点作为下次循环比较的节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">                p = pr;</span><br><span class="line">          <span class="comment">// 右节点为空的情况，直接将左节点作为下次循环比较的节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">                p = pl;</span><br><span class="line">          <span class="comment">// 左右节点均不为空，根据二级排序方式重新比较pk与k以决定方向，选取下一次循环的比较节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                      (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                     (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 执行到这里说明无法通过comparable比较，或者比较之后还是相等</span></span><br><span class="line">          <span class="comment">// 此处未采用3级比较，而是直接后序遍历其子节点，找到即刻返回，应该是考虑到这样效率更高。</span></span><br><span class="line">          </span><br><span class="line">       <span class="comment">// 从右节点递归遍历右子树，如果找到了匹配的则返回</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> q;</span><br><span class="line">          <span class="comment">// 右子树未找到，从左节点进入下一个循环</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = pl;</span><br><span class="line">        &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">      <span class="comment">// 未找到匹配元素，返回null。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>putTreeVal方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">				  <span class="comment">// searched记录是否遍历查找过该元素，最多查找一次</span></span><br><span class="line">            <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">            TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">              <span class="comment">// dir 记录方向</span></span><br><span class="line">                <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">              <span class="comment">// 1级排序方式</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">	              <span class="comment">// 采用1级排序方式找到对应元素</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">              <span class="comment">// 2级排序方式</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">// 2级排序方式</span></span><br><span class="line">                    <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                      <span class="comment">//最多执行一次</span></span><br><span class="line">                        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                        searched = <span class="keyword">true</span>;</span><br><span class="line">	                      <span class="comment">// 基于find方法找到了对应元素</span></span><br><span class="line">                        <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                            ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                            <span class="keyword">return</span> q;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="comment">// 3级排序方式</span></span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">              <span class="comment">// p循环到叶子节点，即树中无该元素且找到了插入节点x可能的父节点xp。</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// 构造待插入节点x</span></span><br><span class="line">	                  Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                  <span class="comment">// 在树结构中插入x（平衡前位置），此时插入的位置一定是空的。</span></span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                  <span class="comment">// 在链表结构中插入x</span></span><br><span class="line">                    xp.next = x;</span><br><span class="line">                    x.parent = x.prev = xp;</span><br><span class="line">                    <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                  <span class="comment">// 插入再平衡</span></span><br><span class="line">                    moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>对标2-3-4树看红黑树的插入平衡性调整逻辑：</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A5-%E5%AF%B9%E6%A0%872-3-4%E6%A0%91.jpg" alt="红黑树插入-对标2-3-4树"></p>
<p>balanceInsertion方法源码：</p>
<ul>
<li>并没有严格按照左倾或右倾红黑树来实现，效率优先，只有左右旋时左右倾才是必要的，所以将统一左右倾整合到了左右旋方法中）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 新插入节点初始状态：红色</span></span><br><span class="line">    x.red = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">      <span class="comment">// parent为null说明x为root，调整为黑色并返回，对应所有最终引起root节点变更的情况的最后一步。</span></span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 父节点为黑色，不需要调整（对应情况1及2.3）。</span></span><br><span class="line">      <span class="comment">// Y: 父节点为root，且为红色，这是为什么？这种情况又是怎么出现的？</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">      <span class="comment">// 父节点为左倾，则按左倾进行平衡。</span></span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">          <span class="comment">// 有叔叔节点且叔叔节点为红色，对应情况3.3和3.4（只是并没有将3.4调整为左倾，因为没有必要）</span></span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">          		<span class="comment">// 爷爷节点xpp及其左右节点变色：上红下黑。</span></span><br><span class="line">                xppr.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">              <span class="comment">// 爷爷节点xpp等价于2-3-4树合并到4节点分裂上提的那个节点，其插入上一层节点可能引起新的不平衡。</span></span><br><span class="line">              <span class="comment">// 爷爷节点xpp作为新的插入节点x，进入平衡性插入的下一次迭代。</span></span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 类似情况2</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 如果x为右倾，通过以xp左旋调整为左倾。类似情况2.2的第一次旋转</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                    root = rotateLeft(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">// 因为上一步可能发生左旋而引起xp的变化，所以此处做了非空判断。</span></span><br><span class="line">              <span class="comment">// 变色 + 第二次旋转，类似情况2.1 与 2.2第一次旋转后</span></span><br><span class="line">              <span class="comment">// 即xp、xpp的变色 + 涉及xp的以xpp开启的旋转</span></span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                        root = rotateRight(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 父节点为右倾，则按右倾进行平衡。</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 有叔叔节点，且叔叔节点为红色，对应情况3.1和3.2（只是并没有将3.2调整为左倾，因为没有必要）</span></span><br><span class="line">          <span class="comment">// 2-3-4树中分裂上提之后新插入节点都会与另一个节点组成一个3-节点，等价到红黑树中两者上下关系并不重要。</span></span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">          		<span class="comment">// 爷爷节点xpp及其左右节点变色：上红下黑。</span></span><br><span class="line">                xppl.red = <span class="keyword">false</span>;</span><br><span class="line">                xp.red = <span class="keyword">false</span>;</span><br><span class="line">                xpp.red = <span class="keyword">true</span>;</span><br><span class="line">              <span class="comment">// 爷爷节点xpp等价于2-3-4树合并到4节点时分裂上提的那个节点，其插入上一层节点可能引起新的不平衡。</span></span><br><span class="line">              <span class="comment">// 爷爷节点xpp作为新的插入节点x，进入平衡性插入的下一次迭代。</span></span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//对应情况2.2，第一次右旋调整后变为情况2.1</span></span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                    root = rotateRight(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">// 情况2.1</span></span><br><span class="line">              <span class="comment">// xp、xpp的变色 + 涉及xp的以xpp开启的左旋</span></span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="keyword">true</span>;</span><br><span class="line">                      <span class="comment">// 以xpp左旋</span></span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rotateLeft方法源码：（右旋同理）</p>
<p>注意：TreeNode实现中的左右旋将，实际可能做了两次旋转，如下面注释中的旋转1和2.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">/** 旋转1，父节点为右倾，需先统一调整为右倾，才能做下边的旋转2。</span></span><br><span class="line"><span class="comment">           *   5        5</span></span><br><span class="line"><span class="comment">           *    \        \</span></span><br><span class="line"><span class="comment">           *     7  =&gt;    6</span></span><br><span class="line"><span class="comment">           *    /          \</span></span><br><span class="line"><span class="comment">           *   6            7</span></span><br><span class="line"><span class="comment">           * */</span></span><br><span class="line">            <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)</span><br><span class="line">                rl.parent = p;</span><br><span class="line">          <span class="comment">// 若p为根节点，则此次旋转root变更，并将新的root变为黑色。</span></span><br><span class="line">            <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">                (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">          <span class="comment">/** 旋转2</span></span><br><span class="line"><span class="comment">           * 5            6</span></span><br><span class="line"><span class="comment">           *  \          / \</span></span><br><span class="line"><span class="comment">           *   6    =&gt;  5   7</span></span><br><span class="line"><span class="comment">           *    \</span></span><br><span class="line"><span class="comment">           *     7</span></span><br><span class="line"><span class="comment">           * */</span></span><br><span class="line">          <span class="comment">// 若p不是根节点，变更pp与p、r的关系</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">                pp.left = r;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pp.right = r;</span><br><span class="line">          <span class="comment">// 变更r与p的关系</span></span><br><span class="line">            r.left = p;</span><br><span class="line">            p.parent = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>moveRootToFront方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 确保给定的根是其冲突链表的头节点。Y: 注意理解链接结构字段与树结构字段是独立的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; tab != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        	<span class="comment">// 找到当前该冲突链表头节点。</span></span><br><span class="line">            <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; root.hash;</span><br><span class="line">            TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">          <span class="comment">// 如果当前该冲突头节点不是给定root节点，则将root移到该冲突链表头部。</span></span><br><span class="line">            <span class="keyword">if</span> (root != first) &#123;</span><br><span class="line">                Node&lt;K,V&gt; rn;</span><br><span class="line">                tab[index] = root;</span><br><span class="line">                TreeNode&lt;K,V&gt; rp = root.prev;</span><br><span class="line">                <span class="keyword">if</span> ((rn = root.next) != <span class="keyword">null</span>)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)rn).prev = rp;</span><br><span class="line">                <span class="keyword">if</span> (rp != <span class="keyword">null</span>)</span><br><span class="line">                    rp.next = rn;</span><br><span class="line">                <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                    first.prev = root;</span><br><span class="line">                root.next = first;</span><br><span class="line">                root.prev = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">// 递归不变检查。</span></span><br><span class="line">            <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>checkInvariants方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归不变检查。 t非空。该检查可保证树结构与链表结构是统一的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">checkInvariants</span><span class="params">(TreeNode&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right,</span><br><span class="line">            tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next;</span><br><span class="line">     <span class="comment">// 检查前驱节点：若存在前驱节点，前驱节点的后继必须为t。</span></span><br><span class="line">        <span class="keyword">if</span> (tb != <span class="keyword">null</span> &amp;&amp; tb.next != t)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 检查后继节点：若存在后继节点，后继节点的前驱必须为t。</span></span><br><span class="line">        <span class="keyword">if</span> (tn != <span class="keyword">null</span> &amp;&amp; tn.prev != t)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 检查父节点：若存在父节点，父节点的左右子节点中必有一个是t。</span></span><br><span class="line">        <span class="keyword">if</span> (tp != <span class="keyword">null</span> &amp;&amp; t != tp.left &amp;&amp; t != tp.right)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 检查左节点：若存在左节点，其父节点必须为t且其hash必须小于等于t的hash。1级排序，左小</span></span><br><span class="line">        <span class="keyword">if</span> (tl != <span class="keyword">null</span> &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 检查右节点：若存在右节点，其父节点必须为t且其hash必须大于等于t的hash。1级排序，右大</span></span><br><span class="line">        <span class="keyword">if</span> (tr != <span class="keyword">null</span> &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 检查t的颜色：若为红色，则其左右节点不能都为红色。</span></span><br><span class="line">      <span class="comment">// Y: 若一个不存在，另一个子节点为红色呢？也不符合红黑树定义啊。</span></span><br><span class="line">      <span class="comment">// 对应查看balanceInsertion方法，存在红色root上插入节点的可能，不明原因？</span></span><br><span class="line">        <span class="keyword">if</span> (t.red &amp;&amp; tl != <span class="keyword">null</span> &amp;&amp; tl.red &amp;&amp; tr != <span class="keyword">null</span> &amp;&amp; tr.red)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 递归检查左子树</span></span><br><span class="line">        <span class="keyword">if</span> (tl != <span class="keyword">null</span> &amp;&amp; !checkInvariants(tl))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">// 递归检查右子树</span></span><br><span class="line">        <span class="keyword">if</span> (tr != <span class="keyword">null</span> &amp;&amp; !checkInvariants(tr))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>removeTreeNode方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除给定节点，该节点必须在此调用之前存在。 这比典型的红黑删除代码更混乱，因为我们无法将内部节点的内容与叶后继交换，该				 * 后继由在遍历期间可独立访问的“下一个”指针固定。 因此，我们交换树链接。 如果当前树的节点似乎太少，则将 bin 转换回普通 				 * bin。 （测试会在 2 到 6 个节点之间触发，具体取决于树结构）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">  <span class="comment">// 空映射，返回</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">    TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">  <span class="comment">// next为待删除节点的后继节点，prev为待删除节点的前驱节点。succ -&gt; succeed 继......之后</span></span><br><span class="line">    TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 首先链表结构上删除该节点。前驱、后继直接相连</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 1. 前驱为空，说明为root</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        tab[index] = first = succ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = succ;</span><br><span class="line">    <span class="keyword">if</span> (succ != <span class="keyword">null</span>)</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">  <span class="comment">// first为空，说明链表为空，唯一的一个节点已被删除。</span></span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2. 树结构上删除该节点</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// root存在父节点说明此时root不是真实的根节点，需要更新为当前的根节点。（Y: 是怎么产生的？）</span></span><br><span class="line">    <span class="keyword">if</span> (root.parent != <span class="keyword">null</span>)</span><br><span class="line">        root = root.root();</span><br><span class="line">  <span class="comment">// 冲突元素太少，从红黑树降级为单链表HashMap.Node。</span></span><br><span class="line">  <span class="comment">// movable 可移动的，若为false则删除元素时不移动其它节点。</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span></span><br><span class="line">        || (movable</span><br><span class="line">            &amp;&amp; (root.right == <span class="keyword">null</span></span><br><span class="line">                || (rl = root.left) == <span class="keyword">null</span></span><br><span class="line">                || rl.left == <span class="keyword">null</span>))) &#123;</span><br><span class="line">        tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 直接删除节点p，转换成找到其替代节点replacement，将replacement与p节点互换位置，再删除p，使树结构变动最小。</span></span><br><span class="line">  </span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">  <span class="comment">// 情况1：p有两个子节点，找到它右子树中的最小值，为replacement。</span></span><br><span class="line">    <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">      <span class="comment">// 找到p的替代者，即其右子树中最小值s</span></span><br><span class="line">        <span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">// find successor</span></span><br><span class="line">            s = sl;</span><br><span class="line">      <span class="comment">// 交换s与其替代者的颜色</span></span><br><span class="line">        <span class="keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="comment">// swap colors</span></span><br><span class="line">        TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">      <span class="comment">// 若找到的替代者为p的子节点即右节点，把p挂到s的右节点（Y：为什么是右节点？因为左节点要与p的左节点建立链接）。</span></span><br><span class="line">        <span class="keyword">if</span> (s == pr) &#123; <span class="comment">// p was s&#x27;s direct parent</span></span><br><span class="line">            p.parent = s;</span><br><span class="line">            s.right = p;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 否则，把p与sp建立链接，s与pr建立链接</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">            <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                    sp.left = p;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sp.right = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>)</span><br><span class="line">                pr.parent = s;</span><br><span class="line">        &#125;</span><br><span class="line">        p.left = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">// s的右节点作为p的右节点与p建立双向链接。</span></span><br><span class="line">        <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)</span><br><span class="line">            sr.parent = p;</span><br><span class="line">      <span class="comment">// p的原左节点作为s的左节点，两者建立双向链接。</span></span><br><span class="line">        <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)</span><br><span class="line">            pl.parent = s;</span><br><span class="line">      <span class="comment">// s与p的父节点pp建立双向链接。且若p原为root，则更新s为root。</span></span><br><span class="line">        <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>)</span><br><span class="line">            root = s;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = s;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = s;</span><br><span class="line">      <span class="comment">// sr存在时，等同于情况2，再次用sr替代p</span></span><br><span class="line">        <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">            replacement = sr;</span><br><span class="line">      <span class="comment">// sr不存在，等同于情况3</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            replacement = p;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 情况2: p有一个子节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">        replacement = pl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">        replacement = pr;</span><br><span class="line">  <span class="comment">// 情况3: p为叶子节点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        replacement = p;</span><br><span class="line">  <span class="comment">// replacement非p时，还需要一次位置互换，将replacement与pp建立双向链接，删除p与树的关系。</span></span><br><span class="line">    <span class="keyword">if</span> (replacement != p) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (pp == <span class="keyword">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = replacement;</span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 若替换后p最终为红色，则删除不影响树结构，不调整，否则进行删除的平衡性调整。</span></span><br><span class="line">  <span class="comment">// 到此处，replacement或者为p本身或者已代替了p的位置，且replacement一定是叶子节点。</span></span><br><span class="line">    TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// replacement即为p时，清除p与树之间可能存在的任何引用。</span></span><br><span class="line">  <span class="comment">// 如p的原父亲节点若仍保留有对p的引用，则删除它，删除p对pp的引用。</span></span><br><span class="line">    <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">// detach</span></span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        p.parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                pp.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                pp.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (movable)</span><br><span class="line">        moveRootToFront(tab, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对标2-3-4树看红黑树删除平衡性调整逻辑：</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4-%E5%AF%B9%E8%A1%A82-3-4%E6%A0%91.jpg" alt="红黑树删除-对表2-3-4树"></p>
<p>balanceDeletion方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该方法实际所做的事情与删除无直接关系，实际是x子树黑高矮一层，向上借一个黑色节点，达到黑色平衡。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceDeletion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 进入这个方法，说明被替代的节点p之前是黑色的，因为红色的不需要调整</span></span><br><span class="line"><span class="comment">    * 进入该方法的时候，替代节点可能与删除节点相等：x == replacement == p</span></span><br><span class="line"><span class="comment">    *                  替代节点可能与删除节点不相等：x == replacement ！= p</span></span><br><span class="line"><span class="comment">    * 此处可不在考虑删除，而将x视为借东西的节点，在向父亲xp借，xp帮忙从兄弟节点乃至上层去借。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">     <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) &#123;</span><br><span class="line">       <span class="comment">// x为空或root时</span></span><br><span class="line">         <span class="keyword">if</span> (x == <span class="keyword">null</span> || x == root)</span><br><span class="line">             <span class="keyword">return</span> root;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">             x.red = <span class="keyword">false</span>;</span><br><span class="line">             <span class="keyword">return</span> x;</span><br><span class="line">         &#125;</span><br><span class="line">       <span class="comment">// 相当于自己有，不用借，置为黑，可能自己开始就有，也可能是向上迭代中指向了富裕的祖先节点。</span></span><br><span class="line">       <span class="comment">// x初始状态为红色的情况的终点；再有就是情况1、情况2.1、情况4.1可能的终点</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (x.red) &#123;</span><br><span class="line">             x.red = <span class="keyword">false</span>;</span><br><span class="line">             <span class="keyword">return</span> root;</span><br><span class="line">         &#125;</span><br><span class="line">       <span class="comment">// 若x在其父节点的左侧</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> ((xpl = xp.left) == x) &#123;</span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 情况3：x有兄弟节点xpr，且为红色，则xpr必有两个黑色子节点（对比2-3-4树的3-节点可知）。</span></span><br><span class="line"><span class="comment">            *   1. 将兄弟节点设为黑色；</span></span><br><span class="line"><span class="comment">            *   2. 将父节点设为红色；</span></span><br><span class="line"><span class="comment">            *   3. 以父节点进行左旋，更新xp、xpr，如此借到了原xprl为新的xpr，转化为情况4。</span></span><br><span class="line"><span class="comment">            **/</span> </span><br><span class="line">             <span class="keyword">if</span> ((xpr = xp.right) != <span class="keyword">null</span> &amp;&amp; xpr.red) &#123;</span><br><span class="line">                 xpr.red = <span class="keyword">false</span>;</span><br><span class="line">                 xp.red = <span class="keyword">true</span>;</span><br><span class="line">                 root = rotateLeft(root, xp);</span><br><span class="line">                 xpr = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.right;</span><br><span class="line">             &#125;</span><br><span class="line">           <span class="comment">// 情况1 x无兄弟节点，则x指向父节点，向上调整</span></span><br><span class="line">             <span class="keyword">if</span> (xpr == <span class="keyword">null</span>)</span><br><span class="line">                 x = xp;</span><br><span class="line">           <span class="comment">// x有兄弟节点xpr，非情况1和情况3，则只能是情况2和情况4</span></span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                 TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</span><br><span class="line">               <span class="comment">// 情况2.1和情况4.1 无子节点</span></span><br><span class="line">               <span class="comment">// x的兄弟节点xpr没有子节点，可将xpr设为红色，xp局部平衡但高度整体少1，x指向xp，向上调整。</span></span><br><span class="line">                 <span class="keyword">if</span> ((sr == <span class="keyword">null</span> || !sr.red) &amp;&amp;</span><br><span class="line">                     (sl == <span class="keyword">null</span> || !sl.red)) &#123;</span><br><span class="line">                     xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                     x = xp;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="keyword">if</span> (sr == <span class="keyword">null</span> || !sr.red) &#123;</span><br><span class="line">                       <span class="comment">// 情况2.2和情况4.2 xpr只左节点sl</span></span><br><span class="line">                         <span class="keyword">if</span> (sl != <span class="keyword">null</span>)</span><br><span class="line">                             sl.red = <span class="keyword">false</span>;</span><br><span class="line">                         xpr.red = <span class="keyword">true</span>;</span><br><span class="line">                       <span class="comment">// 以xpr右旋，变为右倾，目的是保证有右节点。更新xp与xpr，转化为情况2.3和4.3</span></span><br><span class="line">                       <span class="comment">// 旋转操作可能会引起root变化，若变化则更新root。</span></span><br><span class="line">                         root = rotateRight(root, xpr);</span><br><span class="line">                         xpr = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                             <span class="keyword">null</span> : xp.right;</span><br><span class="line">                     &#125;</span><br><span class="line">                    <span class="comment">// 情况2.3 和情况4.3 xpr有右节点</span></span><br><span class="line">                     <span class="keyword">if</span> (xpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">// 让兄弟节点xpr变为父节点的颜色，因为在让它代替父节点的位置时不改变树的平衡状态</span></span><br><span class="line">                         xpr.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                         <span class="keyword">if</span> ((sr = xpr.right) != <span class="keyword">null</span>)</span><br><span class="line">                           <span class="comment">// 将xpr的右节点，设为黑色，保证xp右子树的黑色树高不变。</span></span><br><span class="line">                             sr.red = <span class="keyword">false</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">//将xp设为黑色，以xp左旋，补充到新xp的左子树，树高增加一层。整体平衡。</span></span><br><span class="line">                         xp.red = <span class="keyword">false</span>;</span><br><span class="line">                         root = rotateLeft(root, xp);</span><br><span class="line">                     &#125;</span><br><span class="line">                   <span class="comment">// 令x为root，进入下一次循环时终止循环。</span></span><br><span class="line">                     x = root;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123; <span class="comment">// symmetric 对称</span></span><br><span class="line">             <span class="keyword">if</span> (xpl != <span class="keyword">null</span> &amp;&amp; xpl.red) &#123;</span><br><span class="line">                 xpl.red = <span class="keyword">false</span>;</span><br><span class="line">                 xp.red = <span class="keyword">true</span>;</span><br><span class="line">                 root = rotateRight(root, xp);</span><br><span class="line">                 xpl = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.left;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span> (xpl == <span class="keyword">null</span>)</span><br><span class="line">                 x = xp;</span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                 TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;</span><br><span class="line">                 <span class="keyword">if</span> ((sl == <span class="keyword">null</span> || !sl.red) &amp;&amp;</span><br><span class="line">                     (sr == <span class="keyword">null</span> || !sr.red)) &#123;</span><br><span class="line">                     xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                     x = xp;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="keyword">if</span> (sl == <span class="keyword">null</span> || !sl.red) &#123;</span><br><span class="line">                         <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                             sr.red = <span class="keyword">false</span>;</span><br><span class="line">                         xpl.red = <span class="keyword">true</span>;</span><br><span class="line">                         root = rotateLeft(root, xpl);</span><br><span class="line">                         xpl = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                             <span class="keyword">null</span> : xp.left;</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">if</span> (xpl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         xpl.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                         <span class="keyword">if</span> ((sl = xpl.left) != <span class="keyword">null</span>)</span><br><span class="line">                             sl.red = <span class="keyword">false</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         xp.red = <span class="keyword">false</span>;</span><br><span class="line">                         root = rotateRight(root, xp);</span><br><span class="line">                     &#125;</span><br><span class="line">                     x = root;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<hr>
<blockquote>
<p><strong>感谢参考的文章及作者：</strong></p>
<ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41725090/article/details/82147576">【源码分析】hashmap中的红黑树是如何进行排序的2</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42340670/article/details/80753826">JDK8：HashMap源码解析：TreeNode类的find方法</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/eniac12/p/5558848.html">Sedgewick的红黑树</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/c159cc/article/details/107227842">java的HashMap中TreeNode节点的删除复杂性分析</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40722604/article/details/107792636">10、JDK1.8HashMap源码分析系列文章（balanceDeletion）</a></li>
</ol>
<p>推荐一个期间使用的：<a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">红黑树操作可视化网站</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.coder.love/2021/08/11/start/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="青马流光">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="青马流光的博客">
      <meta itemprop="description" content="学习笔记">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 青马流光的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/11/start/" class="post-title-link" itemprop="url">Start</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-11 14:26:25" itemprop="dateCreated datePublished" datetime="2021-08-11T14:26:25+08:00">2021-08-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-10-12 14:53:14" itemprop="dateModified" datetime="2021-10-12T14:53:14+08:00">2021-10-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <center> <h3>Code the love to the world. </h3> </center>

<ul>
<li>Knowledge is not confused.  知识不迷茫</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.coder.love/2021/08/11/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="青马流光">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="青马流光的博客">
      <meta itemprop="description" content="学习笔记">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 青马流光的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/08/11/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-11 14:25:25" itemprop="dateCreated datePublished" datetime="2021-08-11T14:25:25+08:00">2021-08-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-21 16:59:44" itemprop="dateModified" datetime="2022-03-21T16:59:44+08:00">2022-03-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-Hexo-Quick-Start"><a href="#1-Hexo-Quick-Start" class="headerlink" title="1. Hexo Quick Start"></a>1. Hexo Quick Start</h2><p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="1-图床"><a href="#1-图床" class="headerlink" title="1. 图床"></a>1. 图床</h2><ul>
<li><p>Gitee + PicGo</p>
<blockquote>
<ul>
<li><p>Gitee中访问大于1M的图片，需要登录。对于较大的，如git，需要压缩。</p>
<blockquote>
<p>imagemagick</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew install imagemagick</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -fuzz 代表压缩率</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> convert pattern_design.gif -fuzz 15% -layers Optimize new_pattern_design.gif</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="2-npm"><a href="#2-npm" class="headerlink" title="2. npm"></a>2. npm</h2><ul>
<li>npm 使用 <a target="_blank" rel="noopener" href="https://npmmirror.com/">npmmirror 中国镜像站</a>，使用cnpm命令替代npm命令。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">青马流光</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
