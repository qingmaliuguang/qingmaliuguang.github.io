<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="description" content="SpringBoot-AOP"/>




  <meta name="keywords" content="SpringBoot," />





  <link rel="alternate" href="/default" title="青马流光的博客" >




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1" />



<link rel="canonical" href="http://blog.coder.love/2022/03/21/SpringBoot-AOP/"/>


<meta name="description" content="——————————————————————关于Spring AOP—————————————————————— 1. @EnableAspectJAutoProxy如下来自其注释。  支持处理用AspectJ的@Aspect注解标记的组件，类似于在Spring的  aop:aspectj-autoproxy XML元素中找到的功能。在@Configuration类上使用如下: 123456789">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringBoot-AOP">
<meta property="og:url" content="http://blog.coder.love/2022/03/21/SpringBoot-AOP/index.html">
<meta property="og:site_name" content="青马流光的博客">
<meta property="og:description" content="——————————————————————关于Spring AOP—————————————————————— 1. @EnableAspectJAutoProxy如下来自其注释。  支持处理用AspectJ的@Aspect注解标记的组件，类似于在Spring的  aop:aspectj-autoproxy XML元素中找到的功能。在@Configuration类上使用如下: 123456789">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/qmlg/image-bed/raw/master/images/image-20220315162419708.png">
<meta property="article:published_time" content="2022-03-21T07:06:25.000Z">
<meta property="article:modified_time" content="2022-03-21T09:07:11.576Z">
<meta property="article:author" content="青马流光">
<meta property="article:tag" content="SpringBoot">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/qmlg/image-bed/raw/master/images/image-20220315162419708.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1" />
<link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet'>





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  <script id="baidu_analytics">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?65a3f3228e88e62009896032ddcfdf2b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



    <title> SpringBoot-AOP - 青马流光的博客 </title>
  <meta name="generator" content="Hexo 5.4.0"></head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">青马流光的博客</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          SpringBoot-AOP
        
      </h1>

      <time class="post-time">
          3月 21 2022
      </time>
    </header>



    
            <div class="post-content">
            <p><font color='00FF00'>——————————————————————关于Spring AOP——————————————————————</font></p>
<h1 id="1-EnableAspectJAutoProxy"><a href="#1-EnableAspectJAutoProxy" class="headerlink" title="1. @EnableAspectJAutoProxy"></a>1. @EnableAspectJAutoProxy</h1><p>如下来自其注释。</p>
<blockquote>
<p>支持处理用AspectJ的@Aspect注解标记的组件，类似于在Spring的  aop:aspectj-autoproxy XML元素中找到的功能。<br>在@Configuration类上使用如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line">   <span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">       <span class="meta">@Bean</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> FooService <span class="title">fooService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> FooService();</span><br><span class="line">       &#125;</span><br><span class="line">  </span><br><span class="line">       <span class="meta">@Bean</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> MyAspect <span class="title">myAspect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> MyAspect();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>FooService是一个典型的POJO组件，而MyAspect是一个@Aspect风格的方面:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooService</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">       <span class="comment">// various methods</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Aspect</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">       <span class="meta">@Before(&quot;execution(* FooService+.*(..))&quot;)</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">advice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">// advise FooService methods as appropriate</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在上面的场景中，@EnableAspectJAutoProxy确保了MyAspect将被正确处理，并且FooService将在它提供的通知中被代理混合。<br>用户可以使用proxyTargetClass()属性来控制为FooService创建的代理类型。下面启用cglib风格的“子类”代理，而不是默认的基于接口的JDK代理方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line">   <span class="meta">@EnableAspectJAutoProxy(proxyTargetClass=true)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>请注意@Aspect bean可以像其他任何bean一样被组件扫描。简单地用@Aspect和@Component标记切面:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.foo;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Component</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooService</span> </span>&#123; ... &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Aspect</span></span><br><span class="line">   <span class="meta">@Component</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>注意；@EnableAspectJAutoProxy只适用于它的本地应用程序上下文，允许在不同级别上选择性地代理bean。 请在每个单独的上下文中重新声明@EnableAspectJAutoProxy，例如公共的根web应用程序上下文和任何单独的DispatcherServlet应用程序上下文，如果你需要在多个级别应用它的行为。<br>这个特性需要aspectjweaver出现在类路径上。虽然这个依赖通常对于spring-aop是可选的，但是对于@EnableAspectJAutoProxy及其底层工具来说是必需的。</p>
</blockquote>
<p><strong>@EnableAspectJAutoProxy通过添加@Import注解引入了AspectJAutoProxyRegistrar.class。</strong></p>
<h1 id="2-AspectJAutoProxyRegistrar"><a href="#2-AspectJAutoProxyRegistrar" class="headerlink" title="2. AspectJAutoProxyRegistrar"></a>2. AspectJAutoProxyRegistrar</h1><ul>
<li>根据给定的@EnableAspectJAutoProxy注解，在当前的BeanDefinitionRegistry中注册一个<strong>AnnotationAwareAspectJAutoProxyCreator</strong>。</li>
<li>基于导入的@Configuration类上的@EnableAspectJAutoProxy.proxyTargetClass()属性的值，注册、升级和配置AspectJ自动代理创建器</li>
<li>AspectJAutoProxyRegistrar实现自ImportBeanDefinitionRegistrar接口。</li>
</ul>
<blockquote>
<p><strong>ImportBeanDefinitionRegistrar</strong></p>
<p>接口，由在处理@Configuration类时注册额外bean定义的类型实现。当在bean定义级别(与@Bean方法/实例级别相反)操作时，需要或必须使用。</p>
<p>与@Configuration和ImportSelector一起，这种类型的类可以提供给@Import注解(也可以从ImportSelector返回)。</p>
<p><font color='FF0000'>是在什么时候被调用的？</font></p>
<p>ImportBeanDefinitionRegistrar可以实现以下任何一个Aware接口，它们各自的方法将在registerBeanDefinitions之前被调用:</p>
<ul>
<li>EnvironmentAware</li>
<li>BeanFactoryAware</li>
<li>BeanClassLoaderAware</li>
<li>ResourceLoaderAware</li>
</ul>
<p>或者，该类可以提供唯一的构造函数，其中包含一个或多个受支持的形参类型:</p>
<ul>
<li>Environment</li>
<li>BeanFactory</li>
<li>ClassLoader</li>
<li>ResourceLoader</li>
</ul>
<p>有关使用示例，请参阅实现和相关的单元测试</p>
</blockquote>
<h1 id="3-AnnotationAwareAspectJAutoProxyCreator"><a href="#3-AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="3. AnnotationAwareAspectJAutoProxyCreator"></a>3. AnnotationAwareAspectJAutoProxyCreator</h1><blockquote>
<p>处理当前应用上下文中所有AspectJ注解切面的<strong>AspectJAwareAdvisorAutoProxyCreator</strong>子类，以及Spring Advisor。</p>
<p>任何带有AspectJ注解的类都将被自动识别，如果Spring AOP的基于代理的模型能够应用它们，那么它们的通知将被应用。这包括了方法执行连接点。</p>
<p>如果使用了aop:include元素，只有名称与包含模式匹配的@AspectJ bean才会被认为定义了用于Spring自动代理的方面。</p>
<p>Spring Advisors的处理遵循在org.springframework.aop.framework.autoproxy.<strong>AbstractAdvisorAutoProxyCreator</strong>中建立的规则。</p>
</blockquote>
<ul>
<li><p>它有两个AspectJAdvisorFactory和BeanFactoryAspectJAdvisorsBuilder类型的成员：aspectJAdvisorFactory和aspectJAdvisorsBuilder。aspectJAdvisorFactory为ReflectiveAspectJAdvisorFactory的实例，并用aspectJAdvisorFactory构造了aspectJAdvisorsBuilder。</p>
</li>
<li><p>findCandidateAdvisors方法</p>
<blockquote>
<p>-&gt; 调用了aspectJAdvisorsBuilder.buildAspectJAdvisors()</p>
<p>-&gt; 调用了aspectJAdvisorFactory.getAdvisors(…)   【ReflectiveAspectJAdvisorFactory::getAdvisors(…)】</p>
</blockquote>
</li>
</ul>
<h1 id="4-AbstractAdvisorAutoProxyCreator"><a href="#4-AbstractAdvisorAutoProxyCreator" class="headerlink" title="4. AbstractAdvisorAutoProxyCreator"></a>4. AbstractAdvisorAutoProxyCreator</h1><blockquote>
<p>通用的自动代理生成器，根据检测到的每个bean的advisor为特定bean构建AOP代理。</p>
<p><strong>子类可以重写findCandidateAdvisors()方法来返回应用于任何对象的自定义advisor列表。 子类还可以重写继承的shouldSkip方法，以排除某些对象的自动代理。</strong></p>
<p>需要排序的顾问或建议应该用@Order注解，或者实现org.springframework.core.Ordered接口。 这个类使用AnnotationAwareOrderComparator对顾问进行排序。 没有使用@Order注释或没有实现Ordered接口的advisor将被认为是无序的;它们将以未定义的顺序出现在advisor链的末尾。</p>
</blockquote>
<ul>
<li>继承自<strong>AbstractAutoProxyCreator</strong>。</li>
</ul>
<h1 id="5-AbstractAutoProxyCreator"><a href="#5-AbstractAutoProxyCreator" class="headerlink" title="5. AbstractAutoProxyCreator"></a>5. AbstractAutoProxyCreator</h1><blockquote>
<p>org.springframework.beans.factory.config.<strong>BeanPostProcessor</strong>的实现， 它用AOP代理包装每个合格的bean，在调用bean本身之前委托给指定的拦截器。</p>
<ul>
<li><p>BeanPostProcessor</p>
<blockquote>
<ul>
<li><p>工厂钩子，允许自定义修改新bean实例——例如，检查标记接口或用代理包装bean。</p>
</li>
<li><p>通常，通过标记接口或类似的方式填充bean的后处理器将实现postProcessBeforeInitialization， 而用代理包装bean的后处理器通常将实现postProcessAfterInitialization。</p>
</li>
<li><p>注册</p>
<p>ApplicationContext可以在它的bean定义中自动检测BeanPostProcessor bean，并将这些后处理器应用到随后创建的任何bean。 普通的BeanFactory允许以编程方式注册后处理程序，将它们应用于通过bean工厂创建的所有bean。</p>
</li>
<li><p>排序</p>
<p>在ApplicationContext中被自动检测到的BeanPostProcessor bean将根据 org.springframework.core.prioritordered和org.springframework.core.Ordered语义进行排序。 相反，以编程方式注册到BeanFactory的BeanPostProcessor bean将按照注册的顺序应用; 对于以编程方式注册的后处理器，任何通过实现prioritorderordered或Ordered接口表示的排序语义都将被忽略。 而且，对于BeanPostProcessor bean， @Order注解没有被考虑在内</p>
</li>
</ul>
</blockquote>
</li>
<li><p>postProcessBeforeInstantiation</p>
<p>-&gt; createProxy</p>
<blockquote>
<p>为给定的bean创建AOP代理。</p>
</blockquote>
<p>-&gt; ProxyFactory::getProxy</p>
<blockquote>
<p>根据该工厂中的设置创建一个新的代理。</p>
</blockquote>
<p>-&gt; ProxyCreatorSupport::createAopProxy</p>
<blockquote>
<ul>
<li><p>ProxyCreatorSupport</p>
<blockquote>
<p>代理工厂的基类。提供对可配置的AopProxyFactory的方便访问</p>
<ul>
<li><p>AopProxyFactory</p>
<blockquote>
<p>接口，由工厂实现，这些工厂能够基于AdvisedSupport配置对象创建AOP代理。</p>
<p>代理人须遵守以下合约:</p>
<ul>
<li>它们应该实现配置指出应该代理的所有接口。</li>
<li>它们应该实现被建议的接口。</li>
<li>它们应该实现equals方法来比较代理接口、通知和目标。</li>
<li>如果所有的advisor和target都是可序列化的，它们应该是可序列化的。</li>
<li>如果advisor和target是线程安全的，那么它们应该是线程安全的。</li>
</ul>
<p>代理可能允许也可能不允许更改通知。如果它们不允许更改通知(例如，因为配置被冻结)，代理应该在尝试更改通知时抛出AopConfigException。</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<p>-&gt; DefaultAopProxyFactory::createAopProxy</p>
<blockquote>
<ul>
<li><p>DefaultAopProxyFactory</p>
<blockquote>
<p>默认的AopProxyFactory实现，创建CGLIB代理或JDK动态代理。</p>
<p><font color='00FF00'>创建一个CGLIB代理，如果一个给定的AdvisedSupport实例如下所示:</font></p>
<ul>
<li>设置了 optimize 标志</li>
<li>设置了 proxyTargetClass 标志</li>
<li>没有指定代理接口</li>
</ul>
<p>通常，指定proxyTargetClass来强制使用CGLIB代理，或者指定一个或多个接口来使用JDK动态代理。</p>
</blockquote>
</li>
</ul>
</blockquote>
<p>-&gt; AopProxy::getProxy</p>
<blockquote>
<ul>
<li><p>AopProxy</p>
<blockquote>
<p>用于已配置的AOP代理的委托接口，允许创建实际的代理对象。</p>
<p>JDK动态代理和CGLIB代理都有现成的实现，由DefaultAopProxyFactory应用。</p>
<p><img src="https://gitee.com/qmlg/image-bed/raw/master/images/image-20220315162419708.png" alt="image-20220315162419708"></p>
</blockquote>
</li>
<li><p>JdkDynamicAopProxy::getProxy</p>
<blockquote>
<p><font color='FF0000'>JdkDynamicAopProxy的invoke方法是在哪里调用的？</font></p>
</blockquote>
<p>-&gt; Proxy.newProxyInstance  【jdk java.lang.reflect】</p>
<blockquote>
<p>返回指定接口的代理实例，该接口将方法调用分派给指定的调用处理程序。</p>
<p>如果违反了以下任何一个限制，将会抛出IllegalArgumentException:</p>
<p>……</p>
<p>请注意，指定的代理接口的顺序是重要的:对具有相同接口组合但顺序不同的代理类的两个请求将导致两个不同的代理类。</p>
</blockquote>
<p>-&gt; Constructor::newInstance</p>
</li>
<li><p>ObjenesisCglibAopProxy::getProxy</p>
<blockquote>
<p>基于对象的CglibAopProxy扩展，在不调用类构造函数的情况下创建代理实例。在Spring 4中默认使用。</p>
<ul>
<li><p>CglibAopProxy</p>
<blockquote>
<p>面向Spring AOP框架的基于cglib的AopProxy实现。</p>
<p>这种类型的对象应该通过代理工厂获得，由AdvisedSupport对象配置。这个类是Spring AOP框架的内部类，客户机代码不需要直接使用它。</p>
<p>如果需要，DefaultAopProxyFactory将自动创建基于cglib的代理，例如在代理一个目标类的情况下(有关详细信息，请参阅代理javadoc)。</p>
<p>如果底层(目标)类是线程安全的，则使用该类创建的代理是线程安全的。</p>
</blockquote>
</li>
</ul>
</blockquote>
<p>-&gt; SpringObjenesis::newInstance  ||  Constructor::newInstance</p>
<blockquote>
<ul>
<li><p>SpringObjenesis</p>
<blockquote>
<p>特定于Spring的ObjenesisStd / ObjenesisBase的变体，提供基于Class键而不是类名的缓存，并允许选择性地使用缓存。</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p>postProcessAfterInitialization</p>
<blockquote>
<p>如果bean被子类标识为代理，则使用配置的拦截器创建代理</p>
</blockquote>
<p>-&gt; wrapIfNecessary</p>
<p>-&gt; createProxy</p>
</li>
</ul>
<p>这个类区分“公共”拦截器:为它创建的所有代理共享，和“特定”拦截器:每个bean实例唯一。 不需要任何通用的拦截器。如果有，则使用interceptorNames属性设置它们。</p>
</blockquote>
<p><font color='00FF00'>——————————————那么AnnotationAwareAspectJAutoProxyCreator是什么时候怎么起作用的呢？——————————————</font></p>
<h1 id="7-AbstractAutowireCapableBeanFactory"><a href="#7-AbstractAutowireCapableBeanFactory" class="headerlink" title="7. AbstractAutowireCapableBeanFactory"></a>7. AbstractAutowireCapableBeanFactory</h1><ul>
<li>initializeBean -&gt; <ul>
<li>applyBeanPostProcessorsBeforeInitialization</li>
<li>applyBeanPostProcessorsAfterInitialization</li>
</ul>
</li>
</ul>
<h1 id="8-DefaultSingletonBeanRegistry"><a href="#8-DefaultSingletonBeanRegistry" class="headerlink" title="8. DefaultSingletonBeanRegistry"></a>8. DefaultSingletonBeanRegistry</h1><p>getSingleton</p>
<blockquote>
<p>处理循环引用。</p>
</blockquote>
<h1 id="PropertyAccessorFactory（spring-beans）"><a href="#PropertyAccessorFactory（spring-beans）" class="headerlink" title="PropertyAccessorFactory（spring-beans）"></a>PropertyAccessorFactory（spring-beans）</h1><ul>
<li>获取PropertyAccessor实例的简单工厂facade，特别是对于BeanWrapper实例。隐藏实际的目标实现类及其扩展的公共签名。</li>
</ul>
<h1 id="HandlerInterceptor（spring-webmvc）"><a href="#HandlerInterceptor（spring-webmvc）" class="headerlink" title="HandlerInterceptor（spring-webmvc）"></a>HandlerInterceptor（spring-webmvc）</h1><blockquote>
<p>HandlerInterceptor基本上类似于Servlet Filter，但与后者相比，它只允许自定义预处理（可以选择禁止处理程序本身的执行），以及自定义后处理。过滤器功能更强大，例如，它们允许交换传递给链的请求和响应对象。请注意，过滤器是在web .xml中配置的，它是应用程序上下文中的HandlerInterceptor。</p>
</blockquote>
<h1 id="WebRequestInterceptor"><a href="#WebRequestInterceptor" class="headerlink" title="WebRequestInterceptor"></a>WebRequestInterceptor</h1><blockquote>
<p>接口，一般的web请求拦截。允许通过构建WebRequest抽象来应用于Servlet请求。<br>该接口采用<strong>mvc风格的请求处理:执行一个处理程序，公开一组模型对象，然后根据该模型呈现视图。</strong>另外，处理程序也可以完全处理请求，而不呈现视图。</p>
</blockquote>
<h1 id="RequestMappingHandlerMapping"><a href="#RequestMappingHandlerMapping" class="headerlink" title="RequestMappingHandlerMapping"></a>RequestMappingHandlerMapping</h1><blockquote>
<p>从@Controller类的类型和方法级的@RequestMapping注释中创建RequestMappingInfo实例。<br>弃用注意:<br>在5.2.4中，useSuffixPatternMatch和useRegisteredSuffixPatternMatch被弃用，以阻止使用路径扩展来进行请求映射和内容协商(与ContentNegotiationManagerFactoryBean中类似的弃用)。有关更多内容，请阅读第24719期。</p>
</blockquote>
<h1 id="BeanNameUrlHandlerMapping"><a href="#BeanNameUrlHandlerMapping" class="headerlink" title="BeanNameUrlHandlerMapping"></a>BeanNameUrlHandlerMapping</h1><blockquote>
<p>实现了org.springframe.web.servlet.HandlerMapping接口，该接口将url映射到名称以斜杠(“/”)开头的bean，类似于Struts将url映射到动作名称的方式。<br>这是org.springframework.web.servlet使用的默认实现。DispatcherServlet，以及org.springframework.web.servlet.mvc.method.annotation .RequestMappingHandlerMapping。另外，SimpleUrlHandlerMapping允许以声明的方式自定义处理程序映射。<br>映射是从URL到bean名。因此，一个传入的URL“/foo”将映射到一个名为“/foo”的处理程序，或者映射到“/foo /foo2”，如果多个映射到一个单独的处理程序。<br>支持直接匹配(给定”/test” -&gt;注册”/test”)和”<em>“匹配(给定”/test” -&gt;注册”/t</em>“)。注意，默认情况下，如果适用，映射到当前servlet映射中;详见”alwaysUseFullPath”属性。关于模式选项的详细信息，请参见org.springframework.util.AntPathMatcher javadoc。</p>
</blockquote>
<h1 id="ProxyFactory"><a href="#ProxyFactory" class="headerlink" title="ProxyFactory"></a>ProxyFactory</h1><blockquote>
<p>用于编程使用的AOP代理的工厂，而不是通过bean工厂中的声明性设置。这个类提供了一种在自定义用户代码中获取和配置AOP代理实例的简单方法。</p>
</blockquote>
<h1 id="AopProxyFactory-gt-DefaultAopProxyFactory"><a href="#AopProxyFactory-gt-DefaultAopProxyFactory" class="headerlink" title="AopProxyFactory -&gt; DefaultAopProxyFactory"></a>AopProxyFactory -&gt; DefaultAopProxyFactory</h1><blockquote>
<p><strong>DefaultAopProxyFactory</strong></p>
<p>默认的AopProxyFactory实现，创建CGLIB代理或JDK动态代理。</p>
<p>创建一个CGLIB代理，如果一个给定的AdvisedSupport实例如下所示:</p>
<ul>
<li>设置了 optimize 标志</li>
<li>设置了 proxyTargetClass 标志</li>
<li>没有指定代理接口</li>
</ul>
<p>通常，指定proxyTargetClass来强制使用CGLIB代理，或者指定一个或多个接口来使用JDK动态代理</p>
</blockquote>
<ul>
<li>createAopProxy</li>
</ul>
<h1 id="BeanDefinitionRegistry"><a href="#BeanDefinitionRegistry" class="headerlink" title="BeanDefinitionRegistry"></a>BeanDefinitionRegistry</h1><ul>
<li>保存bean定义的注册中心的接口，例如RootBeanDefinition和ChildBeanDefinition实例。 通常由内部使用AbstractBeanDefinition层次结构的Beanfactories实现。</li>
<li>这是Spring bean工厂包中封装bean定义注册的唯一接口。标准的BeanFactory接口只包括对完全配置的工厂实例的访问。</li>
<li>Spring bean定义的读者希望使用这个接口的实现。Spring core 中已知的实现者有DefaultListableBeanFactory和GenericApplicationContext。</li>
</ul>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/SpringBoot/">SpringBoot</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2022/03/24/%E5%85%B3%E4%BA%8E%E5%86%85%E5%B5%8C%E6%9C%8D%E5%8A%A1%E5%99%A8/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">关于内嵌服务器</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2022/03/21/SpringBoot-web-%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/">
        <span class="next-text nav-default">SpringBoot-web-问题记录</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2014 -
    
    2022
    <span class="footer-author">青马流光.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> and <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
